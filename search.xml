<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SurfaceControl事务提交过程]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfacecontrol-transaction%2F</url>
    <content type="text"><![CDATA[综述 SurfaceControl，顾明思议它是Surface的控制管理者，我们知道Surface是应用层用户进行UI绘制的绘图表面，它由WindowManagerService创建，WindowManagerService管理着窗口对象WindowState，Window是一个抽象的概念，它属于设计层面使用的类，而Surface实际上才是实现上的窗口实体。所以当WMS对Window做了改变，比如调整layerStack，Z-order，大小,位置等后需要通过SurfaceControl来告知SurfaceFlinger，以便SurfaceFlinger更新其在SF端的Layer图层进行合成渲染，这个Layer图层实际上和应用层使用的Surface是对应的。本篇我们将通过SuraceControl来了解这些属性更新的具体过程。 SurfaceControl的创建 123456789101112131415161718192021222324public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Configuration outConfig, Surface outSurface) &#123; .... try &#123; if (!win.mHasSurface) &#123; surfaceChanged = true; &#125; //创建SurfaceControl 准备画布 SurfaceControl surfaceControl = winAnimator.createSurfaceLocked(); if (surfaceControl != null) &#123; outSurface.copyFrom(surfaceControl);//Surface从SurfaceControl中得到 if (SHOW_TRANSACTIONS) Slog.i(TAG, " OUT SURFACE " + outSurface + ": copied"); &#125; else &#123; // For some reason there isn't a surface. Clear the // caller's object so they see the same state. outSurface.release(); &#125; &#125; catch (Exception e) &#123;&#125; ....&#125; 在之前介绍创建Surface的流程中我们知道SurfaceControl的创建过程是在WMS的relayoutWindow方法中进行的，Surface是从SurfaceControl中取到的。它实际是通过WindowStateAnimator的createSurfaceLocked创建。 123456789101112131415161718192021222324252627282930313233SurfaceControl createSurfaceLocked() &#123; .... //创建SurfaceControl mSurfaceControl = new SurfaceControl( mSession.mSurfaceSession, attrs.getTitle().toString(), w, h, format, flags); .... //这里通过SurfaceControl的transaction来提交Surface的设置 SurfaceControl.openTransaction(); try &#123; try &#123; mSurfaceX = mWin.mFrame.left + mWin.mXOffset; mSurfaceY = mWin.mFrame.top + mWin.mYOffset; mSurfaceControl.setPosition(mSurfaceX, mSurfaceY);//设置position mSurfaceLayer = mAnimLayer; mSurfaceControl.setLayerStack(mLayerStack);//设置layerStack mSurfaceControl.setLayer(mAnimLayer);//设置Z order mSurfaceControl.setAlpha(0);//设置透明度 0? mSurfaceShown = false; &#125; catch (RuntimeException e) &#123; Slog.w(TAG, "Error creating surface in " + w, e); mService.reclaimSomeSurfaceMemoryLocked(this, "create-init", true); &#125; mLastHidden = true; &#125; finally &#123; SurfaceControl.closeTransaction(); if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, "&lt;&lt;&lt; CLOSE TRANSACTION createSurfaceLocked"); &#125; ...&#125; WindowStateAnimator的createSurfaceLocked负责创建SurfaceControl对象，同时会开启一个事务来提交surface的初始属性。属性的设置是通过SurfaceControl的一系列set方法进行设置的。事务过程通过openTransaction和closeTransaction来控制。 属性设置和事务提交 下面我们就具体分析这两个方法是如何进行属性设置和事务提交的。 1234567891011121314151617public class SurfaceControl &#123; /** start a transaction */ public static void openTransaction() &#123; nativeOpenTransaction(); &#125; /** end a transaction */ public static void closeTransaction() &#123; nativeCloseTransaction(); &#125; public void setLayer(int zorder) &#123; checkNotReleased(); nativeSetLayer(mNativeObject, zorder); &#125;&#125; 这里我们看的是Z-order的属性设置，属性的设置和提交都是通过JNI层进行一步处理的，我们接着看android_view_SurfaceControl.cpp中的JNI实现。 123456789101112131415161718static void nativeSetLayer(JNIEnv* env, jclass clazz, jint nativeObject, jint zorder) &#123; SurfaceControl* const ctrl = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject); status_t err = ctrl-&gt;setLayer(zorder); if (err &lt; 0 &amp;&amp; err != NO_INIT) &#123; doThrowIAE(env); &#125;&#125;//开启事务static void nativeOpenTransaction(JNIEnv* env, jclass clazz) &#123; SurfaceComposerClient::openGlobalTransaction();&#125;//提交事务static void nativeCloseTransaction(JNIEnv* env, jclass clazz) &#123; SurfaceComposerClient::closeGlobalTransaction();&#125; 属性设置通过native层的SurfaceControl来设置，提交实际上是经过SurfaceComposerClient处理，之前我们在介绍Surface创建流程是有过介绍，它实际上是SF端的Client在客户端的Binder代理，在WMS中的为应用端创建Session会话时也会构造一个SurfaceSession，这个SurfaceSession实际上就是SurfaceComposerClient在上层的体现。 属性设置 下面我们先看属性是如何设置的 1234567891011121314SurfaceControl::SurfaceControl( const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbp) : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)&#123;&#125;status_t SurfaceControl::setLayer(int32_t layer) &#123; status_t err = validate(); if (err &lt; 0) return err; const sp&lt;SurfaceComposerClient&gt;&amp; client(mClient); return client-&gt;setLayer(mHandle, layer);&#125; 在SurfaceControl中属性设置最终还是通过我们创建的SurfaceComposerClient进行处理的，它的构造方法中的client就是我们在SurfaceSession中创建的 SurfaceComposerClient。 12345678910111213SurfaceComposerClient::SurfaceComposerClient() : mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;inline Composer&amp; SurfaceComposerClient::getComposer() &#123; return mComposer;&#125;status_t SurfaceComposerClient::setLayer(const sp&lt;IBinder&gt;&amp; id, int32_t z) &#123; return getComposer().setLayer(this, id, z);&#125; 创建SurfaceComposerClient对象时同时会创建一个mComposer的Composer对象，它是一个单例，我们的属性值最终是通过它来进行设置的，我们看看Composer的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Composer : public Singleton&lt;Composer&gt;&#123; friend class Singleton&lt;Composer&gt;; mutable Mutex mLock; SortedVector&lt;ComposerState&gt; mComposerStates; SortedVector&lt;DisplayState &gt; mDisplayStates; uint32_t mForceSynchronous; uint32_t mTransactionNestCount; bool mAnimation; Composer() : Singleton&lt;Composer&gt;(), mForceSynchronous(0), mTransactionNestCount(0), mAnimation(false) &#123; &#125; void openGlobalTransactionImpl(); void closeGlobalTransactionImpl(bool synchronous); void setAnimationTransactionImpl(); layer_state_t* getLayerStateLocked( const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id); DisplayState&amp; getDisplayStateLocked(const sp&lt;IBinder&gt;&amp; token);public: ... status_t setPosition(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, float x, float y); status_t setSize(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, uint32_t w, uint32_t h); status_t setLayer(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, int32_t z); status_t setLayerStack(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, uint32_t layerStack); ... static void setAnimationTransaction() &#123; Composer::getInstance().setAnimationTransactionImpl(); &#125; static void openGlobalTransaction() &#123; Composer::getInstance().openGlobalTransactionImpl(); &#125; static void closeGlobalTransaction(bool synchronous) &#123; Composer::getInstance().closeGlobalTransactionImpl(synchronous); &#125;&#125;; 通过Composer的定义我们可以大概看出其实属性的设置和提交最终都是通过它来进行的。我们先看设置的过程 123456789101112131415161718192021222324252627status_t Composer::setLayer(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, int32_t z) &#123; Mutex::Autolock _l(mLock); layer_state_t* s = getLayerStateLocked(client, id); if (!s) return BAD_INDEX; s-&gt;what |= layer_state_t::eLayerChanged; s-&gt;z = z; return NO_ERROR;&#125;layer_state_t* Composer::getLayerStateLocked( const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id) &#123; ComposerState s; s.client = client-&gt;mClient; s.state.surface = id; ssize_t index = mComposerStates.indexOf(s); if (index &lt; 0) &#123; // we don't have it, add an initialized layer_state to our list index = mComposerStates.add(s); &#125; ComposerState* const out = mComposerStates.editArray(); return &amp;(out[index].state);&#125; setLayer首先通过getLayerStateLocked获取到一个layer_state_t对象，它保存的了layer的属性信息，layer_state_t实际上是由Composer类的mComposerStates维护的，它是一个SortedVector，即ComposerState的有序集合。我们最终从ComposerState取出layer_state_t，然后将我们设置的属性保存在里面。 提交属性事务 接下来就是提交属性的过程，属性提交通过SurfaceComposerClient的openGlobalTransaction和closeGlobalTransaction 实现 123456789101112131415void SurfaceComposerClient::openGlobalTransaction() &#123; Composer::openGlobalTransaction();&#125;void SurfaceComposerClient::closeGlobalTransaction(bool synchronous) &#123; Composer::closeGlobalTransaction(synchronous);&#125;static void openGlobalTransaction() &#123; Composer::getInstance().openGlobalTransactionImpl();&#125;static void closeGlobalTransaction(bool synchronous) &#123; Composer::getInstance().closeGlobalTransactionImpl(synchronous);&#125; 它内部实际上是使用Composer的静态方法实现，而在Compser的类定义中我们看到，这两个静态方法的实现实际上是会使用我们为 SurfaceComposerClient创建的单例mComposer来进行操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243void Composer::openGlobalTransactionImpl() &#123; &#123; // scope for the lock Mutex::Autolock _l(mLock); mTransactionNestCount += 1; &#125;&#125;void Composer::closeGlobalTransactionImpl(bool synchronous) &#123; sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService()); Vector&lt;ComposerState&gt; transaction; Vector&lt;DisplayState&gt; displayTransaction; uint32_t flags = 0; &#123; // scope for the lock Mutex::Autolock _l(mLock); mForceSynchronous |= synchronous; if (!mTransactionNestCount) &#123; ALOGW("At least one call to closeGlobalTransaction() was not matched by a prior " "call to openGlobalTransaction()."); &#125; else if (--mTransactionNestCount) &#123; return; &#125; transaction = mComposerStates; mComposerStates.clear(); displayTransaction = mDisplayStates; mDisplayStates.clear(); if (mForceSynchronous) &#123; flags |= ISurfaceComposer::eSynchronous; &#125; if (mAnimation) &#123; flags |= ISurfaceComposer::eAnimation; &#125; mForceSynchronous = false; mAnimation = false; &#125; sm-&gt;setTransactionState(transaction, displayTransaction, flags);&#125; openGlobalTransactionImpl的实现只是更新事务计数值mTransactionNestCount，真正的提交操作是在closeGlobalTransactionImpl，这里的synchronous默认为false。我们之前设置的属性保存在mComposerStates中，这里将其添加到transaction中，并通过ISurfaceComposer的setTransactionState提交给SF。这里ISurfaceComposer是SurfaceFlinger的Binder 本地代理。 12345678910111213141516171819202122232425262728293031323334353637383940414243void SurfaceFlinger::setTransactionState( const Vector&lt;ComposerState&gt;&amp; state, const Vector&lt;DisplayState&gt;&amp; displays, uint32_t flags)&#123; ATRACE_CALL(); Mutex::Autolock _l(mStateLock); uint32_t transactionFlags = 0; ... size_t count = displays.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const DisplayState&amp; s(displays[i]); transactionFlags |= setDisplayStateLocked(s); &#125; count = state.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const ComposerState&amp; s(state[i]); // Here we need to check that the interface we're given is indeed // one of our own. A malicious client could give us a NULL // IInterface, or one of its own or even one of our own but a // different type. All these situations would cause us to crash. // // NOTE: it would be better to use RTTI as we could directly check // that we have a Client*. however, RTTI is disabled in Android. if (s.client != NULL) &#123; sp&lt;IBinder&gt; binder = s.client-&gt;asBinder(); if (binder != NULL) &#123; String16 desc(binder-&gt;getInterfaceDescriptor()); if (desc == ISurfaceComposerClient::descriptor) &#123; sp&lt;Client&gt; client( static_cast&lt;Client *&gt;(s.client.get()) ); transactionFlags |= setClientStateLocked(client, s.state); &#125; &#125; &#125; &#125; if (transactionFlags) &#123; // this triggers the transaction setTransactionFlags(transactionFlags); ... &#125;&#125; 在setTransactionState中会通过setClientStateLocked通知SF更新layer的属性。这里会从ComposerState中取出 state,即layer_state_t。设置完成后会通过setTransactionFlags通知SF进行layer属性的变更操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162uint32_t SurfaceFlinger::setClientStateLocked( const sp&lt;Client&gt;&amp; client, const layer_state_t&amp; s)&#123; uint32_t flags = 0; sp&lt;Layer&gt; layer(client-&gt;getLayerUser(s.surface)); if (layer != 0) &#123; const uint32_t what = s.what; if (what &amp; layer_state_t::ePositionChanged) &#123; if (layer-&gt;setPosition(s.x, s.y)) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eLayerChanged) &#123; // NOTE: index needs to be calculated before we update the state ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer); if (layer-&gt;setLayer(s.z)) &#123; mCurrentState.layersSortedByZ.removeAt(idx); mCurrentState.layersSortedByZ.add(layer); // we need traversal (state changed) // AND transaction (list changed) flags |= eTransactionNeeded|eTraversalNeeded; &#125; &#125; if (what &amp; layer_state_t::eSizeChanged) &#123; if (layer-&gt;setSize(s.w, s.h)) &#123; flags |= eTraversalNeeded; &#125; &#125; if (what &amp; layer_state_t::eAlphaChanged) &#123; if (layer-&gt;setAlpha(uint8_t(255.0f*s.alpha+0.5f))) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eMatrixChanged) &#123; if (layer-&gt;setMatrix(s.matrix)) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eTransparentRegionChanged) &#123; if (layer-&gt;setTransparentRegionHint(s.transparentRegion)) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eVisibilityChanged) &#123; if (layer-&gt;setFlags(s.flags, s.mask)) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eCropChanged) &#123; if (layer-&gt;setCrop(s.crop)) flags |= eTraversalNeeded; &#125; if (what &amp; layer_state_t::eLayerStackChanged) &#123; // NOTE: index needs to be calculated before we update the state ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer); if (layer-&gt;setLayerStack(s.layerStack)) &#123; mCurrentState.layersSortedByZ.removeAt(idx); mCurrentState.layersSortedByZ.add(layer); // we need traversal (state changed) // AND transaction (list changed) flags |= eTransactionNeeded|eTraversalNeeded; &#125; &#125; &#125; return flags;&#125; setClientStateLocked方法首先通过Client的getLayerUser取出Layer图层，这个图层就是我们为应用端创建Surface时在SF端创建的。它通过SF的addClientLayer添加到Client以及SF的mCurrentState.layersSortedByZ中。所以这里将我们设置的属性值最终更新到SF管理的layer中。 设置完SF中layer的属性后需要通知SF进行layer的属性变更，实际上就是让SF进行一次合成渲染操作以便更新应用界面，这个是通过setTransactionFlags进行的。 123456789101112131415161718192021222324252627282930313233343536373839404142uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags) &#123; uint32_t old = android_atomic_or(flags, &amp;mTransactionFlags); if ((old &amp; flags)==0) &#123; // wake the server up signalTransaction(); &#125; return old;&#125;void SurfaceFlinger::signalTransaction() &#123; mEventQueue.invalidate();&#125;void SurfaceFlinger::onMessageReceived(int32_t what) &#123;//MessageQueue中消息实际是通过SF来处理的 ATRACE_CALL(); if(mDelayFlag) &#123; usleep(20000); mDelayFlag = 0; &#125; switch (what) &#123; //处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。 case MessageQueue::TRANSACTION: handleMessageTransaction(); break; //用于处理Layer或者display属性的变化以及Layer对应buffer的更新 case MessageQueue::INVALIDATE: handleMessageTransaction();//处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。 handleMessageInvalidate();//主要是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域 signalRefresh();//进行刷新 break; /** * 表示SurfaceFlinger需要进行一次合成操作(Refresh): * 1) Layer属性的变化导致window state发生变化; 2) Layer有新的buffer到来; 3) HWC请求进行一次repaint。 */ case MessageQueue::REFRESH: handleMessageRefresh();//合并和渲染输出 break; &#125;&#125; signalTransaction会通过SF的MessageQueue安排一次VSYNC信号，从而触发INVALIDATE事件，然后在SF中再通过onMessageReceived处理layer属性变更以及合成和渲染的工作。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WindowManagerService添加窗口测试]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-wms-add-test%2F</url>
    <content type="text"><![CDATA[WindowManagerService创建窗口测试 通过WindowManagerService我们可以直接申请、渲染并注销自己的窗口，而不需要经过Activity，Dialog等系统组件，通过本测试，我们可以清楚WMS最基本的工作方式。以下代码基于Android4.4 创建一个SampleWindow类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package test.wms.samplewindow;import android.content.Context;import android.content.res.Configuration;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Point;import android.graphics.Rect;import android.os.Binder;import android.os.Bundle;import android.os.IBinder;import android.os.Looper;import android.os.ParcelFileDescriptor;import android.view.Choreographer;import android.view.Display;import android.view.DragEvent;import android.view.Gravity;import android.view.InputEvent;import android.view.MotionEvent;import android.view.Surface;import android.view.View;import android.view.WindowManager;import android.os.ServiceManager;import android.view.InputEventReceiver;import android.view.InputChannel;import android.view.DisplayInfo;import android.view.WindowManagerGlobal;import android.view.IWindow;import android.view.IWindowSession;import android.view.IWindowManager;import android.hardware.display.IDisplayManager;public class SampleWindow &#123; public static void main(String[] args) &#123; try&#123; //SampleWindow.Run()是这个程序的主入口 new SampleWindow().Run(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //IWindowSession 是客户端向WMS请求窗口操作的中间代理，并且是进程唯一的 IWindowSession mSession = null; //InputChannel 是窗口接收用户输入事件的管道。在第5章中将对其进行详细的探讨 InputChannel mInputChannel = new InputChannel(); // 下面的三个Rect保存了窗口的布局结果。其中mFrame表示了窗口在屏幕上的位置与尺寸 // 在4.4中将详细介绍它们的作用以及计算原理 Rect mInsets1 = new Rect(); Rect mInsets2 = new Rect(); Rect mFrame = new Rect(); Rect mVisibleInsets = new Rect(); Configuration mConfig = new Configuration(); //窗口的Surface，在此Surface上进行的绘制都将在此窗口上显示出来 Surface mSurface = new Surface(); // 用于在窗口上进行绘图的画刷 Paint mPaint = new Paint(); // 添加窗口所需的令牌 IBinder mToken = new Binder(); // 一个窗口对象，本例演示了如何将此窗口添加到WMS中，并在其上进行绘制操作 MyWindow mWindow = new MyWindow(); //WindowManager.LayoutParams定义了窗口的布局属性，包括位置、尺寸以及窗口类型等 WindowManager.LayoutParams mLp = new WindowManager.LayoutParams(); Choreographer mChoreographer = null; //InputHandler 用于从InputChannel接收按键事件做出响应 InputHandler mInputHandler = null; boolean mContinueAnime = true; public void Run() throws Exception&#123; Looper.prepareMainLooper(); // 获取WMS服务 IWindowManager wms = IWindowManager.Stub.asInterface( ServiceManager.getService(Context.WINDOW_SERVICE)); // 通过WindowManagerGlobal获取进程唯一的IWindowSession实例。它将用于向WMS // 发送请求。注意这个函数在较早的Android版本（如4.1）位于ViewRootImpl类中 mSession= WindowManagerGlobal.getWindowSession(); // 获取屏幕分辨率 IDisplayManager dm = IDisplayManager.Stub.asInterface( ServiceManager.getService(Context.DISPLAY_SERVICE)); DisplayInfo di = dm.getDisplayInfo(Display.DEFAULT_DISPLAY); Point scrnSize = new Point(di.appWidth, di.appHeight); // 初始化WindowManager.LayoutParams initLayoutParams(scrnSize); // 将新窗口添加到WMS installWindow(wms); // 初始化Choreographer的实例，此实例为线程唯一。这个类的用法与Handler // 类似，不过它总是在VSYC同步时回调，所以比Handler更适合做动画的循环器[1] mChoreographer= Choreographer.getInstance(); // 开始处理第一帧的动画 scheduleNextFrame(); // 当前线程陷入消息循环，直到Looper.quit() Looper.loop(); // 标记不要继续绘制动画帧 mContinueAnime= false; // 卸载当前Window uninstallWindow(wms); &#125; public void initLayoutParams(Point screenSize) &#123; // 标记即将安装的窗口类型为SYSTEM_ALERT，这将使得窗口的ZOrder顺序比较靠前 mLp.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; mLp.setTitle("SampleWindow"); // 设定窗口的左上角坐标以及高度和宽度 mLp.gravity = Gravity.LEFT | Gravity.TOP; mLp.x = screenSize.x / 4; mLp.y = screenSize.y / 4; mLp.width = screenSize.x / 2; mLp.height = screenSize.y / 2; // 和输入事件相关的Flag，希望当输入事件发生在此窗口之外时，其他窗口也可以接受输入事件 mLp.flags = mLp.flags | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; &#125; public void installWindow(IWindowManager wms) throws Exception &#123; // 首先向WMS声明一个Token，任何一个Window都需要隶属与一个特定类型的Token wms.addWindowToken(mToken,WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); // 设置窗口所隶属的Token mLp.token = mToken; // 通过IWindowSession将窗口安装进WMS，注意，此时仅仅是安装到WMS，本例的Window // 目前仍然没有有效的Surface。不过，经过这个调用后，mInputChannel已经可以用来接受 // 输入事件了 mSession.add(mWindow,0, mLp, View.VISIBLE, mInsets2, mInputChannel); /*通过IWindowSession要求WMS对本窗口进行重新布局，经过这个操作后，WMS将会为窗口 创建一块用于绘制的Surface并保存在参数mSurface中。同时，这个Surface被WMS放置在 LayoutParams所指定的位置上 */ mSession.relayout(mWindow,0, mLp, mLp.width, mLp.height, View.VISIBLE, 0, mFrame, mInsets1,mInsets2,mVisibleInsets, mConfig, mSurface); if(!mSurface.isValid()) &#123; throw new RuntimeException("Failed creating Surface."); &#125; // 基于WMS返回的InputChannel创建一个Handler，用于监听输入事件 //mInputHandler一旦被创建，就已经在监听输入事件了 mInputHandler= new InputHandler(mInputChannel, Looper.myLooper()); &#125; public void uninstallWindow(IWindowManager wms) throws Exception &#123; // 从WMS处卸载窗口 mSession.remove(mWindow); // 从WMS处移除之前添加的Token wms.removeWindowToken(mToken); &#125; public void scheduleNextFrame() &#123; // 要求在显示系统刷新下一帧时回调mFrameRender，注意，只回调一次 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION , mFrameRender, null); &#125; // 这个Runnable对象用以在窗口上描绘一帧 public Runnable mFrameRender = new Runnable() &#123; @Override public void run() &#123; try&#123; // 获取当期时间戳 long time = mChoreographer.getFrameTime() % 1000; // 绘图 if (mSurface.isValid()) &#123; Canvas canvas = mSurface.lockCanvas(null); canvas.drawColor(Color.DKGRAY); canvas.drawRect(2 * mLp.width * time / 1000 - mLp.width, 0, 2 *mLp.width * time / 1000, mLp.height,mPaint); mSurface.unlockCanvasAndPost(canvas); mSession.finishDrawing(mWindow); &#125; if(mContinueAnime)&#123; scheduleNextFrame(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; // 定义一个类继承InputEventReceiver，用以在其onInputEvent()函数中接收窗口的输入事件 class InputHandler extends InputEventReceiver &#123; Looper mLooper = null; public InputHandler(InputChannel inputChannel, Looper looper) &#123; super(inputChannel,looper); mLooper= looper; &#125; @Override public void onInputEvent(InputEvent event) &#123; if(event instanceof MotionEvent) &#123; MotionEvent me = (MotionEvent)event; if (me.getAction() ==MotionEvent.ACTION_UP) &#123; // 退出程序 mLooper.quit(); &#125; &#125; super.onInputEvent(event); &#125; &#125; // 实现一个继承自IWindow.Stub的类MyWindow class MyWindow extends IWindow.Stub &#123; @Override public void resized(Rect frame, Rect overscanInsets, Rect contentInsets, Rect visibleInsets, boolean reportDraw, Configuration newConfig) &#123; &#125; @Override public void moved(int newX, int newY) &#123; &#125; @Override public void dispatchAppVisibility(boolean visible) &#123; &#125; @Override public void dispatchGetNewSurface() &#123; &#125; @Override public void dispatchScreenState(boolean on) &#123; &#125; @Override public void windowFocusChanged(boolean hasFocus, boolean touchEnabled) &#123; &#125; @Override public void executeCommand(String command, String parameters, ParcelFileDescriptor out) &#123; &#125; @Override public void closeSystemDialogs(String reason) &#123; &#125; @Override public void dispatchWallpaperOffsets(float x, float y, float xStep, float yStep, boolean sync) &#123; &#125; @Override public void dispatchDragEvent(DragEvent event) &#123; &#125; @Override public void dispatchSystemUiVisibilityChanged(int seq, int globalUi, int localValue, int localChanges) &#123; &#125; @Override public void dispatchWallpaperCommand(String action, int x, int y, int z, Bundle extras, boolean sync) &#123; &#125; @Override public void doneAnimating() &#123; &#125; &#125;&#125; 创建Android.mk文件 123456789# Copyright 2012 The Android Open Source ProjectLOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_MODULE_TAGS := optionalLOCAL_MODULE := samplewindowinclude $(BUILD_JAVA_LIBRARY) 创建编译目录 将Android.mk和SampleWindow.java文件放在frameworks\base\cmds\samplewindow目录下，最终的结构如下： frameworks\base\cmds\samplewindow\src\test\wms\samplewindow\SampleWindow.java frameworks\base\cmds\samplewindow\Android.mk 编译模块 cd到Android源码目录中执行: 12345. /build/envsetup.shlunch xxxcd frameworks\base\cmds\samplewindow\mm 经过编译后的模块最终会在out\target\product\system目录下生成samplewindow.jar文件，将该文件拷贝出来 将jar文件转换为dex文件 由于jar文件不能再Android系统中直接运行，需要转换为dex文件，所以我们需要通过sdk工具dx来进行转换，dx脚本在 sdk/build-tools/目录下，执行dx --dex --output=samplewindow.dex samplewindow.jar生成dex文件 执行dex文件 通过app_process 命令来执行dex文件，命令如下 1app_process -Djava.class.path=/data/local/tmp/samplewindow.dex /system/bin test.wms.samplewindow.SampleWindow 执行完成后手机屏幕就会显示我们创建的窗口，根据我们的设置，当在窗口触摸手指离开后退出窗口。 参考 深入理解WindowManagerService https://blog.csdn.net/innost/article/details/47660193]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[contentprovider源码走读]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fasop-contentprovider-src%2F</url>
    <content type="text"><![CDATA[获取ContentResolver 12345678910111213@Overridepublic ContentResolver getContentResolver() &#123; return mContentResolver;&#125;//Context实例的创建private ContextImpl(ContextImpl container, ActivityThread mainThread, LoadedApk packageInfo, IBinder activityToken, UserHandle user, boolean restricted, Display display, Configuration overrideConfiguration) &#123; ... mContentResolver = new ApplicationContentResolver(this, mainThread, user); ...&#125; 这里的ApplicationCOntentResolver继承自ContentResolver，ContentResolver是一个抽象类。它是ContextImpl的内部类。 query 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//ContentResolver.javapublic final Cursor query(final Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal) &#123; //先根据uri获取到ICP，ICP是ContentProvider的binder接口，继承自IInterface，这里获取unstable类型的 IContentProvider unstableProvider = acquireUnstableProvider(uri); if (unstableProvider == null) &#123; return null; &#125; IContentProvider stableProvider = null; Cursor qCursor = null; try &#123; long startTime = SystemClock.uptimeMillis(); ICancellationSignal remoteCancellationSignal = null; if (cancellationSignal != null) &#123; cancellationSignal.throwIfCanceled(); remoteCancellationSignal = unstableProvider.createCancellationSignal(); cancellationSignal.setRemote(remoteCancellationSignal); &#125; try &#123; //通过ICP查询，这里涉及到Binder调用 qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); &#125; catch (DeadObjectException e) &#123; //远程进程死亡，负责清理unstable的ICP unstableProviderDied(unstableProvider); //随后创建stable的ICP stableProvider = acquireProvider(uri); if (stableProvider == null) &#123; return null; &#125; //再次进行查询，取到Cursor qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); &#125; if (qCursor == null) &#123; return null; &#125; // Force query execution. Might fail and throw a runtime exception here. qCursor.getCount(); long durationMillis = SystemClock.uptimeMillis() - startTime; maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder); // Wrap the cursor object into CursorWrapperInner object. CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri)); stableProvider = null; qCursor = null; return wrapper; &#125; catch (RemoteException e) &#123; // Arbitrary and not worth documenting, as Activity // Manager will kill this process shortly anyway. return null; &#125; finally &#123; if (qCursor != null) &#123; qCursor.close(); &#125; if (cancellationSignal != null) &#123; cancellationSignal.setRemote(null); &#125; if (unstableProvider != null) &#123; releaseUnstableProvider(unstableProvider); &#125; if (stableProvider != null) &#123; releaseProvider(stableProvider); &#125; &#125;&#125; 以CursorWrapperInner返回，它实现了Cursor接口。这里unstable和stable的区别在于，unstable的ContentProvider 不会因为其远程服务进程的死亡而导致app被杀掉，而stable会。 1234567891011//ContentResolver.javapublic final IContentProvider acquireUnstableProvider(Uri uri) &#123; if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; return null; &#125; String auth = uri.getAuthority(); if (auth != null) &#123; return acquireUnstableProvider(mContext, uri.getAuthority()); &#125; return null;&#125; 这里acquireUnstableProvider是个抽象方法，那么应该在其子类ApplicationContentResolver中实现。 12345678910111213141516171819202122232425262728293031//ApplicationContentResolver.java@Overrideprotected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; return mMainThread.acquireProvider(c, auth, mUser.getIdentifier(), false);&#125;//ActivityThread.javapublic final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; //这里阻塞等待直到获取Provider代理，如果Provider未启动，则先启动 holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; &#125; if (holder == null) &#123; Slog.e(TAG, "Failed to find provider info for " + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; 这里我们可以看到它ICP先试通过acquireExistingProvider来获取，如果取到就直接返回，否则就需要通过AMS的getContentProvider来取到的， 它返回一个IActivityManager.ContentProviderHolder成员holder,其中的provider就是ICP的binder代理接口。那么acquireExistingProvider 大概就是从缓存里取吧。 123456789101112131415161718192021222324252627282930//ActivityThread.javapublic final IContentProvider acquireExistingProvider( Context c, String auth, int userId, boolean stable) &#123; synchronized (mProviderMap) &#123; final ProviderKey key = new ProviderKey(auth, userId);//以auth和userid构造一个key final ProviderClientRecord pr = mProviderMap.get(key);//通过该key取到ProviderClientRecord if (pr == null) &#123; return null; &#125; IContentProvider provider = pr.mProvider;//从ProviderClientRecord就可以取到ICP的binder代理接口 IBinder jBinder = provider.asBinder(); if (!jBinder.isBinderAlive()) &#123;//判断binder server是否还活着 // The hosting process of the provider has died; we can't // use this one. Log.i(TAG, "Acquiring provider " + auth + " for user " + userId + ": existing object's process dead"); handleUnstableProviderDiedLocked(jBinder, true); return null; &#125; // Only increment the ref count if we have one. If we don't then the // provider is not reference counted and never needs to be released. ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; incProviderRefLocked(prc, stable);//增加该provider的引用计数 &#125; return provider; &#125;&#125; 其中mProviderMap中记录的是本进程的ContentProvider，它再应用启动时候就进行了初始化，这样如果是当前应用使用自身的ContentProvider，就不需要再去 AMS中查找了，直接从这里就可以取到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//ActivityManagerService.javapublic final ContentProviderHolder getContentProvider( IApplicationThread caller, String name, int userId, boolean stable) &#123; …… userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, true, "getContentProvider", null); return getContentProviderImpl(caller, name, null, stable, userId);&#125; private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; synchronized(this) &#123; ProcessRecord r = getRecordForAppLocked(caller); ... cpr = mProviderMap.getProviderByName(name, userId);//查看这个contentProvider是否已经有记录 boolean providerRunning = cpr != null; if (providerRunning) &#123;//content provider已经存在 if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; //Content provider被允许运行在调用者进程，这样让调用者自己实例化一个content provider实例即可 ContentProviderHolder holder = cpr.newHolder(null); holder.provider = null; return holder; &#125; &#125; …… //content provider没在运行 if (!providerRunning) &#123; …… ComponentName comp = new ComponentName(cpi.packageName, cpi.name); cpr = mProviderMap.getProviderByClass(comp, userId); final boolean firstClass = cpr == null; if (firstClass) &#123; ApplicationInfo ai = AppGlobals.getPackageManager(). getApplicationInfo( cpi.applicationInfo.packageName, STOCK_PM_FLAGS, userId); ai = getAppInfoForUser(ai, userId); //为content provider创建record cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton); &#125; if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; return cpr.newHolder(null); &#125; final int N = mLaunchingProviders.size(); int i; for (i=0; i&lt;N; i++) &#123; if (mLaunchingProviders.get(i) == cpr) &#123; break; &#125; &#125; if (i &gt;= N) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; // Content provider is now in use, its package can't be stopped. try &#123; AppGlobals.getPackageManager().setPackageStoppedState( cpr.appInfo.packageName, false, userId); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e); &#125; // Use existing process if already started ProcessRecord proc = getProcessRecordLocked( cpi.processName, cpr.appInfo.uid, false);//获取进程信息 if (proc != null &amp;&amp; proc.thread != null) &#123;//如果所在进程已经启动 proc.pubProviders.put(cpi.name, cpr); try &#123; //启动content provider并发布 proc.thread.scheduleInstallProvider(cpi); &#125; catch (RemoteException e) &#123; &#125; &#125; else &#123; //启动conent provider的目标进程 proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false); …… &#125; cpr.launchingApp = proc; mLaunchingProviders.add(cpr); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; // Make sure the provider is published (the same provider class // may be published under multiple names). if (firstClass) &#123; mProviderMap.putProviderByClass(comp, cpr); &#125; mProviderMap.putProviderByName(name, cpr); conn = incProviderCountLocked(r, cpr, token, stable); &#125; &#125; //循环等待,直到provider发布完成才会退出循环. synchronized (cpr) &#123; while (cpr.provider == null) &#123; ... cpr.wait(); ... &#125; &#125;&#125; Provoider的install流程 1234567891011121314151617181920212223242526272829303132public void handleInstallProvider(ProviderInfo info) &#123; installContentProviders(mInitialApplication, Lists.newArrayList(info));&#125;private void installContentProviders( Context context, List&lt;ProviderInfo&gt; providers) &#123; final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results = new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;(); for (ProviderInfo cpi : providers) &#123; if (DEBUG_PROVIDER) &#123; StringBuilder buf = new StringBuilder(128); buf.append("Pub "); buf.append(cpi.authority); buf.append(": "); buf.append(cpi.name); &#125; IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); if (cph != null) &#123; cph.noReleaseNeeded = true; results.add(cph); &#125; &#125; try &#123; //发布该provider ActivityManagerNative.getDefault().publishContentProviders( getApplicationThread(), results); &#125; catch (RemoteException ex) &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// ActivityThread.javaprivate IActivityManager.ContentProviderHolder installProvider(Context context, IActivityManager.ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; if (holder == null || holder.provider == null) &#123; try&#123; final java.lang.ClassLoader cl = c.getClassLoader(); localProvider = (ContentProvider)cl. loadClass(info.name).newInstance(); provider = localProvider.getIContentProvider(); localProvider.attachInfo(c, info); &#125; &#125; synchronized (mProviderMap) &#123; IBinder jBinder = provider.asBinder(); if (localProvider != null) &#123; ComponentName cname = new ComponentName(info.packageName, info.name); ProviderClientRecord pr = mLocalProvidersByName.get(cname); if (pr != null) &#123; provider = pr.mProvider; &#125;else&#123; holder = new IActivityManager.ContentProviderHolder(info); holder.provider = provider; holder.noReleaseNeeded = true; pr = installProviderAuthoritiesLocked(provider, localProvider, holder); mLocalProviders.put(jBinder, pr); mLocalProvidersByName.put(cname, pr); &#125; retHolder = pr.mHolder; &#125;else&#123; ... &#125; &#125; return retHolder;&#125; 该过程主要创建ContentProvider实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ActivityManagerService.javapublic final void publishContentProviders(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers) &#123; if (providers == null) &#123; return; &#125; synchronized (this) &#123; final ProcessRecord r = getRecordForAppLocked(caller); ... final long origId = Binder.clearCallingIdentity(); final int N = providers.size(); for (int i=0; i&lt;N; i++) &#123; ContentProviderHolder src = providers.get(i); if (src == null || src.info == null || src.provider == null) &#123; continue; &#125; ContentProviderRecord dst = r.pubProviders.get(src.info.name); if (dst != null) &#123; ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name); mProviderMap.putProviderByClass(comp, dst);//将实例添加到mProviderMap String names[] = dst.info.authority.split(";"); for (int j = 0; j &lt; names.length; j++) &#123; mProviderMap.putProviderByName(names[j], dst); &#125; int NL = mLaunchingProviders.size(); int j; for (j=0; j&lt;NL; j++) &#123; if (mLaunchingProviders.get(j) == dst) &#123; mLaunchingProviders.remove(j); j--; NL--; &#125; &#125; synchronized (dst) &#123; dst.provider = src.provider; dst.proc = r; dst.notifyAll(); &#125; updateOomAdjLocked(r); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125;]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx Rtmp服务器搭建-推送流]]></title>
    <url>%2F%5Bobject%20Object%5D%2Flive%2F</url>
    <content type="text"><![CDATA[基于Nginx-Rtmp的直播服务器搭建 nginx-rtmp在window上的服务端 https://github.com/illuspas/nginx-rtmp-win32 Linux上的搭建 https://juejin.im/entry/599634d2f265da248a7a66a7 测试推送流 https://www.nodemedia.cn/uploads/NodeMediaDevClient.swf 推送流到 rtmp://localhost/live/stream]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 类加载源码分析(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-classloader-src%2F</url>
    <content type="text"><![CDATA[概述 本篇将对Android的类加载机制进行分析。总体来说Android的ClassLoader分为系统ClassLoader和自定义的ClassLoader 系统的包括有三种： BootClassLoader Android系统启动时会使用BootClassLoader预加载一些类。它位于类加载器链的头部。 PathClassLoader 可以加载已经安装的apk,即也就是/data/app/package 下的apk文件，也可以加载/vendor/lib, /system/lib下的nativeLibrary。 DexClassLoader，可以加载一个未安装的apk文件。 我们在App中使用的系统类加载器默认是PathClassLoader，它的父加载器是BootClassLoader。为什么是PathClassLoader呢？因为在contextImpl的getClassLoader有如下实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// /frameworks/base/core/java/android/app/ContextImpl.java@Overridepublic ClassLoader getClassLoader() &#123; return mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();&#125;// /frameworks/base/core/java/android/app/LoadedApk.javapublic ClassLoader getClassLoader() &#123; synchronized (this) &#123; if (mClassLoader != null) &#123; return mClassLoader; &#125; …… if (mIncludeCode &amp;&amp; !mPackageName.equals("android")) &#123; …… //创建PathClassLoader mClassLoader = ApplicationLoaders.getDefault().getClassLoader( zip, libraryPath, mBaseClassLoader); …… &#125; &#125;&#125;// /frameworks/base/core/java/android/app/ApplicationLoaders.javapublic ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)&#123; ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); synchronized (mLoaders) &#123; if (parent == null) &#123; parent = baseParent; &#125; if (parent == baseParent) &#123; ClassLoader loader = mLoaders.get(zip); if (loader != null) &#123; return loader; &#125; …… //创建PathClassLoader PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent); mLoaders.put(zip, pathClassloader); return pathClassloader; &#125; PathClassLoader pathClassloader = new PathClassLoader(zip, parent); …… return pathClassloader; &#125;&#125; 从上面可以看出ContextImpl为用户提供了PathClassLoader来供App加载。 BaseDexClassLoader Android中使用PathClassLoader来加载类，其实实现的就是从本地文件系统中加载类，它继承自BaseDexClassLoader，BaseDexClassLoader继承子ClassLoader，ClassLoader是一个抽象类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// libcore/libdvm/src/main/java/java/lang/ClassLoader.javapublic abstract class ClassLoader &#123; static private class SystemClassLoader &#123; //实际上为PathClassLoader public static ClassLoader loader = ClassLoader.createSystemClassLoader(); &#125; ... /** * The parent ClassLoader. */ private ClassLoader parent; private static ClassLoader createSystemClassLoader() &#123; String classPath = System.getProperty("java.class.path", "."); //创建Android系统的ClassLoader即PathClassLoader return new PathClassLoader(classPath, BootClassLoader.getInstance()); &#125; public static ClassLoader getSystemClassLoader() &#123; return SystemClassLoader.loader; &#125; …… //返回已经被VM加载的类，如果已经加载过返回这个Class protected final Class&lt;?&gt; findLoadedClass(String className) &#123; ClassLoader loader; if (this == BootClassLoader.getInstance()) loader = null; else loader = this; return VMClassLoader.findLoadedClass(loader, className); &#125; //class加载的逻辑，先判断是否已经加载，已经加载就直接返回，否则通过findClass进行加载 protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className);//查找是否已经加载过该类 if (clazz == null) &#123;//clazz为null表示未加载过 try &#123; clazz = parent.loadClass(className, false);//先通过parent加载，这也是遵循双亲委派模型 &#125; catch (ClassNotFoundException e) &#123; // Don't want to see this. &#125; if (clazz == null) &#123;//parent loader未能加载则通过findClass来加载 clazz = findClass(className);//注意findClass在该类的实现为空，它是由子类实现类加载的逻辑的 &#125; &#125; return clazz;//返回加载的类 &#125; protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123; throw new ClassNotFoundException(className); &#125;&#125; 可以看出ClassLoader为我们实现了类加载的基本逻辑，首先它通过findLoadedClass查找要加载的类是否已经加载，如果已经加载了就直接返回，否则通过parent loader进行加载，这符合双亲委派的加载模型，如果父类loader找到该类并加载则返回，否则通过子类加载器进行加载，子类加载时通过findClass进行加载的。所以需要实现findClass的具体逻辑。那么在BaseDexClassLoader我们需要重点关注findClass的类加载逻辑。 1234567891011121314151617181920212223242526//libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.javapublic class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); //BaseDexClassLoader继承自ClassLoader，这里将findClass的任务委托给了DexPathList Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123;//没找到就抛出异常 ClassNotFoundException cnfe = new ClassNotFoundException("Didn't find class \"" + name + "\" on path: " + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c; &#125; ……&#125; 我们发现BaseDexClassLoader的实现非常简单，它内部有一个DexPathList成员pathList，在构造方法中进行初始化，它代表了一个jar/apk文件列表，在这些文件之中包含了class文件和资源文件。而在findClass中实际上是将加载类的任务委托给了pathList。那么就需要再取分析DexPathList了，在这之前我们看看它大概会包含的信息，这是我在应用中打印的ClassLoader信息，它内部的DexPathList包含了该apk和lib的信息。 classLoader: dalvik.system.PathClassLoader[DexPathList[[zip file “/data/app/com.yujian.myapplication-2.apk”],nativeLibraryDirectories=[/data/app-lib/com.yujian.myapplication-2, /system/lib]]] 123456789101112131415161718// libcore/dalvik/src/main/java/dalvik/system/DexPathList.javafinal class DexPathList &#123; ... private final Element[] dexElements;//Element是对应于dex/apk文件或者目录 …… private final File[] nativeLibraryDirectories; //这里 dexPath可以包含多个dex文件，这也是为什么会叫DexPathList public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) &#123; …… this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);//生成Element数组 …… this.nativeLibraryDirectories = splitLibraryPath(libraryPath); &#125;&#125; DexPathList有两个成员dexElements和nativeLibraryDirectories，分别用来描述dex/apk文件信息和lib文件。它们都是在DexPathList构造方法中进行初始化的。其中dexElements是通过makeDexElements和splitLibraryPath生成的。其中Element的定义如下 1234567891011121314 static class Element &#123; private final File file;//代表了源文件 private final boolean isDirectory;//当前描述的文件是否为目录 private final File zip;//源文件如果未压缩文件 zip和file就是同一个File private final DexFile dexFile;//dex文件 …… public Element(File file, boolean isDirectory, File zip, DexFile dexFile) &#123; this.file = file; this.isDirectory = isDirectory; this.zip = zip; this.dexFile = dexFile; &#125; ……&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123; ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); for (File file : files) &#123;//遍历文件 File zip = null; DexFile dex = null; String name = file.getName();//文件名 if (name.endsWith(DEX_SUFFIX)) &#123;//后缀为.dex // Raw dex file (not inside a zip/jar). try &#123; dex = loadDexFile(file, optimizedDirectory);//直接通过loadDexFile加载 &#125; catch (IOException ex) &#123; System.logE("Unable to load dex file: " + file, ex); &#125; &#125; else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX) || name.endsWith(ZIP_SUFFIX)) &#123;//后缀为.apk/.jar/.zip的情况 zip = file;//赋值给zip try &#123; dex = loadDexFile(file, optimizedDirectory); &#125; catch (IOException suppressed) &#123; /* * IOException might get thrown "legitimately" by the DexFile constructor if the * zip file turns out to be resource-only (that is, no classes.dex file in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); &#125; &#125; else if (file.isDirectory()) &#123;//为目录的情况 // We support directories for looking up resources. // This is only useful for running libcore tests. elements.add(new Element(file, true, null, null));//添加一个Element目录 true表示为目录 &#125; else &#123; System.logW("Unknown file type for: " + file); &#125; if ((zip != null) || (dex != null)) &#123; elements.add(new Element(file, false, zip, dex));//添加一个dex文件对应的Element &#125; &#125; return elements.toArray(new Element[elements.size()]);&#125; makeDexElements通过dexPath代表的dex/apk文件或者目录生成对应的elements数组，在构造DexPathList时传递的dexPath时可能包含多个文件路径的，我们上面打印的信息就只有一个apk，这里需要注意，这些文件路径经过splitDexPath返回一个ArrayList代表了dexPath所代表的文件列表。通过一个循环处理这个文件列表，针对不同的文件类型比如dex/apk/jar/zip或者目录进行不同的处理： 如果时dex文件，通过loadDexFile加载，并返回一个描述该文件的DexFile, 如果时zip/apk/jar，先保存压缩文件到zip中，然后通过loadDexFile加载并返回要描述的dex文件的DexFile 如果时目录，直接为其生成一个Element并添加到elements数组中 对于1和2两种情况最终也会未其分别创建Element并添加到elements数组中,这个elements数组最终就是我们要的dexElements。 123456789private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException &#123; if (optimizedDirectory == null) &#123;//对于PathClassLoader来说 optimizedDirectory总是为null的 return new DexFile(file);//直接new一个DexFile返回 &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); &#125;&#125; loadDexFile实际上只是为file创建一个DexFile对象。从名称上看它是专门处理dex文件的。 下面我们就看看DexPathList是如何加载类的 1234567891011121314151617public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123;//遍历dexElements DexFile dex = element.dexFile; if (dex != null) &#123;//通过dexFile加载类 Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz;//加载成功 &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null;&#125; DexPathList先遍历dexElements，对于DexFile通过loadClassBinaryName来加载，如果找到就返回。这里又转到DexFile进行加载了，所以需要再看看DexFile是如何加载的。 12345678910111213141516171819202122public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123; return defineClass(name, loader, mCookie, suppressed);&#125;//DexFile加载类private static Class defineClass(String name, ClassLoader loader, int cookie, List&lt;Throwable&gt; suppressed) &#123; Class result = null; try &#123; //通过native来加载 runtime/native/dalvik_system_DexFile.cc result = defineClassNative(name, loader, cookie); &#125; catch (NoClassDefFoundError e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; catch (ClassNotFoundException e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; return result;&#125; DexFile调用defainClassNative方法来加载类，这里从名称看，它实际上是从native层加载类的，实现在runtime/native/dalvik_system_DexFile.cc。关于native层如何加载类我们在另外的篇章中进行分析。这样DexPathList加载类的逻辑就分析完成了。 需要注意的是DexPathList遍历dexElements通过DexFile来进行的类加载的方式，为一些基于muti dex的热修复技术提供了可能，因为在dexElements数组中靠前的dex文件首先被访问到,这样被修复的类可以被优先加载。 PathClassLoader PathClassLoader是BaseDexClassLoader的子类，它的类加载功能正是依赖于其父类。 我们看看它的实现 1234567891011public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125;&#125; PathClassLoader的实现非常简单，只是提供了两个不同的构造方法，这两个构造方法的区别在于是否提供了lib path，默认情况下的path就是system/lib/和data/app-lib/pakage-name DexClassLoader 123456789101112131415161718192021/** * A class loader that loads classes from &#123;@code .jar&#125; and &#123;@code .apk&#125; files * containing a &#123;@code classes.dex&#125; entry. This can be used to execute code not * installed as part of an application. * &lt;p&gt;This class loader requires an application-private, writable directory to * cache optimized classes. Use &#123;@code Context.getDir(String, int)&#125; to create * such a directory: &lt;pre&gt; &#123;@code * File dexOutputDir = context.getDir("dex", 0); * &#125;&lt;/pre&gt; * * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt; * External storage does not provide access controls necessary to protect your * application from code injection attacks. */public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125; DexClassLoader的实现更加简单，只有一个构造方法，从注释也可以看出它可以从包含classes.dex文件的jar/apk文件中来加载类，而不需要jar/apk为已安装应用的一部分。因为它提供了一个optimizedDirectory参数，这个参数是一个应用私有且可写入的目录，用来保存dex经过优化后的类，需要注意的是为了防止注入，优化后的类是不能被保存在外置存储上的。在PathClassLoader中我们看到这个参数默认是null，也就是它会从默认的位置加载dex，这个位置就是/data/dalvik-cache，也就是已经安装的apk。这也是它们之间最大的区别了。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceFlinger合成layer过程详解]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfaceflinger-composer-src%2F</url>
    <content type="text"><![CDATA[前言 本篇将对Android GUI系统SurfaceFlinger（简称SF）合成layer的具体过程进行分析。合成过程是SF最核心的任务，这个过程贯穿了整个SF业务逻辑，SF所有的工作都最终是为了合成显示做准备。所以，了解SF的合成过程对于我们进一步了解Android GUI系统是必不可少的一部分。 VSYNC控制合成 在介绍SF的VSYNC信号控制同步的篇节中，我们分析了VSYNC信号在绘制和合成过程中所发挥的作用，在SF的init方法中，我们创建了合成延时源并通过EventThread管理该延时源，同时我们通过SF的MessageQueue来为SF创建一个监听合成延时源的Connection并将其注册到EventThread的监听者集合中，这样当合成延时源接收到VSYNC信号后通知SF MessageQueue，然后MessageQueue将该事件通知给SF，随后就可以开始进行合成过程了。这之间MessageQueue可以看作是SF的“秘书”，它负责接收一些SF的消息事件。 12345678void SurfaceFlinger::init() &#123; ... sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, false);//创建合成延时Vsync源 mSFEventThread = new EventThread(sfVsyncSrc); mEventQueue.setEventThread(mSFEventThread);//将合成延时vysnc源与SF的事件管理关联，因为SF主要负责合成 ...&#125; 这里mSFEventThread为管理合成延时源的EventThread，mEventQueue为SF的MessageQueue，这里通过其setEventThread将其注册为EventThread的监听者，负责接收来自合成延时源的VSYNC事件。 123456789101112//frameworks/native/services/surfaceflinger/MessageQueue.cpp//合成延时源的EventThread会和SF的MessageQueue关联起来void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread)&#123; mEventThread = eventThread; //为SF创建延时源的Connection监听 mEvents = eventThread-&gt;createEventConnection(); mEventTube = mEvents-&gt;getDataChannel();//取到BitTube //将其描述符fd添加到Looper中，当延时源的EventHandler收到VSYNC信号后触发cb_eventReceiver回调 mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, ALOOPER_EVENT_INPUT, MessageQueue::cb_eventReceiver, this);&#125; 这里通过EventThead的createEventConnection方法创建一个Connection，这个Connection在第一次引用时被注册到EventThread的监听者队列中，随后获取到Connection对应的BitTube，然后将BitTube的文件描述符添加到MessageQueue的Looper中监听起来，监听的回调为MessageQueue::cb_eventReceiver，这样当EventThread通过Connection通知VSYNC信号到达时可以触发回调通知MessageQueue。 123456789101112131415161718192021222324//当监听到Connection对应的BitTube的文件描述符有事件到达时，这个回调方法被Looper触发int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data); return queue-&gt;eventReceiver(fd, events);&#125;//如果MessageQueue请求了VSYNC信号，合成延时源收到VSYNC信号后触发该回调，再该回调中通知SF进行合成操作int MessageQueue::eventReceiver(int fd, int events) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; while ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123; for (int i=0 ; i&lt;n ; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;#if INVALIDATE_ON_VSYNC mHandler-&gt;dispatchInvalidate();#else mHandler-&gt;dispatchRefresh();#endif break; &#125; &#125; &#125; return 1;&#125; cb_eventReceiver被触发后调用eventReceiver处理VSYNC信号事件，这里先通过DisplayEventReceiver::getEvents方法读取到事件信息。然后对VSYNC事件进行处理，这里INVALIDATE_ON_VSYNC被定义为1，所以通过mHandler的dispatchInvalidate方法进行处理。mHandler是MessageQueue内部使用的Handler。 12345678910111213141516171819202122232425262728293031323334void MessageQueue::Handler::dispatchRefresh() &#123; if ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::REFRESH)); &#125;&#125;void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125;&#125;void MessageQueue::Handler::dispatchTransaction() &#123; if ((android_atomic_or(eventMaskTransaction, &amp;mEventMask) &amp; eventMaskTransaction) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::TRANSACTION)); &#125;&#125;void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case TRANSACTION: android_atomic_and(~eventMaskTransaction, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125; MessageQueue内部的Handler定义了三个dispatch方法，dispatchRefresh，dispatchInvalidate，dispatchTransaction，对应的在SF一端会通过onMessageReceived分别处理这三个事件，合成的任务也是在其中做处理的。 123456789101112131415161718void SurfaceFlinger::onMessageReceived(int32_t what) &#123; ATRACE_CALL(); switch (what) &#123; case MessageQueue::TRANSACTION: //负责处理Layer或者Display的属性变更，这些变更可能影响到图层可见区域脏区域的计算。 handleMessageTransaction(); break; case MessageQueue::INVALIDATE: handleMessageTransaction(); //主要调用handlePageFlip，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域 handleMessageInvalidate(); signalRefresh();//会触发handleMessageRefresh break; case MessageQueue::REFRESH: handleMessageRefresh();//合并和渲染输出 break; &#125;&#125; 在SF的onMessageReceived方法中分别处理TRANSACTION，INVALIDATE以及REFRESH事件，TRANSACTION事件主要是处理Layer和Display的属性变更，这些变更更可能影响到图层可见区域及脏区域的计算。在INVALIDATE事件中除了处理TRANSACTION事件的内容外，还需要获取合成图层layer的最新帧数据，同时还要根据内容更新脏区域。REFRESH事件中主要是合并和渲染输出的处理。实际上我们可以看到，在INVALIDATE事件中包含了TRANSACTION和REFRESH事件的内容，它会完整的处理一次合并和渲染输出过程。大多数情况下SF的任务也是处理INVALIDATE事件。所以接下来我们分析的重点就从INVALIDATE事件开始。 触发合成的时机 SF合成机制依赖于VSYNC信号，但显示设备并不是任何时候都会去进行合成操作，显然，当显示设备的layer没有发生任何变化时候就不需要也不应该去让SF合成，只有当layer内部发生了变化，如最常见的应用绘制好了新的一帧数据，这时候会通过Layer BufferQueue的消费者接口onFrameAvaliable通知SF有新的一帧数据，这时候需要对layer进行合成渲染就需要去请求VSYNC信号，EventThread根据请求触发合成延时源的VSYNC信号通知给监听者也就是上面的MessageQueue，MessageQueue会通知SF去及逆行合成操作。 12345//frameworks/native/services/surfaceflinger/Layer.cppvoid Layer::onFrameAvailable() &#123; android_atomic_inc(&amp;mQueuedFrames);//mQueuedFrames加1 mFlinger-&gt;signalLayerUpdate();//安排一次合成操作&#125; 有新的一帧数据准备好了，通过SF通知MessageQueue安排一次合成操作。 1234//void SurfaceFlinger::signalLayerUpdate() &#123; mEventQueue.invalidate();&#125; 通过MessageQueue的invalidate方法请求一次VSYNC信号。 12345678////frameworks/native/services/surfaceflinger/MessageQueue.cppvoid MessageQueue::invalidate() &#123;#if INVALIDATE_ON_VSYNC mEvents-&gt;requestNextVsync();//请求一次VSYNC#else mHandler-&gt;dispatchInvalidate();#endif&#125; invalidate会通过requestNextVsync请求一次VSYNC信号，这个会通过合成延时源的EventThread进行，当VSYNC信号到达后，会通知MessageQueue注册的监听者，从而将VSYNC信号事件传递给MessageQueue,MessageQueue最终告知SF进行合成操作。 处理Layer及Display属性变更 handleMessageTransaction的任务是处理Layer及Display的属性变更，这个什么意思呢？在Layer内部有实际上有两个State对象mCurrentState和mDrawingState，都维护着Layer的状态信息，当用户调用Layer的方法对其属性如大小，透明度等做了更改后 ，设置的值是保存在mCurrentState这个对象中，而mDrawingState是当前正在使用的状态，这样做的目的是不会因为用户的更改而影响到Layer的绘制合成过程。所以在handleMessageTransaction方法中会计算相关Layer的属性变更，这些变更可能影响到后续可见区域的计算。 12345678910111213141516//frameworks/native/services/surfaceflinger/SurfaceFlinger.cppvoid SurfaceFlinger::handleMessageTransaction() &#123; uint32_t transactionFlags = peekTransactionFlags(eTransactionMask); if (transactionFlags) &#123; handleTransaction(transactionFlags); &#125;&#125;void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)&#123; Mutex::Autolock _l(mStateLock); ... transactionFlags = getTransactionFlags(eTransactionMask); //进一步处理 handleTransactionLocked(transactionFlags); ...&#125; handleMessageTransaction通过peekTransactionFlags查看transaction flag，这个标记决定是否需要进行transaction ，如果需要调用handleTransaction进一步通过调用handleTransactionLocked方法处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//frameworks/native/services/surfaceflinger/SurfaceFlinger.cppvoid SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; //取到当前状态的Layer集合 const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ); const size_t count = currentLayers.size(); if (transactionFlags &amp; eTraversalNeeded) &#123; for (size_t i=0 ; i&lt;count ; i++) &#123;//遍历所有的Layer const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); //取到layer的transaction flag用以判断是否需要进行transaction uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) continue; //调用layer的doTransaction处理变更，这些变更可能会影响到可视区域的计算，如果有一个layer影响到， //就将mVisibleRegionsDirty置true const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125; &#125; //处理显示设备的变更 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; //当前显示设备 const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); //上次的显示设备 const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); .... &#125; //处理transform hint if (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123; ... &#125; const LayerVector&amp; layers(mDrawingState.layersSortedByZ); //说明layer增加了，这里置mVisibleRegionsDirty为true if (currentLayers.size() &gt; layers.size()) &#123; // layers have been added mVisibleRegionsDirty = true; &#125; // some layers might have been removed, so // we need to update the regions they're exposing. //layer被移除了 if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (currentLayers.indexOf(layer) &lt; 0) &#123;//如果这个layer不存在 // this layer is not visible anymore // TODO: we could traverse the tree from front to back and // compute the actual visible region // TODO: we could cache the transformed region const Layer::State&amp; s(layer-&gt;getDrawingState()); Region visibleReg = s.transform.transform( Region(Rect(s.active.w, s.active.h))); //将删除的layer的可见区域置为无效以便后续进行更新 invalidateLayerStack(s.layerStack, visibleReg); &#125; &#125; &#125; //提交变更 commitTransaction();&#125; 在SF内部也维护了两个State状态，mCurrentState和mDrawingState，它们同Layer内部的State定义是不同，mDrawingState是SF上次合成使用的绘图状态，而mCurrentState是SF当前最新的绘图状态。 1234struct State &#123; LayerVector layersSortedByZ; DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;&#125;; 在State的内部包含了一个LayerVector对象layersSortedByZ，从名称上看它是一个以Z序排序的layer集合。这个集合中的layer就是SF即将要使用进行合成的layer。另一个成员displays描述了显示设备的状态信息，它实际上一个Map,key值为设备的Token，也是一个IBinder，value为DisplayDeviceState代表显示设备的状态。 在handleTransactionLocked方法中，我们先从当前状态中取出Layer集合，然后针对每个layer进行doTransaction处理，这里面会对layer的属性变更做处理，我们后面再分析，根据其处理结果，我们可以直到是否影响到可见区域，如果影响到则标记 mVisibleRegionsDirty为true。随后处理显示设备的变更，为什么会在这里处理我想可能是为了支持显示设备的热插拔。通过对比前后两次设备状态，可以知道设备是被移除了还是添加了，或者是设备的其他信息发生了变化等等，针对这些做不同的处理。 设备的增加和删除都会分别从SF的mDisplays进行相应的增加和删除操作，mDisplays是一个DefaultKeyedVector&lt; wp, sp &gt;，它维护了SF使用的显示设备。 接下来处理transform hint的变更，transform hint被用来提高layer的系统性能，关于这个在本篇中不做介绍，略过。 最后的部分是处理layer的变更，前后两次的绘制合成过程，可能有新的layer添加进来，这时候我们同样需要置mVisibleRegionsDirty为true，表示可见区域的变化，但也有可能之前使用的layer被移除，那么它之前的显示区域也就成了脏区域，需要进行更新，这个是通过invalidateLayerStack处理的。随后通过commitTransaction提交transaction，将mCurrentState赋值给mDrawingState 12345678void SurfaceFlinger::commitTransaction()&#123; ... mDrawingState = mCurrentState; mTransactionPending = false; mAnimTransactionPending = false; mTransactionCV.broadcast();&#125; layer的属性变更 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//处理layer的变更uint32_t Layer::doTransaction(uint32_t flags) &#123; const Layer::State&amp; s(getDrawingState()); const Layer::State&amp; c(getCurrentState()); //大小是否发生了变化 const bool sizeChanged = (c.requested.w != s.requested.w) || (c.requested.h != s.requested.h); if (sizeChanged) &#123; // record the new size, form this point on, when the client request // a buffer, it'll get the new size. //layer的大小发生了变化 mSurfaceFlingerConsumer-&gt;setDefaultBufferSize( c.requested.w, c.requested.h); &#125; if (!isFixedSize()) &#123; const bool resizePending = (c.requested.w != c.active.w) || (c.requested.h != c.active.h); if (resizePending) &#123; // don't let Layer::doTransaction update the drawing state // if we have a pending resize, unless we are in fixed-size mode. // the drawing state will be updated only once we receive a buffer // with the correct size. // // in particular, we want to make sure the clip (which is part // of the geometry state) is latched together with the size but is // latched immediately when no resizing is involved. flags |= eDontUpdateGeometryState; &#125; &#125; // always set active to requested, unless we're asked not to // this is used by Layer, which special cases resizes. if (flags &amp; eDontUpdateGeometryState) &#123; &#125; else &#123; Layer::State&amp; editCurrentState(getCurrentState()); editCurrentState.active = c.requested; &#125; //活动大小也发生了变化 if (s.active != c.active) &#123; // invalidate and recompute the visible regions if needed flags |= Layer::eVisibleRegion; &#125; //当Layer的position，Zorder，alpha,matrix,transparent region,flags,crops.等发生变化的时候，sequence就会自增。这里不相等说明属性发生了变更 if (c.sequence != s.sequence) &#123; // invalidate and recompute the visible regions if needed flags |= eVisibleRegion; this-&gt;contentDirty = true; // we may use linear filtering, if the matrix scales us const uint8_t type = c.transform.getType(); mNeedsFiltering = (!c.transform.preserveRects() || (type &gt;= Transform::SCALE)); &#125; // Commit the transaction commitTransaction();//更新layer的绘图状态 return flags;&#125; layer的属性变更也是通过比较mDrawingState和mCurrentState进行计算的，最后同样会通过commitTransaction提交transaction。在这里会对影响可视区域计算的属性做了Layer::eVisibleRegion标记。 获取Layer的帧数据以及计算显示设备的脏区域 1234567891011121314151617181920212223void SurfaceFlinger::handleMessageInvalidate() &#123; ATRACE_CALL(); handlePageFlip();&#125;void SurfaceFlinger::handlePageFlip()&#123; Region dirtyRegion; bool visibleRegions = false; //取到layer列表 const LayerVector&amp; layers(mDrawingState.layersSortedByZ); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); //使用latchBuffer更新layer的图像，并获取其最新的显示数据到mActiveBuffer const Region dirty(layer-&gt;latchBuffer(visibleRegions)); const Layer::State&amp; s(layer-&gt;getDrawingState()); invalidateLayerStack(s.layerStack, dirty);//设置layer关联的设备的更新区域 &#125; mVisibleRegionsDirty |= visibleRegions;&#125; 更新完transcation后接下来就是获取layer显示数据，这个是通过layer的latchBuffer方法获取到的，通过latchBuffer可以得知layer的可见区域，这个可见区域就是显示设备需要更新的脏区域，脏区域通过invalidateLayerStack计算。 合成过程分析 合成主要流程 123456789void SurfaceFlinger::handleMessageRefresh() &#123; ... preComposition(); rebuildLayerStacks(); setUpHWComposer(); ... doComposition(); postComposition();&#125; preComposition 合成的过程主要是在handleMessageRefresh中进行的，我们分别介绍，先看preComposition 123456789101112131415161718192021222324//合成前的预处理void SurfaceFlinger::preComposition()&#123; bool needExtraInvalidate = false; const LayerVector&amp; layers(mDrawingState.layersSortedByZ); const size_t count = layers.size(); //取到当前绘制的layer，对于每个layer调用其onPreComposition判断其是否还有未处理的的frame，如果 //有就将needExtraInvalidate置为true，表示需要进行额外的合成和渲染操作 for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125; &#125; //如果有layer还有未处理的frame，则需要再进行一次合成和渲染操作 if (needExtraInvalidate) &#123; signalLayerUpdate(); &#125;&#125;//合成预处理回调，这里判断layer是否还有未处理的queued framebool Layer::onPreComposition() &#123; mRefreshPending = false; return mQueuedFrames &gt; 0;&#125; preComposition是合成的预处理部分，这部分是判断合成前是否有layer还有新的帧数据mQueuedFrames &gt; 0，如果有的话就需要通过signalLayerUpdate再安排一次合成操作。 rebuildLayerStacks 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//重建设备的可见Layer集合，并计算每个layer的可见区域和脏区域void SurfaceFlinger::rebuildLayerStacks() &#123; // rebuild the visible layer list per screen if (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_CALL(); mVisibleRegionsDirty = false; invalidateHwcGeometry(); const LayerVector&amp; layers(mDrawingState.layersSortedByZ); //对每一个显示设备都需要重建可见layer for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; Region opaqueRegion;//不透明区域 Region dirtyRegion;//透明区域 Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;//可见layer集合 const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); const Transform&amp; tr(hw-&gt;getTransform());//设备的变换矩阵 const Rect bounds(hw-&gt;getBounds());//设备的显示区域 if (hw-&gt;canDraw()) &#123; //为设备layer计算可见区域 SurfaceFlinger::computeVisibleRegions(layers, hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); //重建可见layer const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); const Layer::State&amp; s(layer-&gt;getDrawingState()); //只有layer和显示设备的layerStack匹配才能在该设备上显示 if (s.layerStack == hw-&gt;getLayerStack()) &#123; //绘制的区域为layer的可见非透明区域 Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds);//如果layer的可见区域和当前的设备的窗口区域做交集 //如果可见区域和当前的设备区域有交集，则该layer需要显示出来，将其添加到可见layer的集合中 if (!drawRegion.isEmpty()) &#123; layersSortedByZ.add(layer); &#125; &#125; &#125; &#125; //设置设备的可见Layer集合，比如主屏幕可以有startus bar,app,navigation bar对应的layer， //这些layer存放在layersSortedByZ集合中 hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); hw-&gt;undefinedRegion.set(bounds);//初始的未定义区域为设备的显示区域 hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));//未定义区域=当前未定义区域-不透明区域 hw-&gt;dirtyRegion.orSelf(dirtyRegion);//设置脏区域 &#125; &#125;&#125; rebuildLayerStacks负责重建设备的可见Layer集合，并计算每个layer的可见区域和脏区域。每个显示设备都有一个可见layer集合，这个layer集合将最终被合成在显示设备上。rebuildLayerStacks针对每一个显示设备都进行处理，通过computeVisibleRegions为每个显示设备计算layer可见区域和脏区域，当layer的可见区域和设备窗口区域有交集说明该layer可以显示在该设备中，添加到其可见的layer集合layersSortedByZ中，最后通过setVisibleLayersSortedByZ将该集合设置给显示设备，同时更新显示设备的脏区域dirtyRegion。 setUpHWComposer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void SurfaceFlinger::setUpHWComposer() &#123; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; mDisplays[dpy]-&gt;beginFrame(); &#125; HWComposer&amp; hwc(getHwComposer()); if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list if (CC_UNLIKELY(mHwWorkListDirty)) &#123; mHwWorkListDirty = false; //针对每个设备创建workList for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ());//取到每个设备的可见Layer集合 const size_t count = currentLayers.size(); //为设备创建workdList if (hwc.createWorkList(id, count) == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); //LayerListIterator用于遍历创建的worklist，具体为遍历DisplayData.list-&gt;hwLayers for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setGeometry(hw, *cur); if (mDebugDisableHWC || mDebugRegion || mDaltonize) &#123; cur-&gt;setSkip(true); &#125; &#125; &#125; &#125; &#125; &#125; // set the per-frame data //遍历当前要显示的设备 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; //取到设备的可见Layer集合，这个集合是在rebuildLayerStacks方法中设置的 const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); //为可见的layer设置当前帧的数据 for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; /* * update the per-frame h/w composer data for each layer * and build the transparent region of the FB */ //这里需要注意LayerListIterator的++操作会去迭代DisplayData.list-&gt;hwLayers //同时*cur返回的实际上是LayerListIterator内部的HWCLayer，HWCLayerVersion1实现了抽象类HWCLayer const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setPerFrameData(hw, *cur); &#125; &#125; &#125; //通过HWC的prepare确定合成方式 status_t err = hwc.prepare(); ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125; &#125;&#125; setUpHWComposer负责为显示设备创建workList，为每个设备要输出显示的layer设置frame data，最后由HWC的prepare确定显示设备可见layer的合成方式，下面我们详细的分析这些内容。 创建WorkList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp//设备创建worklist，这里的id为显示设备的id，numLayers是显示设备的可见layer集合数目status_t HWComposer::createWorkList(int32_t id, size_t numLayers) &#123; if (uint32_t(id)&gt;31 || !mAllocatedDisplayIDs.hasBit(id)) &#123; return BAD_INDEX; &#125; if (mHwc) &#123; //每个设备都有一个DisplayData用来描述显示设备的信息 DisplayData&amp; disp(mDisplayData[id]); if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // we need space for the HWC_FRAMEBUFFER_TARGET //如果版本为HWC_DEVICE_API_VERSION_1_1，则需要额外的一个hwc_layer_1_t用来存放合成后的纹理 numLayers++; &#125; //初始化worklist主要是为初始化DispalyData中的hwc_display_contents_1，为其开辟内存空间 if (disp.capacity &lt; numLayers || disp.list == NULL) &#123; size_t size = sizeof(hwc_display_contents_1_t) + numLayers * sizeof(hwc_layer_1_t); free(disp.list); //分配hwc_display_contents_1_t，其中存放的是要显示的layer disp.list = (hwc_display_contents_1_t*)malloc(size); disp.capacity = numLayers; &#125; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; //hwc_display_contents_1内部的hwLayers的最后一个为FrameBufferTarget，合成后的纹理就存放在该对象中 //这里将它拿出来赋值给framebufferTarget disp.framebufferTarget = &amp;disp.list-&gt;hwLayers[numLayers - 1]; memset(disp.framebufferTarget, 0, sizeof(hwc_layer_1_t)); const hwc_rect_t r = &#123; 0, 0, (int) disp.width, (int) disp.height &#125;; //这里初始化这个用来存放合成后的hwc_layer_1_t //类型为HWC_FRAMEBUFFER_TARGET，表示它是由GPU合成的 disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET; disp.framebufferTarget-&gt;hints = 0; disp.framebufferTarget-&gt;flags = 0; disp.framebufferTarget-&gt;handle = disp.fbTargetHandle; disp.framebufferTarget-&gt;transform = 0; disp.framebufferTarget-&gt;blending = HWC_BLENDING_PREMULT; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123; disp.framebufferTarget-&gt;sourceCropf.left = 0; disp.framebufferTarget-&gt;sourceCropf.top = 0; disp.framebufferTarget-&gt;sourceCropf.right = disp.width; disp.framebufferTarget-&gt;sourceCropf.bottom = disp.height; &#125; else &#123; disp.framebufferTarget-&gt;sourceCrop = r; &#125; disp.framebufferTarget-&gt;displayFrame = r; disp.framebufferTarget-&gt;visibleRegionScreen.numRects = 1; disp.framebufferTarget-&gt;visibleRegionScreen.rects = &amp;disp.framebufferTarget-&gt;displayFrame; disp.framebufferTarget-&gt;acquireFenceFd = -1; disp.framebufferTarget-&gt;releaseFenceFd = -1; disp.framebufferTarget-&gt;planeAlpha = 0xFF; &#125; disp.list-&gt;retireFenceFd = -1; disp.list-&gt;flags = HWC_GEOMETRY_CHANGED; disp.list-&gt;numHwLayers = numLayers; &#125; return NO_ERROR;&#125; 每个显示设备都有一个DisplayData对象用来描述显示数据。DisplayData的定义如下： 12345678910111213141516171819202122232425262728struct DisplayData &#123; DisplayData(); ~DisplayData(); uint32_t width; uint32_t height; uint32_t format; // pixel format from FB hal, for pre-hwc-1.1 float xdpi; float ydpi; nsecs_t refresh; bool connected; bool hasFbComp;//标记GLES合成 bool hasOvComp;//标记硬件合成 size_t capacity; //list包括这个显示设备上所有的layer数据，layer数据放在hwLayers中，hwc_display_contents_1结构描述的是 //这个结构描述的是输出到显示设备的内容，具体见hwcomposer.h中的定义 //需要注意的是list-&gt;hwLayers的最后一个存放的是合成的layer hwc_display_contents_1* list; hwc_layer_1* framebufferTarget;//gup合成的layer放在framebufferTarget中 buffer_handle_t fbTargetHandle; sp&lt;Fence&gt; lastRetireFence; // signals when the last set op retires sp&lt;Fence&gt; lastDisplayFence; // signals when the last set op takes // effect on screen buffer_handle_t outbufHandle; sp&lt;Fence&gt; outbufAcquireFence; // protected by mEventControlLock int32_t events;&#125;; 其中DisplayData的hwc_display_contents_1用来存放即将要显示到设备的layer，这个结构的定义如下 12345678 //这个结构描述的是输出到显示设备的内容typedef struct hwc_display_contents_1 &#123; ... uint32_t flags; size_t numHwLayers;//指定了layer的个数 hwc_layer_1_t hwLayers[0];//将要合成显示在设备中的layer，它是用hwc_layer_1_t描述的&#125; hwc_display_contents_1_t; hwc_display_contents_1内部指定了要显示的layer的个数，这些layer是通过hwc_layer_1_t数组进行描述的。我们要创建的workList就是为hwc_display_contents_1以及其内部的hwc_layer_1_t数组分配内存用来存放即将要显示的layer信息。在createWorkList中，如果设备版本为HWC_DEVICE_API_VERSION_1_1，说明支持frameBufferTarget，需要额外的创建多一个hwc_layer_1_t，这个hwc_layer_1_t用来存放的是GLES合成后的layer的信息，它的合成类型被指定为HWC_FRAMEBUFFER_TARGET，在DisplayData中是以framebufferTarget描述的。它实际上是hwc_display_contents_1的hwLayers成员的最后一个hwc_layer_1_t。也就是说hwLayers包含了要合成的layer及合成后的layer的信息。 为layer设置帧数据 为显示设备创建完workList，这时候它只是有了容纳layer的结构体，我们还要告知它每个layer的帧数据，这样显示设备才知道layer如何获取这些数据并进行合成显示。这个是通过Layer的setPerFrameData处理的，还记得之前我们通过Layer的latchBuffer获取了layer最新的帧数据，它被放在mActiveBuffer中，这时候我们就可以将这个最新的帧数据的handle设置到显示设备的layer中了。 1234567891011121314151617//为Layer设置当前帧数据void Layer::setPerFrameData(const sp&lt;const DisplayDevice&gt;&amp; hw, HWComposer::HWCLayerInterface&amp; layer) &#123; // we have to set the visible region on every frame because // we currently free it during onLayerDisplayed(), which is called // after HWComposer::commit() -- every frame. // Apply this display's projection's viewport to the visible region // before giving it to the HWC HAL. const Transform&amp; tr = hw-&gt;getTransform(); Region visible = tr.transform(visibleRegion.intersect(hw-&gt;getViewport())); layer.setVisibleRegionScreen(visible); // NOTE: buffer can be NULL if the client never drew into this // layer yet, or if we ran out of memory //将当前Layer的buffer通过接口HWCLayerInterface保存起来，具体见HWCLayerVersion1 layer.setBuffer(mActiveBuffer);&#125; 1234567891011//HWCLayerVersion1实现//将GraphicBuffer保存在对应的hwc_layer_1_t中 virtual void setBuffer(const sp&lt;GraphicBuffer&gt;&amp; buffer) &#123; if (buffer == 0 || buffer-&gt;handle == 0) &#123; getLayer()-&gt;compositionType = HWC_FRAMEBUFFER; getLayer()-&gt;flags |= HWC_SKIP_LAYER; getLayer()-&gt;handle = 0; &#125; else &#123; getLayer()-&gt;handle = buffer-&gt;handle;//指定buffer的handle即可 &#125;&#125; 确定layer的合成方式 setUpHWComposer的最后一步是通过HWComposer的prepare确定显示设备layer的合成方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879status_t HWComposer::prepare() &#123; for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; DisplayData&amp; disp(mDisplayData[i]);//取到设备的DisplayData if (disp.framebufferTarget) &#123;//它有待合成的hwc_layer_1_t // make sure to reset the type to HWC_FRAMEBUFFER_TARGET // DO NOT reset the handle field to NULL, because it's possible // that we have nothing to redraw (eg: eglSwapBuffers() not called) // in which case, we should continue to use the same buffer. LOG_FATAL_IF(disp.list == NULL); //确保framebufferTarget的合成类型为HWC_FRAMEBUFFER_TARGET disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET; &#125; if (!disp.connected &amp;&amp; disp.list != NULL) &#123; ALOGW("WARNING: disp %d: connected, non-null list, layers=%d", i, disp.list-&gt;numHwLayers); &#125; mLists[i] = disp.list;//取到DispalayData的list存放在mLists中一份，它是一个hwc_display_contents_1数组 if (mLists[i]) &#123; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123; mLists[i]-&gt;outbuf = disp.outbufHandle; mLists[i]-&gt;outbufAcquireFenceFd = -1; &#125; else if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // garbage data to catch improper use mLists[i]-&gt;dpy = (hwc_display_t)0xDEADBEEF; mLists[i]-&gt;sur = (hwc_surface_t)0xDEADBEEF; &#125; else &#123; mLists[i]-&gt;dpy = EGL_NO_DISPLAY; mLists[i]-&gt;sur = EGL_NO_SURFACE; &#125; &#125; &#125; //为显示设备准备好缓冲区，由硬件合成模块决定哪些layer可以通过硬件合成，并为其打上HWC_OVERLAY标记， //默认的合成类型为HWC_FRAMEBUFFER int err = mHwc-&gt;prepare(mHwc, mNumDisplays, mLists); ALOGE_IF(err, "HWComposer: prepare failed (%s)", strerror(-err)); if (err == NO_ERROR) &#123; // here we're just making sure that "skip" layers are set // to HWC_FRAMEBUFFER and we're also counting how many layers // we have of each type. // // If there are no window layers, we treat the display has having FB // composition, because SurfaceFlinger will use GLES to draw the // wormhole region. //对于每个显示设备 for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; //取到设备DisplayData DisplayData&amp; disp(mDisplayData[i]); disp.hasFbComp = false; disp.hasOvComp = false; //取到hwc_display_contents_1 if (disp.list) &#123; //对于显示设备的每一个hwc_layer_1_t都判断其合成类型 for (size_t i=0 ; i&lt;disp.list-&gt;numHwLayers ; i++) &#123; hwc_layer_1_t&amp; l = disp.list-&gt;hwLayers[i]; //ALOGD("prepare: %d, type=%d, handle=%p", // i, l.compositionType, l.handle); if (l.flags &amp; HWC_SKIP_LAYER) &#123;//需要跳过的layer使用OPENGL合成 l.compositionType = HWC_FRAMEBUFFER; &#125; if (l.compositionType == HWC_FRAMEBUFFER) &#123;//合成类型为HWC_FRAMEBUFFER，则是OPENGL合成 disp.hasFbComp = true; &#125; if (l.compositionType == HWC_OVERLAY) &#123;//如果合成类型为HWC_OVERLAY则为硬件合成 disp.hasOvComp = true; &#125; &#125; if (disp.list-&gt;numHwLayers == (disp.framebufferTarget ? 1 : 0)) &#123; disp.hasFbComp = true; &#125; &#125; else &#123; disp.hasFbComp = true;//如果没有硬件合成使用OPENGL合成 &#125; &#125; &#125; return (status_t)err;&#125; prepare将所有显示设备的hwc_display_contents_1防止在mLists数组中，然后通过hwc硬件的prepare方法决定每个显示设备的layer是否支持硬件合成，如果是就将其compositionType标记为HWC_OVERLAY，默认情况下compositionType是HWC_FRAMEBUFFER表示通过GLES合成。最后通过处理结果来更新DisplayData的hasFbComp和hasOvComp，它们分别表示是否有GLES合成和硬件合成的layer。 doComposition 123456789101112131415161718192021222324void SurfaceFlinger::doComposition() &#123; ATRACE_CALL(); const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything); //同样针对每一个显示设备进行处理 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;canDraw()) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); // repaint the framebuffer (if needed) //处理需要进行软件合成的部分，也有可能没有需要软件合成的Layer。 doDisplayComposition(hw, dirtyRegion); hw-&gt;dirtyRegion.clear(); hw-&gt;flip(hw-&gt;swapRegion); hw-&gt;swapRegion.clear(); &#125; // inform the h/w that we're done compositing hw-&gt;compositionComplete(); &#125; //把不管是普通Layer的数据还是通过EGL合成后的数据都发送到硬件合成模块进行合成 postFramebuffer();&#125; doCompositiont负责处理那些需要进行GLES合成的layer。最后通过postFramebuffer提交给硬件合成模块进行合成显示。GLES合成layer是通过doDisplayComposition处理的，我们先看它的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void SurfaceFlinger::doDisplayComposition(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; inDirtyRegion)&#123; Region dirtyRegion(inDirtyRegion); // compute the invalid region hw-&gt;swapRegion.orSelf(dirtyRegion); uint32_t flags = hw-&gt;getFlags(); if (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123; // we can redraw only what's dirty, but since SWAP_RECTANGLE only // takes a rectangle, we must make sure to update that whole // rectangle in that case dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; if (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123; // We need to redraw the rectangle that will be updated // (pushed to the framebuffer). // This is needed because PARTIAL_UPDATES only takes one // rectangle instead of a region (see DisplayDevice::flip()) dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; // we need to redraw everything (the whole screen) dirtyRegion.set(hw-&gt;bounds()); hw-&gt;swapRegion = dirtyRegion; &#125; &#125; if (CC_LIKELY(!mDaltonize)) &#123; //关键点1 合成layer doComposeSurfaces(hw, dirtyRegion); &#125; else &#123; RenderEngine&amp; engine(getRenderEngine()); engine.beginGroup(mDaltonizer()); doComposeSurfaces(hw, dirtyRegion); engine.endGroup(); &#125; // update the swap region and clear the dirty region hw-&gt;swapRegion.orSelf(dirtyRegion); // swap buffers (presentation) //关键点2 将合成的纹理渲染在EGL本地窗口中，这会触发本地窗口对应的BufferQueue，通知它的消费端FrameBufferSurface进行消费 hw-&gt;swapBuffers(getHwComposer());&#125; doDisplayComposition又通过doComposeSurfaces合成显示设备的layer，之前我们为设备创建了workList，知道合成的layer最终会被保存在frameBufferTarget对应的hwc_layer_1_t中，那么这到底是怎么样实现呢？我们接着看doComposeSurfaces的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void SurfaceFlinger::doComposeSurfaces(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; dirty)&#123; RenderEngine&amp; engine(getRenderEngine()); const int32_t id = hw-&gt;getHwcDisplayId(); HWComposer&amp; hwc(getHwComposer()); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); //判断是否需要进行GLES合成，如果设备的layer集合中有需要GLES合成的layer则返回true bool hasGlesComposition = hwc.hasGlesComposition(id); if (hasGlesComposition) &#123;//通过GLES进行合成 //设置EGL的display和Context ，这里为EGL设置本地窗口对象，合成的纹理渲染在该窗口中 if (!hw-&gt;makeCurrent(mEGLDisplay, mEGLContext)) &#123; ALOGW("DisplayDevice::makeCurrent failed. Aborting surface composition for display %s", hw-&gt;getDisplayName().string()); return; &#125; ... &#125; /* * and then, render the layers targeted at the framebuffer */ //获取到显示设备的可见layer集合 const Vector&lt; sp&lt;Layer&gt; &gt;&amp; layers(hw-&gt;getVisibleLayersSortedByZ()); const size_t count = layers.size(); const Transform&amp; tr = hw-&gt;getTransform(); if (cur != end) &#123; // we're using h/w composer //遍历处理这些layer for (size_t i=0 ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); //layer的设置裁剪区域 const Region clip(dirty.intersect(tr.transform(layer-&gt;visibleRegion))); if (!clip.isEmpty()) &#123; switch (cur-&gt;getCompositionType()) &#123; case HWC_OVERLAY: &#123;//如果当前layer是通过硬件进行合成，则不需要进行任何处理，合成工作交给硬件处理 ... break; &#125; //当前layer需要软件进行合成，调用draw方法通过EGL合成为纹理 //需要注意的是对于需要GLES进行合成的Layer，其都会绘制在同一个纹理上，这个纹理的Buffer会在后面的通过swapBuffer提交给设备的frameBufferTarget case HWC_FRAMEBUFFER: &#123; layer-&gt;draw(hw, clip); break; &#125; ... &#125; &#125; layer-&gt;setAcquireFence(hw, *cur); &#125; &#125; else &#123; ... &#125;&#125; 在doComposeSurfaces方法中，我们首先通过DisplayDevice的makeCurrent方法配置EGL display和context,要合成的对象最终被渲染到DisplayDevice的本地窗口中，后面我们对此进行分析，随后取到设备的可见layer集合，然后通过循环遍历这个集合，在循环中我们只需要关心通过GLES合成部分的layer，这些layer的合成会调用draw方法进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Layer进行软件合成void Layer::draw(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; clip) const &#123; onDraw(hw, clip);&#125;void Layer::draw(const sp&lt;const DisplayDevice&gt;&amp; hw) &#123; onDraw( hw, Region(hw-&gt;bounds()) );&#125;void Layer::onDraw(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; clip) const&#123; ATRACE_CALL(); …… // Bind the current buffer to the GL texture, and wait for it to be // ready for us to draw into. //绑定当前Buffer到GL纹理，等待渲染 status_t err = mSurfaceFlingerConsumer-&gt;bindTextureImage(); if (err != NO_ERROR) &#123; ALOGW("onDraw: bindTextureImage failed (err=%d)", err); // Go ahead and draw the buffer anyway; no matter what we do the screen // is probably going to have something visibly wrong. &#125; bool blackOutLayer = isProtected() || (isSecure() &amp;&amp; !hw-&gt;isSecure()); RenderEngine&amp; engine(mFlinger-&gt;getRenderEngine()); if (!blackOutLayer) &#123; // TODO: we could be more subtle with isFixedSize() const bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize(); // Query the texture matrix given our current filtering mode. float textureMatrix[16]; mSurfaceFlingerConsumer-&gt;setFilteringEnabled(useFiltering); mSurfaceFlingerConsumer-&gt;getTransformMatrix(textureMatrix); …… // Set things up for texturing. mTexture.setDimensions(mActiveBuffer-&gt;getWidth(), mActiveBuffer-&gt;getHeight()); mTexture.setFiltering(useFiltering); mTexture.setMatrix(textureMatrix); //为渲染引擎设置图层纹理 engine.setupLayerTexturing(mTexture); &#125; else &#123; engine.setupLayerBlackedOut(); &#125; //通过OPENGL渲染纹理，这里面会计算layer的绘制区域和纹理坐标等 drawWithOpenGL(hw, clip); engine.disableTexturing();&#125; Layer通过draw合成渲染之前，我们通过DisplayDevice的makeCurrent已经配置好了EGL，在onDraw方法中先通过bindTextureImage将当前layer的buffer绑定到GL纹理，这个是通过GLConsumer的bindTextureImageLocked实现的，因为 这里的mSurfaceFlingerConsumer它是个SurfaceFlingerConsumer，继承自GLConusmer。 1234567891011121314151617181920status_t GLConsumer::bindTextureImageLocked() &#123; ... glBindTexture(mTexTarget, mTexName);//绑定渲染的纹理 if (mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT) &#123; ... &#125; else &#123; EGLImageKHR image = mEglSlots[mCurrentTexture].mEglImage; glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image); while ((error = glGetError()) != GL_NO_ERROR) &#123; ST_LOGE("bindTextureImage: error binding external texture image %p" ": %#04x", image, error); return UNKNOWN_ERROR; &#125; &#125; // Wait for the new buffer to be ready. return doGLFenceWaitLocked();&#125; 在bindTextureImaageLocked中glBindTexture绑定渲染的纹理，其中mTexName为纹理ID，这个纹理ID在Layer构造的时候就生成了，渲染的纹理mTexture也是在Layer构造的时候进行初始化的，它是通过SF创建的RenderEngine创建的纹理ID mTextureName,该纹理ID被传递给了Layer的消费者GLConsumer。 12345678910111213Layer(...)&#123; ... mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName); mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName); ...&#125;void Layer::onFirstRef() &#123; // Creates a custom BufferQueue for SurfaceFlingerConsumer to use mBufferQueue = new SurfaceTextureLayer(mFlinger);//创建一个BufferQueue //BufferQueue的消费者 mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(mBufferQueue, mTextureName); ...&#125; 1234567class SurfaceFlingerConsumer : public GLConsumer &#123;public: SurfaceFlingerConsumer(const sp&lt;BufferQueue&gt;&amp; bq, uint32_t tex) : GLConsumer(bq, tex, GLConsumer::TEXTURE_EXTERNAL, false) &#123;&#125; ...&#125; 在SurfaceFlingerConsumer的构造中将纹理ID传递给GLConsumer，GLConsumer将其保存在成员mTexName，所以layer通过onDraw渲染的纹理和消费者SurfaceFlingerConsumer使用的是同一个纹理。 前面我们知道Layer渲染纹理前会通过DisplayDevice通过makeCurrent配置EGL，我们看看DisplayDevice是如何创建为EGL创建本地窗口的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465DisplayDevice::DisplayDevice( const sp&lt;SurfaceFlinger&gt;&amp; flinger, DisplayType type, int32_t hwcId, bool isSecure, const wp&lt;IBinder&gt;&amp; displayToken, const sp&lt;DisplaySurface&gt;&amp; displaySurface, const sp&lt;IGraphicBufferProducer&gt;&amp; producer, EGLConfig config) : mFlinger(flinger), mType(type), mHwcDisplayId(hwcId), mDisplayToken(displayToken), mDisplaySurface(displaySurface),//这个是FrameBufferSurface mDisplay(EGL_NO_DISPLAY), mSurface(EGL_NO_SURFACE), mDisplayWidth(), mDisplayHeight(), mFormat(), mFlags(), mPageFlipCount(), mIsSecure(isSecure), mSecureLayerVisible(false), mScreenAcquired(false), mLayerStack(NO_LAYER_STACK), mOrientation()&#123; /** * 通过BufferQueue创建一个Surface本地窗口，这个Surface是作为生产者的，而FrameBufferSurface作为消费端， * 它们共享同一个BufferQueue，同时Surface是作为EGL创建WindowSurface的本地窗口，当Layer通过EGL合成纹理后， * eglSwapBuffers方法会通过其ANativeWindow的QueueBuffer方法将绘制好的纹理缓冲区入队列，并通过 * FrameBufferSurface的OnFrameAvaliable回调通知给消费端，消费端将取出该GraphicBuffer并将通过HWC的fbPost * 将其设置到显示设备的DisplayData的FramebufferTarget，随后通过HWC的commit将其提交给显示设备。 */ mNativeWindow = new Surface(producer, false); ANativeWindow* const window = mNativeWindow.get(); int format; window-&gt;query(window, NATIVE_WINDOW_FORMAT, &amp;format); // Make sure that composition can never be stalled by a virtual display // consumer that isn't processing buffers fast enough. We have to do this // in two places: // * Here, in case the display is composed entirely by HWC. // * In makeCurrent(), using eglSwapInterval. Some EGL drivers set the // window's swap interval in eglMakeCurrent, so they'll override the // interval we set here. if (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL) window-&gt;setSwapInterval(window, 0); /* * Create our display's surface */ EGLSurface surface; EGLint w, h; EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY); //通过Surface的ANativeWindow创建EGLSurface对象，EGL合成后的纹理数据被存放在Surface的BufferQueue中 surface = eglCreateWindowSurface(display, config, window, NULL); eglQuerySurface(display, surface, EGL_WIDTH, &amp;mDisplayWidth); eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mDisplayHeight); mDisplay = display;//将创建的EGLDisplay保存 mSurface = surface;//将创建的EGLSurface保存 mFormat = format; mPageFlipCount = 0; ...&#125; 在SF初始化显示设备的时候会为其创建DisplayDevice对象，这个对象内部会创建EGL本地窗口EGLSurface mSurface，它内部使用的BufferQueue和其参数mDisplaySurface指定的FrameBufferSurface使用同一个BufferQueue，这里又是一个生产-消费模型，本地窗口Surface负责成产数据，而FrameBufferSurface负责对数据进行消费。具体来说就是layer渲染的纹理数据最终是交给EGL本地窗口了，而本地窗口和FrameBufferSurface使用同一个BufferQueue,FrameBufferSurface作为BufferQueue的消费端最终会接收来自于DisplayDevice本地窗口的Buffer数据，这个是通过DisplayDevice的swapBuffer触发的，swapBuffer会使本地窗口的Buffer数据通过BufferQueue的queueBuffer入队，这样就能触发FrameBufferSurface的onFrameAvaliable回调。 1234567891011121314151617//frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp//EGL合成好的Buffer最终会通过该回调通知FramebufferSurfacevoid FramebufferSurface::onFrameAvailable() &#123; sp&lt;GraphicBuffer&gt; buf; sp&lt;Fence&gt; acquireFence; status_t err = nextBuffer(buf, acquireFence);//取到合成好的纹理Buffer if (err != NO_ERROR) &#123; ALOGE("error latching nnext FramebufferSurface buffer: %s (%d)", strerror(-err), err); return; &#125; //将纹理Buffer通过HWC设置到显示设备的缓冲区中，准确来说是放在DisplayData的FramebufferTarget中 err = mHwc.fbPost(mDisplayType, acquireFence, buf); if (err != NO_ERROR) &#123; ALOGE("error posting framebuffer: %d", err); &#125;&#125; 通过EGL合成好的数据最终会通过FramebufferSurface的onFrameAvaliable回调消费，这里先通过nexBuffer取到合成好的GraphicBuffer的数据，然后通过HWComposer的fbPost方法将取到的GraphicBuffer保存到设备的framebufferTarget中。 1234567891011121314status_t FramebufferSurface::nextBuffer(sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence) &#123; Mutex::Autolock lock(mMutex); BufferQueue::BufferItem item; status_t err = acquireBufferLocked(&amp;item, 0);//获取BufferItem ... //根据获取的BufferItem取到对应的GrapicBuffer mCurrentBufferSlot = item.mBuf; //去对应槽内的Buffer mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer; outFence = item.mFence; outBuffer = mCurrentBuffer; return NO_ERROR;&#125; nextBuffer通过acquireBufferLocked取到BufferItem，然后从item中取到对应的槽索引mCurrentBufferSlot,最后根据该索引取到对应的GraphicBuffer。 1234567891011121314151617181920212223242526272829303132333435363738394041//将合成好的Buffer保存在DisplayData 的frameBufferTarget成员中int HWComposer::fbPost(int32_t id, const sp&lt;Fence&gt;&amp; acquireFence, const sp&lt;GraphicBuffer&gt;&amp; buffer) &#123; //硬件合成模块的API版本要是1.1才支持framebufferTarget if (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; return setFramebufferTarget(id, acquireFence, buffer); &#125; else &#123; acquireFence-&gt;waitForever("HWComposer::fbPost"); return mFbDev-&gt;post(mFbDev, buffer-&gt;handle); &#125;&#125;//将EGL合成好的纹理buffer设置到显示设备DispData的framebufferTarget中status_t HWComposer::setFramebufferTarget(int32_t id, const sp&lt;Fence&gt;&amp; acquireFence, const sp&lt;GraphicBuffer&gt;&amp; buf) &#123; if (uint32_t(id)&gt;31 || !mAllocatedDisplayIDs.hasBit(id)) &#123; return BAD_INDEX; &#125; //要设置的显示设备的DisplayData DisplayData&amp; disp(mDisplayData[id]); if (!disp.framebufferTarget) &#123; // this should never happen, but apparently eglCreateWindowSurface() // triggers a Surface::queueBuffer() on some // devices (!?) -- log and ignore. ALOGE("HWComposer: framebufferTarget is null"); return NO_ERROR; &#125; int acquireFenceFd = -1; if (acquireFence-&gt;isValid()) &#123; acquireFenceFd = acquireFence-&gt;dup(); &#125; // ALOGD("fbPost: handle=%p, fence=%d", buf-&gt;handle, acquireFenceFd); //设置taget handle为buffer的handle disp.fbTargetHandle = buf-&gt;handle; disp.framebufferTarget-&gt;handle = disp.fbTargetHandle; //设置fence disp.framebufferTarget-&gt;acquireFenceFd = acquireFenceFd; return NO_ERROR;&#125; fbPost将取到的GraphicBuffer通过setFramebufferTarget保存到相应设备的framebufferTarget中，这样就完成设备layer GLES合成的内容。 postFramebuffer 在doComposition的最后一步是将设备的合成好的layer和需要硬件合成的layer一起提交给硬件合成模块，让其进行最终的显示。 这个是通过postFramebuffer完成的。 123456789101112131415161718192021222324252627//通知硬件合成模块进行合成void SurfaceFlinger::postFramebuffer()&#123; ... HWComposer&amp; hwc(getHwComposer()); if (hwc.initCheck() == NO_ERROR) &#123; if (!hwc.supportsFramebufferTarget()) &#123; // EGL spec says: // "surface must be bound to the calling thread's current context, // for the current rendering API." getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); &#125; //提交给硬件合成显示 hwc.commit(); &#125; ……&#125;//将layer数据提交给硬件合成模块status_t HWComposer::commit() &#123; int err = NO_ERROR; if (mHwc) &#123; //将mLists提交给硬件合成，注意mLists是一个hwc_display_contents_1指针数组，它存放了显示设备最终要显示的图层数据。 err = mHwc-&gt;set(mHwc, mNumDisplays, mLists); ... &#125; return (status_t)err;&#125; 最终通过HWComposer的commit方法，将设备数和hwc_display_contents_1指针数据一起传递给硬件的合成模块，hwc_display_contents_1包含了通过GLES合成的layer，它的信息保存hwLayers的最后一个hwc_layer_l_t中， 同时hwLayers还可能有需要进行硬件合成的layer。不管怎么样，它们都是一起提交给硬件合成模块的，硬件负责对这些layer进行最终的合成渲染。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceFlinger之绘图缓冲区]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfaceflinger-buffer-src%2F</url>
    <content type="text"><![CDATA[SurfaceFlinger是GUI系统的核心服务，它主要负责图层的合成任务，同时它为每个应用程序维护一个Client，Client又是由多个Layer组成，Layer对应应用端的Window，这样SurfaceFlinger就能通过Layer来明白各个应用的绘图需求，从而将其合成显示。本篇将从SurfaceFlinger的角度来分析系统是如何通过Layer来管理绘图缓冲区。 缓冲队列 绘图缓冲区是通过BufferQueeu进行管理的，它是一个缓冲区队列，从生产消费的角度来说它同时为消费者和生产者，这里看看它的结构便可以知道 123class BufferQueue : public BnGraphicBufferProducer, public BnGraphicBufferConsumer, private IBinder::DeathRecipient BufferQueue同时是一个Binder,因此它也就具有跨进程的能力。本篇将会根据具体的使用来分析BufferQueue是如何同时作为消费者和生产者的。 BufferQueue的构成 BufferQueue内部是一个BufferSlot数组，大小为32，BufferSlot即Buffer槽用来描述一块缓冲区，需要注意的是BufferQueue在初始情况下并未分配缓冲区，只有当用户进行申请时才真正的分配缓冲区。一个缓冲区一旦被分配它便具有了状态,分别是： FREE 表明该Buffer空闲，可以dequeue被生产者使用，此时它的拥有者为BufferQueue。 DEQUEUED 表示该Buffer已经被生产者dequeue，但还未入队或者取消，此时生产者是它的拥有者 QUEUED 表明这个Buffer已经被生产者填充好内容，等待消费者进行消费，此时它的拥有者为BufferQueue ACQUIRED 表示该Buffer块被消费者获取到，此时消费者作为其拥有者。 1234567891011121314151617181920212223242526272829303132333435363738enum BufferState &#123; // FREE indicates that the buffer is available to be dequeued // by the producer. The buffer may be in use by the consumer for // a finite time, so the buffer must not be modified until the // associated fence is signaled. // // The slot is "owned" by BufferQueue. It transitions to DEQUEUED // when dequeueBuffer is called. FREE = 0, // DEQUEUED indicates that the buffer has been dequeued by the // producer, but has not yet been queued or canceled. The // producer may modify the buffer's contents as soon as the // associated ready fence is signaled. // // The slot is "owned" by the producer. It can transition to // QUEUED (via queueBuffer) or back to FREE (via cancelBuffer). DEQUEUED = 1, // QUEUED indicates that the buffer has been filled by the // producer and queued for use by the consumer. The buffer // contents may continue to be modified for a finite time, so // the contents must not be accessed until the associated fence // is signaled. // // The slot is "owned" by BufferQueue. It can transition to // ACQUIRED (via acquireBuffer) or to FREE (if another buffer is // queued in asynchronous mode). QUEUED = 2, // ACQUIRED indicates that the buffer has been acquired by the // consumer. As with QUEUED, the contents must not be accessed // by the consumer until the fence is signaled. // // The slot is "owned" by the consumer. It transitions to FREE // when releaseBuffer is called. ACQUIRED = 3&#125;; BufferQueue作为消费者 View在第一次进行绘制时会从WMS请求一个Surface绘图表面，这个绘图表面实际上会通过IGrpahicBufferProducer来请求绘图缓冲区，它实际上是一个IBinder Client，它的服务端即BufferQueue是在为WMS对应的Window对象创建SF端的Layer对象时创建 123456789101112131415161718void Layer::onFirstRef() &#123; // Creates a custom BufferQueue for SurfaceFlingerConsumer to use mBufferQueue = new SurfaceTextureLayer(mFlinger); mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(mBufferQueue, mTextureName); mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0)); mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(this); mSurfaceFlingerConsumer-&gt;setName(mName);#ifdef TARGET_DISABLE_TRIPLE_BUFFERING#warning "disabling triple buffering" mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(2);#else mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(3);#endif const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice()); updateTransformHint(hw);&#125; 这里的SurfaceTextureLayer是BufferQueue的子类，它在Layer对象被创建后第一次引用时创建。 123456789101112131415161718192021222324252627282930313233status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123; // initialize the surfaces switch (format) &#123; case PIXEL_FORMAT_TRANSPARENT: case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break; case PIXEL_FORMAT_OPAQUE:#ifdef NO_RGBX_8888 format = PIXEL_FORMAT_RGB_565;#else format = PIXEL_FORMAT_RGBX_8888;#endif break; &#125;#ifdef NO_RGBX_8888 if (format == PIXEL_FORMAT_RGBX_8888) format = PIXEL_FORMAT_RGBA_8888;#endif *outLayer = new Layer(this, client, name, w, h, flags); status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags); if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getBufferQueue(); &#125; return err;&#125; 可以看到Layer被创建后，通过getBufferQueue得到该缓冲队列，这个队列是以一个Binder代理返回给应用端的，应用端最终是通过该BufferQueue来请求缓冲区，从而通过该缓冲区构造SkCanvas最终提交给上层使用的。从这个角度来讲BufferQueue是作为生产者的。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vsync信号图形绘制-Choreographer源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-choreographer%2F</url>
    <content type="text"><![CDATA[Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。 Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vsync信号。垂直信号到来后就要开始准备绘制下一帧的数据。Choreographer主要是在ViewRootImpl中使用的，ViewRootImpl是view树的管理者，负责view树的逻辑处理及事件事件输入。 所有的绘制流程是从ViewRootImpl.java的scheduleTraversals开始的，这个方法会去请求vsync信号，并在信号到来时去绘制更新ui。 12345678910void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //请求vsync信号，当vsync信号到达后开始mTraversalRunnable任务,垂直信号的接受由ChoreoGrpaher负责 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); …… &#125;&#125; 这里我们不关心具体的绘制过程，主要是看Choreographer如何通过vysnc信号来协调界面的绘制。 这里首先是通过Choreographer对象mChoreographer对象post了一个回调，告诉Choreographer当vsync信号到达时帮我调用mTraversalRunable回调。这个回调的定义如下： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal();//vsync信号到达后执行绘制流程 &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); doTraversal()内部会调用performTraversals()方法，从而开启view绘制的三大流程。 下面我们看看Choreographer是如何将vsync接受信号并告之ViewRoomImpl的刷新回调的。我们就从这个postCallback入手分析。 12345678910111213141516171819202122232425262728public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; …… postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;//post一个延时回调private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //将请求的回调按照相应的类型添加到回调队列中，这里会根据一个失效时间来构造 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123;//延时为0时调用 ，对于scheduleTraversals走这里 scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; postCallback最终会调用postCallbackDelayedInternal，参数delayMillis为0，所以会调用scheduleFrameLocked进一步进行操作。这里需要注意的是每次请求都会添加到其类型对应的回调队列中， 这里的mCallbackQueues是一个根据类型区分的回调队列，有四种类型，分别是输入回调，动画回调和绘制回调以及Choreographer.CALLBACK_COMMIT。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123;//使用vsync信号更新 if (DEBUG_FRAMES) &#123; Log.d(TAG, "Scheduling next frame on vsync."); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123;//通过ui线程发送请求等待一个vsync信号 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms."); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125;``` 这个USE_VSYNC代表我们系统使用vsync信号进行屏幕信号的同步，这个方法是在我们的ui线程操作的，所以会发送MSG_DO_SCHEDULE_VSYNC请求vsync信号。这里的mHandler是一个FrameHandler```javaprivate final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync();//请求vsync信号 break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 接着调用doScheduleVsync 1234567void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125; 123private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();//请求vsync信号&#125; 这里的mDisplayEventReceiver是一个FrameDisplayEventReceiver对象，它继承了DisplayEventReceiver，其中实现了其方法onVsync，这个方法就是当onVsync信号到达时的回调方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//垂直信号到达@Overridepublic void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won't send us vsyncs for secondary displays // but that could change in the future so let's log a message to help us remember // that we need to fix this. //并不是sf内置的display if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, "Received vsync from secondary display, but we don't support " + "this case yet. Choreographer needs a way to explicitly request " + "vsync for a specific display to ensure it doesn't lose track " + "of its scheduled vsync."); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f) + " ms in the future! Check that graphics HAL is generating vsync " + "timestamps using the correct timebase."); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, "Already have a pending vsync event. There should only be " + "one at a time."); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125;@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);//垂直信号到来触发&#125;&#125; 垂直信号vsync到来后会触发doFrame，在这个方法里面会进行我们的回调，即mTraversalRunnable。 12345678910111213141516171819202122void doFrame(long frameTimeNanos, int frame) &#123; …… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);//回调输入事件的相关回调 mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);//回调动画相关的回调 mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);//回调绘制相关的回调 doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ……&#125; 123456789101112131415161718192021222324void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS);//获取相关类型的回调 if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true;…… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, "RunCallback: type=" + callbackType + ", action=" + c.action + ", token=" + c.token + ", latencyMillis=" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos);//调用回调 &#125; &#125; ……&#125; 这里会根据类型从队列中取出相应的回调进行调用。这个就是上层对于vsync的处理。接下来我们看看底层的vsync信号是如何传递给Choreographer的。这就需要看看FrameDisplayEventReceiver的父类DisplayEventReceiver，这个DisplayEventReceiver会通过native层进行初始化，native层通过它的成员方法dispatchVsync将vsync信号报告给上层，即调用onVsync。我们先看其构造方法: 1234567891011public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException("looper must not be null"); &#125; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource);//初始化接收器 mCloseGuard.open("dispose");&#125; 其构造方法是调用nativeInit进行初始化的，并将当前对象this作为一个接收器传递给底层。我们看看这个方法 123456789101112131415161718192021222324frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp//注册显示事件接收器 receiverWeak即DisplayEventReceiverstatic jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj, jint vsyncSource) &#123; //这个messageQueue是通过ui线程的Looper构造的 sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, "MessageQueue is not initialized."); return 0; &#125; sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue, vsyncSource);//创建本地接收器 status_t status = receiver-&gt;initialize();//初始化native的接受器 if (status) &#123; String8 message; message.appendFormat("Failed to initialize display event receiver. status=%d", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 在初始化方法中会创建本地的接受器对象，它同时是用我们传递的java层的接受器对象构造的，构造完成后即进行初始化。这个NativeDisplayEventReceiver的定义如下 12345678910111213141516171819//native的显示事件接受器class NativeDisplayEventReceiver : public DisplayEventDispatcher &#123;public: NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource); void dispose();protected: virtual ~NativeDisplayEventReceiver();private: jobject mReceiverWeakGlobal;//java层的接收器对象 sp&lt;MessageQueue&gt; mMessageQueue; DisplayEventReceiver mReceiver; virtual void dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count); virtual void dispatchHotplug(nsecs_t timestamp, int32_t id, bool connected);&#125;; NativeDisplayEventReceiver继承自DisplayEventDispatcher，而DisplayEventDispatcher又实现了LooperCallback的接口handleEvent，这个方法是Looper的事件回调，也就是当Looper接受到消息后会对其进行调用，那么这个DisplayEventDispatcher就是负责进行消息事件的转发的。后面我们看看它是如何将vsync信号转发的。 12345678910111213141516//初始化receiverstatus_t DisplayEventDispatcher::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW("Failed to initialize display event receiver, status=%d", result); return result; &#125; int rc = mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL);//添加事件侦听,这里的this代表注册的是一个LooperCallback, //当事件到达后会调用其handleEvent方法,这个可以具体参见Looper的实现 if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 这里的addFd将其注册到为Looper的事件回调，注意这里第四个参数this，因为DisplayEventDispatcher是继承LooperCallback的。这样当事件到来后会调用handleEvent。 还有，在NativeDisplayEventReceiver的内部持有一个DisplayEventReceiver对象，这个对象比较重要，它是负责和Sf打交道的。 1234567891011DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != NULL) &#123; //通过sf建立连接，这里就应该很熟悉了，这个连接创建好后在第一次引用时会去注册到EventThread中 mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource); if (mEventConnection != NULL) &#123; mDataChannel = std::make_unique&lt;gui::BitTube&gt;(); mEventConnection-&gt;stealReceiveChannel(mDataChannel.get()); &#125; &#125;&#125; 12345678sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection( ISurfaceComposer::VsyncSource vsyncSource) &#123; if (vsyncSource == eVsyncSourceSurfaceFlinger) &#123; return mSFEventThread-&gt;createEventConnection(); &#125; else &#123;//如果时app端的就走这里 return mEventThread-&gt;createEventConnection(); &#125;&#125; 刚刚说到DisplayEventReceiver是和Sf打交道的， 它和NativeDisplayEventReceiver是同时创建的。在其构造方法中首先通过sf的createDisplayEventConnection创建一个连接对象即Connection对象，mEventThread是管理绘图延时对象的vsync信号处理，它是一个EventThread。Connection就是由它创建的。 123sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));//创建一个新的连接，这个连接在第一个被引用时会去进行注册&#125; 这个connection在第一次被引用时会进行注册，即将其添加到mEventThread的连接队列，在vsync消息到来时调用其postEvent方法对事件进行转发。 1234567891011121314151617181920212223242526272829303132333435void EventThread::Connection::onFirstRef() &#123; // NOTE: mEventThread doesn't hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125;//注册创建的连接，实际上时将创建的连接添加到监听队列，并通知等待的线程status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; Mutex::Autolock _l(mLock); mDisplayEventConnections.add(connection);//添加到连接队列中 mCondition.broadcast();//唤醒等待的线程 return NO_ERROR;&#125;bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event);//post事件 …… &#125; return true;&#125;status_t EventThread::Connection::postEvent( const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; postEvent实际上会调用DisplayEventReceiver的setEvents方法，这样会触发getEvents的回调从而通过DisplayEventDispatcher的handleEvent回调方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel, Event const* events, size_t count)&#123; return gui::BitTube::sendObjects(dataChannel, events, count);//发送接受到的事件&#125;int DisplayEventDispatcher::handleEvent(int, int events, void*)&#123; …… // Drain all pending events, keep the last vsync. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;//丢弃所有的等待事件，只保留上次的vsync信号事件 ALOGV("dispatcher %p ~ Vsync pulse: timestamp=%" PRId64 ", id=%d, count=%d", this, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount); mWaitingForVsync = false; dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);//分派vsync信号 &#125; return 1; // keep the callback&#125;bool DisplayEventDispatcher::processPendingEvents( nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123;//等待事件到来 ALOGV("dispatcher %p ~ Read %d events.", this, int(n)); for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // Later vsync events will just overwrite the info from earlier // ones. That's fine, we only care about the most recent. gotVsync = true; *outTimestamp = ev.header.timestamp;//timestamp *outId = ev.header.id;//id *outCount = ev.vsync.count;//count break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; &#125; &#125; return gotVsync;&#125;&#125;void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal)); if (receiverObj.get()) &#123; ALOGV("receiver %p ~ Invoking vsync handler.", this); env-&gt;CallVoidMethod(receiverObj.get(), gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); ALOGV("receiver %p ~ Returned from vsync handler.", this); &#125; mMessageQueue-&gt;raiseAndClearException(env, "dispatchVsync");&#125; 最终调用NativeDisplayEventReceiver的dispatchVsync回调给java层的dispatchVsync，这样vsync信号就传递给上层应用了。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUI系统之SurfaceFlinger之VSYNC信号的产生和处理(二)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfaceflinger-vsync-src%2F</url>
    <content type="text"><![CDATA[SurfaceFlinger中VSYNC信号的控制同步 SurfaceFlinger（简称SF）的绘制合成过程是在VSYNC信号(即垂直同步信号)的控制下同步进行的，所以VSYNC信号可以说是SF的指挥官，它的协调同步控制对于界面绘制效率至关重要。本篇将介绍VYSNC信号在SF服务中是如何发挥这个指挥官的角色。 SurfaceFlinger中的VSYNC SufaceFlinger的初始化是在init方法中进行的，这个方法中关于VYSNC信号有两个DispSyncSource，分别为App绘制延时源和SF合成延时源，这两个信号源基于同一个VSYNC信号模型mPrimaryDispSync，它是一个DispSync对象，DispSync是对硬件Hwc垂直信号的同步模型，那么为什么在有硬件VSYNC信号的情况下还需要一个这样的同步模型呢？实际上，这个是Android系统的一种优化策略，因为在VYSNC信号到来后，App绘制和SF合成过程如果此时同时进行，可能会竞争CPU，从而会影响绘制效率，为了避免竞争引入了VYSNC同步模型DispSync，该模型会根据需要打开硬件的VYSNC信号进行采样，然后同步VSYNC信号模型，从而为上层的绘制延时源和合成延时源提供VYSNC信号，基于该同步模型，绘制延时源和合成延时源可以分别在此基础上添加一个相位偏移量(vsyncPhaseOffsetNs和sfVsyncPhaseOffsetNs)，以此错开绘制和合成在VYSNC信号到来后的执行。 12345678910111213141516171819202122232425void SurfaceFlinger::init() &#123; ... //创建合成对象HWComposer，这里会打开fb和hwc硬件设备，HWComposer代表的不一定就是实际的底层硬件设备 mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this)); …… // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true);//App绘制延时 绘制垂直同步源 mEventThread = new EventThread(vsyncSrc);//这个EventThread负责管理绘制的Vsync同步源 sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, false);//SF合成延时 由于延时的不同，渲染和合成在收到真正的VSync信号之后错开执行。 mSFEventThread = new EventThread(sfVsyncSrc);//这个EventThread负责管理合成的Vsync同步源 mEventQueue.setEventThread(mSFEventThread);//这里会建立一个EventConnection，实际上就是注册成为了一个监听者，这样当有vsync信号时可以通知给MessageQueue …… //给HWC硬件发送消息,用来控制打开关闭Vsync信号 mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run("EventControl", PRIORITY_URGENT_DISPLAY); …… // set initial conditions (e.g. unblank default device) initializeDisplays();//初始化显示器，这里会重新打开Vsync信号，默认它在EventControlThread中设置是关闭的。 ...&#125; 硬件VSYNC信号的产生 在介绍VSYNC信号如何来协调绘制和合成过程前，我们先看硬件VSYNC信号是如何产生并传递给同步模型DispSync。首先硬件的垂直信号是通过显示设备产生的，它通过HAL层的HWComposer模块将硬件垂直信号发送给SF。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cppHWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false)&#123; ... int fberr = loadFbHalModule();//打开fb设备 loadHwcModule();//打开hwc模块 if (mHwc) &#123;//支持硬件合成 if (mHwc-&gt;registerProcs) &#123; mCBContext-&gt;hwc = this; mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; mCBContext-&gt;procs.vsync = &amp;hook_vsync;//硬件垂直信号的回调 if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))//1.1版本支持热插拔 mCBContext-&gt;procs.hotplug = &amp;hook_hotplug; else mCBContext-&gt;procs.hotplug = NULL; memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero)); mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);//注册回调 &#125; // don't need a vsync thread if we have a hardware composer needVSyncThread = false;//支持硬件合成的话就不需要软件进行模拟了 // always turn vsync off when we start //先关闭VSYNC，后面会重新打开 eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); …… &#125; if (mFbDev) &#123;//fb设备已经打开 DisplayData&amp; disp(mDisplayData[HWC_DISPLAY_PRIMARY]); disp.connected = true; //设置主屏幕的参数，包括显示参数包括宽度、高度，像素格式以及刷新频率 disp.width = mFbDev-&gt;width; disp.height = mFbDev-&gt;height; disp.format = mFbDev-&gt;format; disp.xdpi = mFbDev-&gt;xdpi; disp.ydpi = mFbDev-&gt;ydpi; if (disp.refresh == 0) &#123; disp.refresh = nsecs_t(1e9 / mFbDev-&gt;fps); &#125; if (disp.refresh == 0) &#123; disp.refresh = nsecs_t(1e9 / 60.0); &#125; &#125; //需要通过软件模拟Vsync信号 if (needVSyncThread) &#123; // we don't have VSYNC support, we need to fake it mVSyncThread = new VSyncThread(*this); &#125;&#125; HWComposer对象负责SF的硬件合成，理所当然VSYNC信号也应该由其提供，在其构造方法中，会加载hwc设备模块，并将VSYNC信号的回调hook_vsync注册到hwc设备中这样硬件产生的VSYNC信号就可以回调给HWCoposer对象的hook_vsync。需要注意的是HWComposer并不一定就是底层存在的硬件设备，它也可以代表一个虚拟设备，这样VSYNC信号就是通过一个VSyncThread线程模拟硬件产生的。 1234567891011121314151617181920212223242526272829//通知HWComposer垂直事件到达void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp, int64_t timestamp) &#123; cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;( const_cast&lt;hwc_procs_t*&gt;(procs)); ctx-&gt;hwc-&gt;vsync(disp, timestamp);&#125;//VSYNC事件到达void HWComposer::vsync(int disp, int64_t timestamp) &#123; if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123; &#123; Mutex::Autolock _l(mLock); // There have been reports of HWCs that signal several vsync events // with the same timestamp when turning the display off and on. This // is a bug in the HWC implementation, but filter the extra events // out here so they don't cause havoc downstream. if (timestamp == mLastHwVSync[disp]) &#123; ALOGW("Ignoring duplicate VSYNC event from HWC (t=%lld)", timestamp); return; &#125; mLastHwVSync[disp] = timestamp; &#125; …… mEventHandler.onVSyncReceived(disp, timestamp);//sf回调 将vsync消息通告给sf &#125;&#125; 在hook_vsync方法中进一步调用HWComposer的vsync方法通知VSYNC信号事件，在vsync方法中，最终是通过EventHandler的onVsyncReceived方法通知给SF的，这个EventHandler是在构造HWComposer时由SF提供的，实际上SF本身就是继承自HWComposer::EventHandler，而HWComposer::EventHandler的定义如下： 123456789101112class HWComposer&#123;public: class EventHandler &#123; friend class HWComposer; virtual void onVSyncReceived(int disp, nsecs_t timestamp) = 0;//vynsc消息回调 virtual void onHotplugReceived(int disp, bool connected) = 0; protected: virtual ~EventHandler() &#123;&#125; &#125;;&#125; 所以VSYNC信号是通过vsync方法的mEventHandler回调onVsyncReceived通知给SF，我们看看SF是如何实现的onVsyncReceived方法 12345678910111213141516void SurfaceFlinger::onVSyncReceived(int type, nsecs_t timestamp) &#123; bool needsHwVsync = false; &#123; // Scope for the lock Mutex::Autolock _l(mHWVsyncLock); if (type == 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123;//mPrimaryHWVsyncEnabled是用来标识主屏幕对应的HWC的VSYNC功能有没有被开启 needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);//统计Vsync样本 &#125; &#125; if (needsHwVsync) &#123; enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125;&#125; 到这一步，我们看到硬件产生的同步信号最终是交给同步模型DispSync的addResyncSample方法，根据该方法的返回值，可以根据需要控制硬件是否继续发送垂直信号，可见，硬件的垂直信号并不是持续产生的，而是同步模型在需要的时候才打开的，而什么时候需要，是由addResyncSample计算得到的。 这里我们顺便看看硬件的垂直信号是如何打开和关闭的。 1234567891011121314151617181920212223//开启硬件Vsyncvoid SurfaceFlinger::enableHardwareVsync() &#123; Mutex::Autolock _l(mHWVsyncLock); if (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123; mPrimaryDispSync.beginResync(); //eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, true); mEventControlThread-&gt;setVsyncEnabled(true); mPrimaryHWVsyncEnabled = true; &#125;&#125;//禁用硬件Vsyncvoid SurfaceFlinger::disableHardwareVsync(bool makeUnavailable) &#123; Mutex::Autolock _l(mHWVsyncLock); if (mPrimaryHWVsyncEnabled) &#123; //eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, false); mEventControlThread-&gt;setVsyncEnabled(false); mPrimaryDispSync.endResync(); mPrimaryHWVsyncEnabled = false; &#125; if (makeUnavailable) &#123; mHWVsyncAvailable = false; &#125;&#125; 硬件垂直信号的开关是通过mEventControlThread的setVysncEnable方法控制的，在SF的init方法中会创建这个mEventControlThread，它是一个EventControlThread，也是一个线程。 12345678910111213141516171819202122232425262728293031void EventControlThread::setVsyncEnabled(bool enabled) &#123; Mutex::Autolock lock(mMutex); mVsyncEnabled = enabled; mCond.signal();&#125;bool EventControlThread::threadLoop() &#123;//EventControlThread主要用来控制硬件是否应该发送Vsync信号 Mutex::Autolock lock(mMutex); bool vsyncEnabled = mVsyncEnabled; //EventControlThread是在SF的Init中创建的，所以硬件Vsync信号默认是关闭的，这个在屏幕点亮后会开启 mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled); while (true) &#123; status_t err = mCond.wait(mMutex);//没有控制信号的时候是阻塞的 if (err != NO_ERROR) &#123; ALOGE("error waiting for new events: %s (%d)", strerror(-err), err); return false; &#125; //状态发生了变化，则通知SF来控制Vysnc，HWC_DISPLAY_PRIMARY代表了主显示屏，EVENT_VSYNC说明控制的是VSync信号 if (vsyncEnabled != mVsyncEnabled) &#123; mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled); vsyncEnabled = mVsyncEnabled; &#125; &#125; return false;&#125; 在threadLoop中，它一开始默认的就通过SF的eventControl将硬件的VSYNC信号关闭，然后进入到while循环中阻塞，当通过setVsyncEnabled设置了mVsyncEnabled并唤醒线程后，根据设置的状态，通过SF的eventControl将通知hwc开关VSYNC信号。当然，在SF初始化完成后会打开硬件的VSYNC信号。这个流程我简单的介绍下。 SurfaceFlinger::initializeDisplays SurfaceFlinger::onInitializeDisplays SurfaceFlinger::onScreenAcquired SurfaceFlinger::resyncToHardwareVsync 123456789101112131415161718192021222324void SurfaceFlinger::resyncToHardwareVsync(bool makeAvailable) &#123; Mutex::Autolock _l(mHWVsyncLock); if (makeAvailable) &#123; mHWVsyncAvailable = true; &#125; else if (!mHWVsyncAvailable) &#123; ALOGE("resyncToHardwareVsync called when HW vsync unavailable"); return; &#125; const nsecs_t period = getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);// //获得显示设备的刷新率 mPrimaryDispSync.reset(); mPrimaryDispSync.setPeriod(period);//设置DispSync模型里period为显示设备的频率 if (!mPrimaryHWVsyncEnabled) &#123; mPrimaryDispSync.beginResync(); //eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, true); //如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC mEventControlThread-&gt;setVsyncEnabled(true);//打开硬件的VSYNC功能,即在屏幕点亮的时候打开 mPrimaryHWVsyncEnabled = true; &#125;&#125; SF在init中会对显示设备进行一次初始化，这个初始化的过程最终会通过resyncToHardwareVsync根据显示设备设置同步模型的刷新频率同时也会打开硬件的VSYNC信号，以此为VSYNC同步模型做好同步的准备。 DispSync同步模型 硬件VSYNC是如何产生并交给同步模型的过程我们已经清楚了，接下来，我们看看同步模型是如何处理硬件的同步信号并为上层的监听者提供VSYNC信号的。 123456789//Vsync的同步模型对象 默认会启动一个线程进行信号同步DispSync::DispSync() &#123; mThread = new DispSyncThread();//启动同步线程，在在线程中等待垂直信号的到达 mThread-&gt;run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE); reset(); beginResync(); ……&#125; 在DisySync构造方法中会默认的开启一个同步线程DispSyncThread，这个线程负责进行VYSNC信号的同步同时会将垂直同步信号发送给感兴趣的监听者(比如我们在SF的init方法中创建的两个延时源DispSyncSource) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class DispSyncThread: public Thread &#123; ... virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);//当前时间 nsecs_t nextEventTime = 0; while (true) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations;//回调列表 nsecs_t targetTime = 0; &#123; // Scope for lock Mutex::Autolock lock(mMutex); if (mStop) &#123; return false; &#125; if (mPeriod == 0) &#123;//还未设置模型频率，则等待 err = mCond.wait(mMutex); if (err != NO_ERROR) &#123; ALOGE("error waiting for new events: %s (%d)", strerror(-err), err); return false; &#125; continue; &#125; nextEventTime = computeNextEventTimeLocked(now); targetTime = nextEventTime;//触发时间 bool isWakeup = false; if (now &lt; targetTime) &#123;//还未到触发时间，则等待一段时间 err = mCond.waitRelative(mMutex, targetTime - now); if (err == TIMED_OUT) &#123;//等待时间到达触发时间 isWakeup = true; &#125; else if (err != NO_ERROR) &#123; ALOGE("error waiting for next event: %s (%d)", strerror(-err), err); return false; &#125; &#125; now = systemTime(SYSTEM_TIME_MONOTONIC); if (isWakeup) &#123; mWakeupLatency = ((mWakeupLatency * 63) + (now - targetTime)) / 64; if (mWakeupLatency &gt; 500000) &#123; // Don't correct by more than 500 us mWakeupLatency = 500000; &#125; if (traceDetailedInfo) &#123; ATRACE_INT64("DispSync:WakeupLat", now - nextEventTime); ATRACE_INT64("DispSync:AvgWakeupLat", mWakeupLatency); &#125; &#125; //收集此次应该通知的监听者 callbackInvocations = gatherCallbackInvocationsLocked(now); &#125; if (callbackInvocations.size() &gt; 0) &#123; //回调通知，调用注册的事件，即SF中的绘图延时和合成延时对象 fireCallbackInvocations(callbackInvocations); &#125; &#125; return false; &#125;&#125; DispSyncThread的逻辑很简单，它通过一个while循环，来不断的通过computeNextEventTimeLocked计算下一次VSYNC信号的时间，然后通过gatherCallbackInvocationsLocked收集要通知的监听者，最后通过fireCallbackInvocations来通知他们VSYNC信号的到达事件。这里最关键的是VYSNC信号的计算过程，同步模型是如何按照监听者的延时要求提供VSYNC信号的，它是如何保证VSYNC信号的精度和有序性的？以及模型出现误差后是如何做出调整？要回答这些问题，需要对同步模型的整个机制进行完整和全面的了解。这里为了保证文章篇幅，我们不会对同步模型做详细的描述，这里只简单的描述下即可。 前面我们知道SF在接收到硬件的VSYNC信号后通过addResyncSample方法来将信号发送给同步模型的进行样本统计。下面我们看看其实现， 12345678910111213141516171819202122232425bool DispSync::addResyncSample(nsecs_t timestamp) &#123; Mutex::Autolock lock(mMutex); size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES; mResyncSamples[idx] = timestamp; if (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123; mNumResyncSamples++; &#125; else &#123; mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES; &#125; updateModelLocked(); if (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123; resetErrorLocked(); &#125; if (runningWithoutSyncFramework) &#123; // If we don't have the sync framework we will never have // addPresentFence called. This means we have no way to know whether // or not we're synchronized with the HW vsyncs, so we just request // that the HW vsync events be turned on whenever we need to generate // SW vsync events. return mThread-&gt;hasAnyEventListeners(); &#125; return mPeriod == 0 || mError &gt; errorThreshold;&#125; 在该方法中，同步模型会收集硬件的Vsync信号的时间戳信息到mResyncSamples中，最多保存MAX_RESYNC_SAMPLES(定义为32)个硬件的VSYNC信号的时间信息，其中mNumResyncSamples和mFirstResyncSample构成了一个大小为32的VSYNC信号窗口，这个窗口最多可以包含32份硬件的VSYNC信号的时间戳信息，其中mFirstResyncSample是窗口的第一个VSYNC信号样本，而mNumResyncSamples表示已经有多少个信号样本。有了这些样本，就可以基于此来更新我们的同步模型的来使其和硬件的VSYNC信号同步。这个是通过updateModelLocked方法来完成的。 123456789101112131415161718192021222324252627282930313233343536373839404142void DispSync::updateModelLocked() &#123; if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123; nsecs_t durationSum = 0; for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES; // durationSum 表示保存的所有样本(除去第一个vsync)时间间隔之后，用于后面计算 平均 mPeriod // mResyncSamples[idx] - mResyncSamples[prev] 这个差值就是计算出两个硬件vsync样本之间的时间间隔 durationSum += mResyncSamples[idx] - mResyncSamples[prev]; &#125; //这个平均值就是硬件vsync产生的时间间隔 mPeriod = durationSum / (mNumResyncSamples - 1); //下面计算出模型需要的偏移 double sampleAvgX = 0; double sampleAvgY = 0; double scale = 2.0 * M_PI / double(mPeriod); //将硬件vsync的时间间隔换算成对应的度数,即刻度，这里的刻度表示每ns代表多少度 for (size_t i = 0; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; nsecs_t sample = mResyncSamples[idx]; double samplePhase = double(sample % mPeriod) * scale; sampleAvgX += cos(samplePhase); sampleAvgY += sin(samplePhase); &#125; //获得在x轴与y轴的偏移的平均值 sampleAvgX /= double(mNumResyncSamples); sampleAvgY /= double(mNumResyncSamples); //最后再通过atan2获得最终的相移值 mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale); //如果相移小于0 ，那么重新调整一下 if (mPhase &lt; 0) &#123; mPhase += mPeriod; &#125; if (traceDetailedInfo) &#123; ATRACE_INT64("DispSync:Period", mPeriod); ATRACE_INT64("DispSync:Phase", mPhase); &#125; // 将最新的 偏移 mPhase和 vsync时间间隔mPeriod 更新到模型当中 mThread-&gt;updateModel(mPeriod, mPhase); &#125;&#125; updateModelLocked方法根据统计的样本来更新同步模型，只有当样本数大于等于MIN_RESYNC_SAMPLES_FOR_UPDATE(定义为3)时才进行模型的更新，当样本数大于等于3时先通过样本计算mPerid，这个值时计算方式是统计所有相邻样本的时间间隔总和到durationSum中，然后除以样本数减1就是样本的频率mPeriod。接下来计算模型的偏移，因为现在 mPeriod 算出来的是平均值，所以并不是真的硬件vsync时间间隔就是 mPeriod, 存在着误差，即有些样本信号的时间间隔大于平均值，而有些样本时间间隔小于平均值，而这些与mPriod的差值就是偏移，下面就是要算出这些平均的偏移值，计算偏移值后会将偏移值mPhase和时间间隔mPeriod更新到模型中。 123456 void updateModel(nsecs_t period, nsecs_t phase) &#123; Mutex::Autolock lock(mMutex); mPeriod = period; mPhase = phase; mCond.signal();&#125; 随后在同步模型线程中computeNextEventTimeLocked基于统计样本计算的mPeriod和mPhase计算下一次的VSYNC信号，接下来我们看看computeNextEventTimeLocked是如何实现的。 123456789101112131415161718192021222324252627282930//得到最接近的下次VSYNC信号的时间nsecs_t computeNextEventTimeLocked(nsecs_t now) &#123; nsecs_t nextEventTime = INT64_MAX; for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i],now); if (t &lt; nextEventTime) &#123; nextEventTime = t; &#125; &#125; return nextEventTime;&#125;//为监听者计算下次Vsync信号事件发生时间nsecs_t computeListenerNextEventTimeLocked(const EventListener&amp; listener, nsecs_t ref) &#123; nsecs_t lastEventTime = listener.mLastEventTime;//上次的事件 if (ref &lt; lastEventTime) &#123; ref = lastEventTime; &#125; nsecs_t phase = mPhase + listener.mPhase; nsecs_t t = (((ref - phase) / mPeriod) + 1) * mPeriod + phase; if (t - listener.mLastEventTime &lt; mPeriod / 2) &#123; t += mPeriod; &#125; return t;&#125; computeNextEventTimeLocked针对所有的监听者计算下一次的VSYNC信号的发生时间，并将最接近当前时间的一次作为结果返回，而每个监听者的下一次VSYNC信号的发生时间可能是不同，因为他们可能设置了不同的偏移，因此针对每个监听者计算下一次VSYNC信号的发生时间是通过computeListenerNextEventTimeLocked完成的。 同步模型并不一定完全准确，每次计算可能都会有误差的出现，当出现误差后，则需要更新误差值，根据误差值来判断是否需要开启硬件VSYNC重新添加样本到同步模型中进行计算。这个过程是在SF的postCompostion中进行的。 123456789101112131415void SurfaceFlinger::postComposition()&#123; ... const HWComposer&amp; hwc = getHwComposer(); sp&lt;Fence&gt; presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY); if (presentFence-&gt;isValid()) &#123; if (mPrimaryDispSync.addPresentFence(presentFence)) &#123; enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125; &#125; ...&#125; 在postComposition中先拿到当前设备的Fence,然后通过addPresentFence计算同步模型的误差值，根据误差值来决定是否需要启用硬件VSYNC。 通知监听者 1234567891011121314151617181920//收集回调，根据回调的延时偏量计算是否要触发回调Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t ref = now - mPeriod; for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], ref); if (t &lt; now) &#123;//小于当前时间的都是需要通知的监听者 CallbackInvocation ci; ci.mCallback = mEventListeners[i].mCallback; ci.mEventTime = t; callbackInvocations.push(ci); mEventListeners.editItemAt(i).mLastEventTime = t; &#125; &#125; return callbackInvocations;&#125; 计算完下次要触发VSYNC信号的时间后，可能需要等待一段时间，因为当前时间还未到达最近的触发事件，当到达触发的时间后，同步模型线程会通过gatherCallbackInvocationsLocked收集需要进行通知的监听者，如果监听者的下次VSYNC信号发生时间已经小于本次VSYNC信号的触发时间，则说明监听者需要进行通知了，将其添加到集合中等待回调。 123456//回调对同步模型的VSync信号感兴趣的监听者void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123; for (size_t i = 0; i &lt; callbacks.size(); i++) &#123; callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime); &#125;&#125; 最后通过监听者的添加的回调通知其VSYNC信号已经到达。 绘图延时源和合成延时源(DispSyncSource) 在SF的init方法中我们知道SF创建了两个延时源对象DispSyncSource，他们基于同步模型来处理VSYNC信号，这两个不同的延时源通过两个不同的EventThread来管理，他们分别为mEventThread和mSFEventThread，这里的EventThread是为了延时源方便管理VSYNC信号，比如对于绘图延时源，它的监听者就有大名鼎鼎的Choreographer，上层App的绘制过程正是在Choreographer的协调下同步进行的，而Choreographer正是注册到绘图延时源的EventThread中以此来监听VSYNC信号，而SF是注册到合成延时源的EventThread中。 下面我们看看由同步模型传递给延时源的VSYNC信号是如何使用传递给需要的监听者的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class DispSyncSource : public VSyncSource, private DispSync::Callback &#123;//VsyncSource定义在EventThread.hpublic: //DispSync是Vsync信号的模型对象 DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, bool traceVsync) : mValue(0), mPhaseOffset(phaseOffset),//距离Vsync信号的延时偏移 mTraceVsync(traceVsync), mDispSync(dispSync) &#123;&#125; virtual ~DispSyncSource() &#123;&#125; virtual void setVSyncEnabled(bool enable) &#123; // Do NOT lock the mutex here so as to avoid any mutex ordering issues // with locking it in the onDispSyncEvent callback. if (enable) &#123;//如果启用Vsync status_t err = mDispSync-&gt;addEventListener(mPhaseOffset, static_cast&lt;DispSync::Callback*&gt;(this));//添加Vsync信号的事件回调 if (err != NO_ERROR) &#123; ALOGE("error registering vsync callback: %s (%d)", strerror(-err), err); &#125; ATRACE_INT("VsyncOn", 1); &#125; else &#123; status_t err = mDispSync-&gt;removeEventListener( static_cast&lt;DispSync::Callback*&gt;(this)); if (err != NO_ERROR) &#123; ALOGE("error unregistering vsync callback: %s (%d)", strerror(-err), err); &#125; ATRACE_INT("VsyncOn", 0); &#125; &#125; virtual void setCallback(const sp&lt;VSyncSource::Callback&gt;&amp; callback) &#123; Mutex::Autolock lock(mMutex); mCallback = callback; &#125;private: //实现了DispSync的回调接口,这个回调是在DispSync中通过fireCallbackInvocations来调用的 virtual void onDispSyncEvent(nsecs_t when) &#123; sp&lt;VSyncSource::Callback&gt; callback; &#123; Mutex::Autolock lock(mMutex); callback = mCallback; if (mTraceVsync) &#123; mValue = (mValue + 1) % 2; ATRACE_INT("VSYNC", mValue); &#125; &#125; if (callback != NULL) &#123; callback-&gt;onVSyncEvent(when);//调用设置的回调 &#125; &#125; int mValue; const nsecs_t mPhaseOffset; const bool mTraceVsync; DispSync* mDispSync; sp&lt;VSyncSource::Callback&gt; mCallback; Mutex mMutex;&#125;; 延时源通过同步模型DispSync来构造，同步模型通过接口onDispSyncEvent上报给延时源VSYNC信号，并通过延时源设置的回调callback的onVSyncEvent方法将VSYNC信号的到达事件发送给设置者(事实上就是EventThread)。同时，延时源可以通过setVSyncEnabled方法来控制是否监听来自于同步模型的VSYNC信号。 EventThread EventThread顾明思议，它实际上也是一个Thread，它创建的时候就会启动该线程.我们看看它的线程回调 1234567891011121314151617181920212223242526272829//frameworks/native/services/surfaceflinger/EventThread.cppbool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event);//阻塞中，等待VYSNC信号通知 // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event);//post事件 if (err == -EAGAIN || err == -EWOULDBLOCK) &#123; // The destination doesn't accept events anymore, it's probably // full. For now, we just drop the events on the floor. // FIXME: Note that some events cannot be dropped and would have // to be re-sent later. // Right-now we don't have the ability to do this. ALOGW("EventThread: dropping event (%08x) for connection %p", event.header.type, conn.get()); &#125; else if (err &lt; 0) &#123; // handle any other error on the pipe as fatal. the only // reasonable thing to do is to clean-up this connection. // The most common error we'll get here is -EPIPE. removeDisplayEventConnection(signalConnections[i]); &#125; &#125; return true;&#125; 线程回调方法首先通过waitForEvent等待VSYNC信号的通知，同时获取到需要通知的Connection，这里的Connection就是延时源VSYNC信号的监听者，随后通过Connection的postEvent方法将事件发送给监听者，所以EventThread最核心的内容应该是在waitForEvent中进行处理的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//当接收到vsync信号时接收到 或者至少有一个连接对VSYNC信号感兴趣此方法返回给调用者Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent( DisplayEventReceiver::Event* event)&#123; Mutex::Autolock _l(mLock); Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; do &#123; bool eventPending = false; bool waitForVSync = false; size_t vsyncCount = 0; nsecs_t timestamp = 0; //关键点1 垂直信号事件 for (int32_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; timestamp = mVSyncEvent[i].header.timestamp; if (timestamp) &#123; // we have a vsync event to dispatch *event = mVSyncEvent[i];//垂直事件到来 mVSyncEvent[i].header.timestamp = 0; vsyncCount = mVSyncEvent[i].vsync.count; break; &#125; &#125; if (!timestamp) &#123; // no vsync event, see if there are some other event eventPending = !mPendingEvents.isEmpty(); if (eventPending) &#123; // we have some other event to dispatch *event = mPendingEvents[0];//其他的事件 mPendingEvents.removeAt(0); &#125; &#125; // find out connections waiting for events //关键点2 查看是否有对VSYNC信号感兴趣的连接 size_t count = mDisplayEventConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());//取得连接 if (connection != NULL) &#123; bool added = false; if (connection-&gt;count &gt;= 0) &#123;//关于这个显示屏垂直信号的客户端个数大于等于0 // we need vsync events because at least // one connection is waiting for it waitForVSync = true;//至少有一个连接在等待VSync事件 if (timestamp) &#123; // we consume the event only if it's time // (ie: we received a vsync event) if (connection-&gt;count == 0) &#123; // fired this time around connection-&gt;count = -1; signalConnections.add(connection); added = true; &#125; else if (connection-&gt;count == 1 || (vsyncCount % connection-&gt;count) == 0) &#123; // continuous event, and time to report it signalConnections.add(connection); added = true; &#125; &#125; &#125; if (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123; // we don't have a vsync event to process // (timestamp==0), but we have some pending // messages. signalConnections.add(connection); &#125; &#125; else &#123; // we couldn't promote this reference, the connection has // died, so clean-up! mDisplayEventConnections.removeAt(i); --i; --count; &#125; &#125; // Here we figure out if we need to enable or disable vsyncs //关键点3 根据需要开启和关闭VSYNC信号，这里的开启和关闭是指注册回调到延时源以及从同步源移除或者添加监听 if (timestamp &amp;&amp; !waitForVSync) &#123;//收到了一个垂直信号当时没有客户端感兴趣 // we received a VSYNC but we have no clients // don't report it, and disable VSYNC events disableVSyncLocked(); &#125; else if (!timestamp &amp;&amp; waitForVSync) &#123; // we have at least one client, so we want vsync enabled // (TODO: this function is called right after we finish // notifying clients of a vsync, so this call will be made // at the vsync rate, e.g. 60fps. If we can accurately // track the current state we could avoid making this call // so often.) enableVSyncLocked();//启用Vsync &#125; // note: !timestamp implies signalConnections.isEmpty(), because we // don't populate signalConnections if there's no vsync pending if (!timestamp &amp;&amp; !eventPending) &#123; // wait for something to happen if (waitForVSync) &#123;//如果VSYNC信号未到达，但有管兴趣的连接等待VSYNC，则等待VSYNC信号，线程阻塞等待唤醒 // This is where we spend most of our time, waiting // for vsync events and new client registrations. // // If the screen is off, we can't use h/w vsync, so we // use a 16ms timeout instead. It doesn't need to be // precise, we just need to keep feeding our clients. // // We don't want to stall if there's a driver bug, so we // use a (long) timeout when waiting for h/w vsync, and // generate fake events when necessary. bool softwareSync = mUseSoftwareVSync; nsecs_t timeout = softwareSync ? ms2ns(16) : ms2ns(1000); if (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123; if (!softwareSync) &#123; ALOGW("Timed out waiting for hw vsync; faking it"); &#125; // how do we decide which display id the fake // vsync came from ? mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;//消息类型 mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY; mVSyncEvent[0].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC); mVSyncEvent[0].vsync.count++; &#125; &#125; else &#123;//没有对VSync信号感兴趣的，只是让线程阻塞 // Nobody is interested in vsync, so we just want to sleep. // h/w vsync should be disabled, so this will wait until we // get a new connection, or an existing connection becomes // interested in receiving vsync again. mCondition.wait(mLock); &#125; &#125; &#125; while (signalConnections.isEmpty()); // here we're guaranteed to have a timestamp and some connections to signal // (The connections might have dropped out of mDisplayEventConnections // while we were asleep, but we'll still have strong references to them.) return signalConnections;&#125; 垂直事件到达后会将其保存在参数event中，如果timestamp是0，表示没有VSYNC信号到达。mDisplayEventConnections中保存了已经注册的监听者。如果此时connection的count大于等于0，则表示有监听者对VSYNC信号感兴趣，同时置waitForVSync为true,同时将该监听者添加到signalConnections集合中。这里connection的count值的含义如下： count &gt;= 1 : continuous event. count is the vsync rate 如果在大于等于1，表示会持续接收vsync event count == 0 : one-shot event that has not fired 表示只接收一次 count ==-1 : one-shot event that fired this round / disabled 等于-1，表示不能再接收vsync事件了 当满足timestamp &amp;&amp; !waitForVSync时表示VSYNC信号已经到达，但是此时没有感兴趣的监听者，所以此时不需要再接收VSYNC信号了，通过disableVSyncLocked移除对同步模型的VSYNC信号的监听。 当!timestamp &amp;&amp; waitForVSync满足时则说明有感兴趣的监听者，但VSYNC信号还未达到，这时候需要使用enableVSyncLocked将延时源添加到同步模型的监听者集合中。 如果!timestamp &amp;&amp; !eventPending则表示没有VSYNC信号到达，且没有其他等待的事件，但此时如果waitForVSync为true,则要等待VSYNC信号，但此时不会无限等待下去，而是有一个超时时间。 当VSYNC信号到达后，通过EventThread设置的callback来接收来自同步模型的VSYNC信号，这个回调就是EventThread的onVSyncEvent方法 12345678void EventThread::onVSyncEvent(nsecs_t timestamp) &#123; Mutex::Autolock _l(mLock); mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;//准备好发送的消息 mVSyncEvent[0].header.id = 0; mVSyncEvent[0].header.timestamp = timestamp; mVSyncEvent[0].vsync.count++; mCondition.broadcast();//广播解除threadloop的阻塞&#125; 在onVSyncEvent方法中，会解除在waitForEvent中等待VSYNC信号的阻塞状态。从而退出while循环，通知相应的监听者VSYNC信号的到达。 总结 至此，我们就将VSYNC信号在SF中的传递和控制过程介绍完了，我们简单总结下整个传递过程： 硬件或者由软件模拟触发VSYNC信号，通知给SF SF接收到硬件的VSYNC信号后将其添加到同步模型DispSync的样本数组中进行统计和计算模型的偏移和周期 同步模型根据计算的偏移和周期计算下次VSYNC信号发生时间，并通知监听者VSYNC信号到达的事件 同步模型的VSYNC信号传递给延时源，延时源通过EventThread来管理VSYNC信号的收发 参考 Android 5.1 SurfaceFlinger VSYNC详解 https://blog.csdn.net/newchenxf/article/details/49131167 DispSync https://echuang54.blogspot.com/2015/01/dispsync.html Android中的GraphicBuffer同步机制-Fence https://blog.csdn.net/jinzhuojun/article/details/39698317]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUI系统之SurfaceFlinger HAL层(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfaceflinger-1-src%2F</url>
    <content type="text"><![CDATA[SurfaceFlinger是GUI系统的核心，本篇将以自底向上的方式对其展开介绍。 硬件层面 Linux 内核提供了统一的famebuffer显示驱动，设备节点/dev/graphics/fb* 或者 /dev/fb*,fb0是第一个显示屏。 HAL层面 HAL即硬件抽象层，Android的各个子系统通常不会直接使用内核驱动，而是由HAL层简介引用底层架构。Android的HAL层提供了Gralloc，包括了fb和gralloc两个设备。前者负责打开内核中的framebuffer，初始化配置；后者则管理帧缓冲去的分配和释放。 在HAL层中还有一个重要的模块 “Composer”，它为厂商自定制“UI合成”提供了接口。Composer的直接使用者是SurfaceFlinger中的HWComposer Gralloc模块 下面我们就从HAL层来看看Gralloc的结构 123456789101112131415161718hardware\libhardware\include\hardware\gralloc.htypedef struct gralloc_module_t &#123; struct hw_module_t common;//每个硬件模块对应的结构都需要hw_module_t这个抽象模块 int (*registerBuffer)(struct gralloc_module_t const* module, buffer_handle_t handle); int (*unregisterBuffer)(struct gralloc_module_t const* module, buffer_handle_t handle); int (*lock)(struct gralloc_module_t const* module, buffer_handle_t handle, int usage, int l, int t, int w, int h, void** vaddr); int (*unlock)(struct gralloc_module_t const* module, buffer_handle_t handle); …………… void* reserved_proc[3];&#125; gralloc_module_t; 对于以上的结构体需要注意的是： 1.每一个硬件都有其对应的模块结构，并且该结构的第一个成员必须为hw_module_t结构，该结构是HAL层对硬件的统一抽象。所以每一个硬件模块都要对应一个hw_module_t结构，并且名称必须为HAL_MODULE_INFO_SYM。 12345678910111213141516hardware\libhardware\include\hardware\hardware.htypedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;//version_major uint16_t hal_api_version;//version_minor const char *id; const char *name; const char *author; struct hw_module_methods_t* methods;&#125; hw_module_t;typedef struct hw_module_methods_t &#123; int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_module_t结构用来描述硬件模块的基本信息，如当前的版本，模块Id以及硬件模块对应的打开方法。 Gralloc模块负责管理gralloc设备和fb设备，它是处于HAL层的，向上提供了这个两个设备的功能。其中最主要的两个接口分别为gralloc_device_open和gralloc_alloc。 我们先看gralloc_device_open，这个方法负责打开gralloc或者fb设备的。 12345678910111213141516171819202122232425262728//gralloc模块的打开设备方法int gralloc_device_open(const hw_module_t* module, const char* name, hw_device_t** device)&#123; int status = -EINVAL; if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) &#123;//打开GPU gralloc_context_t *dev; dev = (gralloc_context_t*)malloc(sizeof(*dev)); /* initialize our state here */ memset(dev, 0, sizeof(*dev)); /* initialize the procs */ dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; dev-&gt;device.common.version = 0; dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); dev-&gt;device.common.close = gralloc_close; dev-&gt;device.alloc = gralloc_alloc; dev-&gt;device.free = gralloc_free; *device = &amp;dev-&gt;device.common; status = 0; &#125; else &#123;//打开fb设备 status = fb_device_open(module, name, device); &#125; return status;&#125; 参数name指定了要打开的模块，Name为GRALLOC_HARDWARE_GPU0说明打开的是GPU，否则打开fb设备。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//对外的分配缓冲区的方法static int gralloc_alloc(alloc_device_t* dev, int width, int height, int format, int usage, buffer_handle_t* pHandle, int* pStride)&#123; if (!pHandle || !pStride) return -EINVAL; int bytesPerPixel = 0; switch (format) &#123;//指定的缓冲区像素格式 case HAL_PIXEL_FORMAT_RGBA_FP16: bytesPerPixel = 8; break; case HAL_PIXEL_FORMAT_RGBA_8888: case HAL_PIXEL_FORMAT_RGBX_8888: case HAL_PIXEL_FORMAT_BGRA_8888: bytesPerPixel = 4; break; case HAL_PIXEL_FORMAT_RGB_888: bytesPerPixel = 3; break; case HAL_PIXEL_FORMAT_RGB_565: case HAL_PIXEL_FORMAT_RAW16: bytesPerPixel = 2; break; default: return -EINVAL; &#125; const size_t tileWidth = 2; const size_t tileHeight = 2; size_t stride = align(width, tileWidth); size_t size = align(height, tileHeight) * stride * bytesPerPixel + 4; int err; if (usage &amp; GRALLOC_USAGE_HW_FB) &#123;//在FB设备中分配帧缓冲区 err = gralloc_alloc_framebuffer(dev, size, usage, pHandle); &#125; else &#123;//在内存中分配图形缓冲区 err = gralloc_alloc_buffer(dev, size, usage, pHandle); &#125; if (err &lt; 0) &#123; return err; &#125; *pStride = stride; return 0;&#125; 另一个方法gralloc_alloc 负责为上层分配缓冲区，注意这里的缓冲区既可以是内存缓冲区，也可以是fb的帧缓冲区。这分别是通过gralloc_alloc_buffer 和 gralloc_alloc_framebuffer来实现的。在内存中创建缓冲区是基于asheme的方式来创建一块匿名共享内存来作为缓冲区的，而如果是从fb中分配则只需要将fb的帧缓冲区映射到当前进程来即可。具体可以参见famebuffer.cpp中的mapFrameBufferLocked方法。 关于fb设备 其最重要的功能是将上层缓冲区的内容通过交换显示在屏幕上，这个功能是通过fb_post来实现的，在这之前我们看看如何打开fb设备 1234567891011121314151617181920212223242526272829303132333435363738394041//打开fb设备 这个方法通过HAL层的Gralloc模块提供给上层接口int fb_device_open(hw_module_t const* module, const char* name, hw_device_t** device)&#123; int status = -EINVAL; if (!strcmp(name, GRALLOC_HARDWARE_FB0)) &#123;//打开的是Fb设备 /* initialize our state here */ fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));//分配fb_context_t 结构 memset(dev, 0, sizeof(*dev)); /* initialize the procs */ dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; dev-&gt;device.common.version = 0; dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); dev-&gt;device.common.close = fb_close; dev-&gt;device.setSwapInterval = fb_setSwapInterval; dev-&gt;device.post = fb_post;//设置设备post回调接口，这个接口将缓冲区的内容显示在屏幕上 dev-&gt;device.setUpdateRect = 0; private_module_t* m = (private_module_t*)module; status = mapFrameBuffer(m);//对fb设备进行映射 其实是调用mapFrameBufferLocked if (status &gt;= 0) &#123; int stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; 3); int format = (m-&gt;info.bits_per_pixel == 32) ? (m-&gt;info.red.offset ? HAL_PIXEL_FORMAT_BGRA_8888 : HAL_PIXEL_FORMAT_RGBX_8888) : HAL_PIXEL_FORMAT_RGB_565; const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.flags) = 0; const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres; const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres; const_cast&lt;int&amp;&gt;(dev-&gt;device.stride) = stride; const_cast&lt;int&amp;&gt;(dev-&gt;device.format) = format; const_cast&lt;float&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi; const_cast&lt;float&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi; const_cast&lt;float&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps; const_cast&lt;int&amp;&gt;(dev-&gt;device.minSwapInterval) = 1; const_cast&lt;int&amp;&gt;(dev-&gt;device.maxSwapInterval) = 1; *device = &amp;dev-&gt;device.common; &#125; &#125; return status;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//将缓冲区的内容显示在屏幕上static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)&#123; if (private_handle_t::validate(buffer) &lt; 0) return -EINVAL; fb_context_t* ctx = (fb_context_t*)dev; private_handle_t const* hnd = reinterpret_cast&lt;private_handle_t const*&gt;(buffer); private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( dev-&gt;common.module); if (hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) &#123; //如果缓冲区是来自于fb设备的帧缓冲区 const size_t offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base; m-&gt;info.activate = FB_ACTIVATE_VBL; m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;//直接调整y方向的分辨率偏移既可，不需要做任何拷贝 if (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == -1) &#123;//通过FBIOPUT_VSCREENINFO命令 ALOGE("FBIOPUT_VSCREENINFO failed"); //显示在屏幕上 m-&gt;base.unlock(&amp;m-&gt;base, buffer); return -errno; &#125; m-&gt;currentBuffer = buffer; &#125; else &#123; //否则是来自内存的缓冲区 // If we can't do the page_flip, just copy the buffer to the front // FIXME: use copybit HAL instead of memcpy void* fb_vaddr; void* buffer_vaddr; m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer, GRALLOC_USAGE_SW_WRITE_RARELY, 0, 0, m-&gt;info.xres, m-&gt;info.yres, &amp;fb_vaddr);//对帧缓冲区加锁 m-&gt;base.lock(&amp;m-&gt;base, buffer, GRALLOC_USAGE_SW_READ_RARELY, 0, 0, m-&gt;info.xres, m-&gt;info.yres, &amp;buffer_vaddr);//对内存缓冲区加锁 memcpy(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres);//需要将内存的缓冲区拷贝到fb的帧 缓冲中 m-&gt;base.unlock(&amp;m-&gt;base, buffer); m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer); &#125; return 0;&#125; 好了，对于HAL层的模块分析就到这里了，下篇我们介绍下VSYNC信号相关的内容。 参考 http://blog.csdn.net/luoshengyang/article/details/7747932]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUI系统之SurfaceFlinger启动过程分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-gui-surfaceflinger-startup%2F</url>
    <content type="text"><![CDATA[surfaceFlinger 在init.rc中是作为一个service存在的它声明如下 12345service surfaceflinger /system/bin/surfaceflinger class main user system group graphics drmrpc onrestart restart zygote 从上面的内容可以看出，surfaceflinger所属的class为main，这和zygote时同级的。但它的启动并不需要带任何参数。同时由于surfaceflinger是service,说明它是单独的可执行程序，程序路径为/system/bin/surfaceflinger 运行在单独的进程里，另外，从最后一行也能看出sf重启时要重启zygote。 Surfaceflinger主程序对应的文件是frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp 所以我们从这个文件入手。 1234567891011121314151617181920212223242526272829int main(int argc, char** argv) &#123; // When SF is launched in its own process, limit the number of // binder threads to 4. ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);//限制了binder线程的个数为4 // start the thread pool sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;startThreadPool();//启动binder线程 // instantiate surfaceflinger sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger();//创建SF对象#if defined(HAVE_PTHREADS) setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);#endif set_sched_policy(0, SP_FOREGROUND); // initialize before clients can connect flinger-&gt;init();//SF的初始化 // publish surface flinger sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);//添加到SM中 // run in this thread flinger-&gt;run();//sf运行起来 return 0;&#125; sf的主程序中做了以下事情： 1.初始binder的运行环境 2.创建Sf对象，并对其进行初始化 3.将Sf服务添加到ServiceManger中，以便向其他进程提供服务 4.SF在自己的线程中开始运行 SurfaceFlinger作为服务进程，必然需要通过Binder进行IPC通信，所以在一开始需要对Binder环境进行初始化。接着创建了SurfaceFlinger对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344frameworks/native/services/surfaceflinger/SurfaceFlinger.cppSurfaceFlinger::SurfaceFlinger() : BnSurfaceComposer(), mTransactionFlags(0), mTransactionPending(false), mAnimTransactionPending(false), mLayersRemoved(false), mRepaintEverything(0), mRenderEngine(NULL), mBootTime(systemTime()), mVisibleRegionsDirty(false), mHwWorkListDirty(false), mAnimCompositionPending(false), mDebugRegion(0), mDebugDDMS(0), mDebugDisableHWC(0), mDebugDisableTransformHint(0), mDebugInSwapBuffers(0), mLastSwapBufferTime(0), mDebugInTransaction(0), mLastTransactionTime(0), mBootFinished(false), mPrimaryHWVsyncEnabled(false), mHWVsyncAvailable(false), mDaltonize(false)&#123; // debugging stuff... char value[PROPERTY_VALUE_MAX]; property_get("ro.bq.gpu_to_cpu_unsupported", value, "0"); mGpuToCpuSupported = !atoi(value); property_get("debug.sf.showupdates", value, "0"); mDebugRegion = atoi(value); property_get("debug.sf.ddms", value, "0"); mDebugDDMS = atoi(value); if (mDebugDDMS) &#123; if (!startDdmConnection()) &#123; // start failed, and DDMS debugging not enabled mDebugDDMS = 0; &#125; &#125;&#125; 构造方法很简单，只是都其成员进行初始化，读取一些配置信息，比如是否开启DDMS的调试。 接下来通过init方法对该对象进行初始化。这个初始化过程会做大量比较重要的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp//sf的初始化方法void SurfaceFlinger::init() &#123; status_t err; Mutex::Autolock _l(mStateLock); // initialize EGL for the default display mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);//获取默认的显示设备 eglInitialize(mEGLDisplay, NULL, NULL);//为默认的显示设备初始EGL环境 // Initialize the H/W composer object. There may or may not be an // actual hardware composer underneath. mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this));//创建合成对象 // First try to get an ES2 config err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES2_BIT, &amp;mEGLConfig); if (err != NO_ERROR) &#123; // If ES2 fails, try ES1 err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES_BIT, &amp;mEGLConfig); &#125; …… EGLint r,g,b,a; eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_RED_SIZE, &amp;r); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_GREEN_SIZE, &amp;g); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_BLUE_SIZE, &amp;b); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_ALPHA_SIZE, &amp;a); // get a RenderEngine for the given display / config (can't fail) mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);//通过给定的设备创建渲染引擎 // retrieve the EGL context that was selected/created mEGLContext = mRenderEngine-&gt;getEGLContext();//获取EGL context // figure out which format we got eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_NATIVE_VISUAL_ID, &amp;mEGLNativeVisualId); LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT, "couldn't create EGLContext"); // initialize our non-virtual displays //初始化所有的非虚拟显示设备 for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i); // set-up the displays that are already connected if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123; // All non-virtual displays are currently considered secure. bool isSecure = true; createBuiltinDisplayLocked(type); wp&lt;IBinder&gt; token = mBuiltinDisplays[i]; //为显示设备创建BufferQueue用来管理其帧缓冲区 并通过FramebufferSurface进行管理 sp&lt;BufferQueue&gt; bq = new BufferQueue(new GraphicBufferAlloc()); sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i, bq); sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, type, allocateHwcDisplayId(type), isSecure, token, fbs, bq, mEGLConfig);//为每个实体设备创建显示设备对象 if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123; // FIXME: currently we don't get blank/unblank requests // for displays other than the main display, so we always // assume a connected display is unblanked. ALOGD("marking display %d as acquired/unblanked", i); hw-&gt;acquireScreen(); &#125; mDisplays.add(token, hw); &#125; &#125; // make the GLContext current so that we can create textures when creating Layers // (which may happens before we render something) getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);//将EGL context和默认的显示设备关联 // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true);//创建绘图延时对象 mEventThread = new EventThread(vsyncSrc);//负责管理绘图延时Vsync信号 sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, false);//创建合成延时对象 mSFEventThread = new EventThread(sfVsyncSrc);//负责管理合成延时Vsync信号 mEventQueue.setEventThread(mSFEventThread); mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run("EventControl", PRIORITY_URGENT_DISPLAY); ……&#125; 在init方法中，sf做了以下的事： 1.为默认的显示设备初始EGL环境 2.创建合成对象 3.初始化所有的非虚拟显示设备 4.创建绘图延时Vysnc源 及 合成延时Vysnc源 12345678void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread)&#123; mEventThread = eventThread; mEvents = eventThread-&gt;createEventConnection(); mEventTube = mEvents-&gt;getDataChannel(); mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, ALOOPER_EVENT_INPUT, MessageQueue::cb_eventReceiver, this);//为sf的vsync信号注册事件回调&#125; 需要注意的是在main方法中创建的SurfaceFlinger是个强引用对象，所以在第一次调用同时也会会触发onFirstRef方法，这个方法会对SF的mEventQueue成员进行初始化。它是一个MessageQueue对象，负责SF的消息管理。 1234567891011void SurfaceFlinger::onFirstRef()&#123; mEventQueue.init(this);&#125;void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger)&#123; mFlinger = flinger;//持有sf的引用 mLooper = new Looper(true);//为其创建一个Looper对象 mHandler = new Handler(*this);//创建Handler&#125; 最后调用sf的run方法，这个方法会进入一个循环，不断等待消息的到来并进行处理 123456789101112131415161718192021222324252627282930313233343536void SurfaceFlinger::run() &#123; do &#123; waitForEvent(); &#125; while (true);&#125;void SurfaceFlinger::waitForEvent() &#123; mEventQueue.waitMessage();&#125;frameworks/native/services/surfaceflinger/MessageQueue.cppvoid MessageQueue::waitMessage() &#123; do &#123; IPCThreadState::self()-&gt;flushCommands(); int32_t ret = mLooper-&gt;pollOnce(-1);//内部会调用MessageQueue的handleMessage方法对消息进行处理 switch (ret) &#123; case ALOOPER_POLL_WAKE: case ALOOPER_POLL_CALLBACK: continue; case ALOOPER_POLL_ERROR: ALOGE("ALOOPER_POLL_ERROR"); case ALOOPER_POLL_TIMEOUT: // timeout (should not happen) continue; default: // should not happen ALOGE("Looper::pollOnce() returned unknown status %d", ret); continue; &#125; &#125; while (true);&#125;//通过消息的handler对消息进行处理void MessageBase::handleMessage(const Message&amp;) &#123; this-&gt;handler(); barrier.open();&#125;; SF的消息来源有两种，一个是Vsync信号，这是通过注册的cb_eventReceiver事件回调来处理的，另一种可能是应用进程或者说客户端的消息，比如创建Layer的请求，就是通过发送消息的方式来处理的。 12345678910111213141516171819202122232425262728293031323334353637383940frameworks/native/services/surfaceflinger/Client.cppstatus_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; class MessageCreateLayer : public MessageBase &#123;//继承子messagbase SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123;//实现了handler 这个方法用于接收方处理消息 result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();&#125;]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-libray-retrofit-src%2F</url>
    <content type="text"><![CDATA[Retrofit源码分析 基于Retrofit2.1.的源码分析，Retrofit的用例如下： 12345678910111213Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.example.com/") .addConverterFactory(GsonConverterFactory.create()) .build();public interface MyApi&#123; @GET('/xx/xx') Call&lt;User&gt; getUser();&#125;MyApi api = retrofit.create(MyApi.class);Response&lt;User&gt; user = api.getUser().execute(); 参数配置 Retrofit使用了Builder的方式来配置参数。 12345678910111213141516171819public static final class Builder &#123; private final Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; public Builder() &#123; this(Platform.get()); &#125; Builder(Platform platform) &#123; this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; Retrofit配置的参数： platform指定了Retrofit使用的平台，可以为Android或者Java8。在不同平台使用了不同的callAdapter以及CallbackExecutor，前者负责转换OkHttpCall为该平台下的Call请求，CallbackExecutor负责将请求投递出去。 callFactory 即Call的工厂类，通过该工厂类可以生成Call对象,这个Call是什么呢？它如下描述所说 A call is a request that has been prepared for execution，A call can be canceled. As this object represents a single request/response pair (stream), it cannot be executed twice Call封装了我们的HTTP请求，它可以被执行调用并返回结果，这样使得http请求对外界来说是透明的，它也是个请求/响应对，Retrofit默认使用OkHttpClient作为其CallFactory。 baseUrl 是Http请求的基址，在接口方法中指定的相对url和该字段拼接为一个完整的url，如示例中的https://api.example.com/ converterFactories 请求结果的转换器，通过该转换器可以将请求的结果转换成我们想要的数据格式或者对象。这是一个集合，可以添加多个转换器，接口方法根据其返回类型决定使用哪个转换器。 adapterFactories 请求适配器用来将生成的请求转换成平台需要的请求对象。 生成调用请求 1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //为Service接口类动态生成代理对象 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //接口方法的调用最终会通过代理对象来完成请求对象的生成 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; create是retrofit最为精妙的部分，它结合了动态代理可以为每个接口方法生成对应的请求，事实上，这会经过以下几步完成： 根据调用的method方法来生成ServiceMethod，ServiceMethod是经过解析后的对象，它根据Method方法的注解来生成了一些创建OKHttpCall所需的信息。 结合解析后的Method对象即ServiceMethod和用户传递的方法参数生成OkHttpCall这是Retroift默认的请求对象 根据Method的返回类型ServiceMethod为Method创建适当的CallAdapter，通过该Adapter可以将创建的OkHttpCall转换成我们需要的Call请求。 针对接口方法生成ServiceMethod 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//ServieMethod也是使用build模式来构建Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method;//对应的Service方法 this.methodAnnotations = method.getAnnotations();//方法的注解 this.parameterTypes = method.getGenericParameterTypes();//参数类型 this.parameterAnnotationsArray = method.getParameterAnnotations();//参数注解&#125;//为Service Method生成描述对象public ServiceMethod build() &#123; callAdapter = createCallAdapter();//为方法的请求生成相应的适配器 responseType = callAdapter.responseType();//响应类型 if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError("'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; responseConverter = createResponseConverter();//创建响应转换器 //解析方法注解 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; //根据解析结果得到的httpMethod不能为空 if (httpMethod == null) &#123; throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.)."); &#125; if (!hasBody) &#123; if (isMultipart) &#123; //multiPart注解必需要body的请求 throw methodError( "Multipart can only be specified on HTTP methods with request body (e.g., @POST)."); &#125; if (isFormEncoded) &#123;//FormUrlEncoded注解必需要body的请求 throw methodError("FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST)."); &#125; &#125; int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, "No Retrofit annotation found."); &#125; //解析注解参数的值 parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; //如果没有设置相对url 则需要通过@Url指定 if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError("Missing either @%s URL or @Url parameter.", httpMethod); &#125; //如果不是FormUrlEncoded或者MultiPart注解 就不需要@Body注解 if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError("Non-body HTTP method cannot contain @Body."); &#125; //如果提交Form需要至少一个@Filed注解 if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError("Form-encoded method must contain at least one @Field."); &#125; //如果是MultiPart需要至少一个@Part if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError("Multipart method must contain at least one @Part."); &#125; //为接口方法创建ServiceMethod对象 return new ServiceMethod&lt;&gt;(this);&#125; 生成Method对应的CallAdapter 123456789101112131415161718private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType();//取到返回类型 if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123;//返回类型不能为空 throw methodError("Service methods cannot return void."); &#125; Annotation[] annotations = method.getAnnotations();//取到方法的注解 try &#123; //noinspection unchecked //根据返回类型和注解返回相应的CallAdapter,这个CallAdapter用来将OkHttpCall转换为相应平台下的网络请求执行器 return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, "Unable to create call adapter for %s", returnType); &#125;&#125; 生成Method对应的ResponseConverter,它负责将请求的结果进行格式转换。 123456789101112131415161718192021222324252627282930313233private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; Annotation[] annotations = method.getAnnotations();//获取注解 try &#123; return retrofit.responseBodyConverter(responseType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, "Unable to create converter for %s", responseType); &#125;&#125;//转由retrofit处理，因为转换器都配置在这里public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123; return nextResponseBodyConverter(null, type, annotations);&#125;//根据返回类型和注解取到转换器，skipPast为nullpublic &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; int start = converterFactories.indexOf(skipPast) + 1; //从converter集合列表中找到满足要求的转换器就返回，这里需要注意遍历是从集合首部开始，也就是说如果有两//个满足要求的转换器，先添加的转换器先匹配到。 for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; …… //未找到要求的抛出异常 throw new IllegalArgumentException(builder.toString());&#125; 解析Method注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123;//解析@DELETE注解 parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123;//解析@GET注解 parseHttpMethodAndPath("GET", ((GET) annotation).value(), false); &#125; else if (annotation instanceof HEAD) &#123;//解析@HEAD注解 parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false); if (!Void.class.equals(responseType)) &#123; throw methodError("HEAD method must use Void as response type."); &#125; &#125; else if (annotation instanceof PATCH) &#123;//解析@PATCH注解 parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true); &#125; else if (annotation instanceof POST) &#123;//解析@POST注解 parseHttpMethodAndPath("POST", ((POST) annotation).value(), true); &#125; else if (annotation instanceof PUT) &#123;//解析@PUT注解 parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true); &#125; else if (annotation instanceof OPTIONS) &#123;//解析@OPTIONS注解 parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false); &#125; else if (annotation instanceof HTTP) &#123; //解析@HTTP注解，表示一个自定义的HTTP请求，如： // @HTTP(method = "GET", path = "xxx/", hasBody = false) HTTP http = (HTTP) annotation; parseHttpMethodAndPath(http.method(), http.path(), http.hasBody()); &#125; else if (annotation instanceof retrofit2.http.Headers) &#123; String[] headersToParse = ((retrofit2.http.Headers) annotation).value(); if (headersToParse.length == 0) &#123; throw methodError("@Headers annotation is empty."); &#125; headers = parseHeaders(headersToParse); &#125; else if (annotation instanceof Multipart) &#123; //解析@Multipart 表示请求体是多部分的。 每一部分作为一个参数,且用Part注解声明 if (isFormEncoded) &#123; throw methodError("Only one encoding annotation is allowed."); &#125; isMultipart = true; &#125; else if (annotation instanceof FormUrlEncoded) &#123; //解析FormUrlEncoded，表示请求正文将使用表单网址编码。使用FormUrlEncoded注解的请求将具”application / x-www-form-urlencoded” MIME类型 if (isMultipart) &#123; throw methodError("Only one encoding annotation is allowed."); &#125; isFormEncoded = true; &#125;&#125;private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123; if (this.httpMethod != null) &#123; throw methodError("Only one HTTP method is allowed. Found: %s and %s.", this.httpMethod, httpMethod); &#125; this.httpMethod = httpMethod;//HTTP method 只能有一个 this.hasBody = hasBody;//是否有body if (value.isEmpty()) &#123;//注解对应的参数 return; &#125; // Get the relative URL path and existing query string, if present. int question = value.indexOf('?'); if (question != -1 &amp;&amp; question &lt; value.length() - 1) &#123; // Ensure the query string does not have any named parameters. String queryParams = value.substring(question + 1); Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams); if (queryParamMatcher.find()) &#123; throw methodError("URL query string \"%s\" must not have replace block. " + "For dynamic query parameters use @Query.", queryParams); &#125; &#125; this.relativeUrl = value;//相对url this.relativeUrlParamNames = parsePathParameters(value);//相对url中包含的请求参数&#125; HTTP请求的创建 根据ServiceMethod创建OkHttpCall对象，这个代表一个http请求。这个OkHttpCall是Retrofit默认使用的请求对象，如果配置了callAdapterFactory则会通过相应的适配器工厂将该Call请求转换成我们需要的请求对象。 123456789101112131415161718final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod;//service 接口方法的对象 private final @Nullable Object[] args;//网络请求调用的参数 private volatile boolean canceled; @GuardedBy("this") private @Nullable okhttp3.Call rawCall;//实际进行网络请求的的调用对象 @GuardedBy("this") private @Nullable Throwable creationFailure; // Either a RuntimeException or IOException. @GuardedBy("this") private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; 前面我们知道Retrofit在配置过程中 即build时为Retrofit配置默认的CallAdapterFactory，这个是根据PlatForm来决定的，这里我们看看Android平台下它是怎样的一个Adapter。 12345678910111213141516171819202122232425List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));static class Android extends Platform &#123; //返回默认的回调执行器 @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; //Android平台下默认的请求适配工厂 @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); //这里通过回调执行器来构造请求适配工厂 return new ExecutorCallAdapterFactory(callbackExecutor); &#125; //结果回调执行器 用来将请求结果投递到主线程 static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 可以看出Android使用了ExecutorCallAdapterFactory，默认的callbackExecutor使用了MainThreadExecutor，它是一个回调执行器，用来将请求结果投递给主线程的，使用了Handler来投递Runable的方式来返回结果。接下来我们就重点分析下这个ExecutorCallAdapterFactory的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; //Retrofit使用get接口从工厂实例中取到CallAdapter @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; //回调执行器，负责请求结果回调 final Call&lt;T&gt; delegate;//委托对象，这个对象负责HTTP请求的 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; //异步的请求方式 @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, "callback == null"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //回调执行器将结果回调给用户 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; …… //同步的请求方式 @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; …… &#125;&#125; 前面我们分析了为对应的接口方法生成ServiceMethod对象时，同时会为该对象指定一个CallAdapter，这个CallAdapter负责接口方法对应的请求及结果的回调，它是通过Retrofit的callAdapter来获取的，实际上是CallAdapterFactory的get接口从工厂实例中取到CallAdapter，CallAdapter只是一个接口，这里直接创建接口实例对象，其最重要的方法为adapt将请求的Call转换为平台下需要的call，这里我们看到它构造了ExecutorCallbackCall对象。 Http请求是委托给了adapt参数传递过来的Call，它是OkHttpCall负责HTTP请求的。Retrofit支持同步和异步的请求方式，对于异步的请求我们需要回调告诉用户请求结果成功与否，这是通过回调执行器来完成的。这里我们可以看到在CallBack的onResponse中通过callbackExecutor的execute投递请求结果，实际上是通过handler来进行的。这里总共有两个CallBack,第一个是用户传递给enqueue方法的，用户通过这个回调得到请求响应，第二个是用来响应委托请求的，而回调执行器就是在这两个接口之前负责线程切换。 对于同步的请求方式，就很简单了，它不需要回调调用后直接返回响应结果Response，但需要注意同步方式需在子线程使用。 请求过程 从CallAdapter中了解到，HTTP的请求是委托给了OkHttpCall的，因此下面我们需要进一步了解OkHttpCall是如何完成http请求的。 1234567891011121314151617final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod;//接口方法对应的对象 private final @Nullable Object[] args;//请求参数 private volatile boolean canceled; @GuardedBy("this") private @Nullable okhttp3.Call rawCall;//元请求对象 它才是实际上进行http请求的 @GuardedBy("this") private @Nullable Throwable creationFailure; // Either a RuntimeException or IOException. @GuardedBy("this") private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; 从OkHttpCall的类结构我们大致了解OkHttpCall，它负责完成http请求则需要知道接口方法完成HTTP请求的参数以及HTTP请求的一些配置信息，因此我们需要serviceMethod和args，同时由于OkHttpCall它也是一个Call，我们需要控制请求过程，比如发起请求和取消请求。而rawCall看起来是负责OkHttpCall内部的http请求。我们继续看看execute方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//http的异步请求过程@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, "callback == null"); okhttp3.Call call; Throwable failure; //要加锁控制 synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall();//创建一个元请求 &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure);//失败回调 return; &#125; if (canceled) &#123; call.cancel();//取消请求的回调 &#125; //通过okhttp3完成的请求过程并通过回调相应 call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse);//解析相应结果 &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response);//通过callback回调给调用者 &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125;//同步请求过程@Override public Response&lt;T&gt; execute() throws IOException &#123;okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; return parseResponse(call.execute());&#125; 可以看出实际上进行请求的Call是通过createRawCall创建的，我们看看它的实现 12345678private okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call;&#125; 可以看到createRawCall是通过callFactory来创建实际请求的Call的，这个callFactory是在Retrofit中进行配置的，Retrofit倾向于使用OkHttp，它提供了client接口来配置OkHttpClient,它是一个基于OkHttp的call Factory，当然Retrofit同样支持其他的请求库，这也是它为什么会有callFactory的原因。我们完全可以封装HttpUrlConnection作为Retrofit的Call Factory，并通过builder的callFactory方法进行配置，它同volley一样是可以配置自身的请求库的，从这个角度来说Retrofit是比较开放和包容的library。这里我就不继续分析OkHttpClient具体的请求过程了，在介绍OkHttp时再做介绍，感兴趣的童鞋可以自行查看。 请求结果的转换 在上一部分内容中请求的结果最终是送给parseResponse进行处理的，从名称来看它负责解析响应的内容。我们看看它的实现 123456789101112131415161718192021222324252627282930313233343536Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body();//得到ResponseBody // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code();//得到响应码 if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; //这里对请求结果进行转换 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; paserResponse通过请求响应rawResponse构造Response，这里面首先取到响应的ResponseBody，然后构造一个body为空的Response，这个Response只有状态，为什么这么做可能是因为转换后的Response本身就包含了响应内容的，在rawResponse再包含相同的数据传递就没必要了，尤其是当数据内容较大时。随后会根据得到的响应码来做不同的处理，最终会通过Response的success或者error构造Response对象返回给调用者。在最后调用Response的success之前会调用serviceMethod的toResponse对响应内容进行转换。 1234/** Builds a method return value from an HTTP response body. */ R toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body); &#125; 可以看到ServiceMethod的toResponse实际上是通过我们配置的转换器调用convert来完成数据转换的，这里就是将ResponseBody转换成接口方法的返回类型。Retrofit内置了几种转换器，它是通过BuiltInConverters来实现的，这里看看最常用的一种转换器的实现即将ResponseBody转换为Gson对象，实际上我们为Retrofit配置的Converter Factory支持请求和响应的转换，这里我们看看响应转换即GsonResponseBodyConverter的实现 123456789101112131415161718final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;&#125; 转换是通过ResponseBody的字符流来构造JsonReader对象来完成的，具体过程就不分析了。 到这里我们基本上就分析完Retrofit的结构了，从整体的结构来说Retrofit的架构比较简单和直接，代码结构也非常清晰和易读，这是一个优秀框架难得的部分。内部使用了大量的设计模式来解耦，如工厂模式，代理模式，以及装饰模式，适配模式等等，这些设计模式带来的优势也是非常明显的，既使得代码结构清晰，也增强了可拓展性。 总结 Retrofit本质上是一个Restful API的网络请求库，它将http请求封装成接口，通过注解的方式来修饰方法和参数以配置Http请求，内部通过动态代理来生成Http请求的Call对象，生成过程首先通过解析接口方法得到ServiceMethod对象并缓存到Map中， 通过该对象构造一个OkHttpCall，这个负责http的请求，随后通过callAdapter将该请求进行封装和适配以满足PlatForm的要求，在这个过程中异步请求会将Call和callbackExecutor关联起来，以在请求后将结果通过回调执行器投递给调用者。请求完成后通过配置的转换器将响应内容转换为需要的格式。]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANR分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fanr-analysis%2F</url>
    <content type="text"><![CDATA[ANR问题分析 在Android开发的bug调试过程中，ANR算是最让开发者头疼的一种情况，一方面是因为导致ANR发生的原因很多，另一个方面ANR不像一般的BUG可能又会非常明显异常堆栈，最重要的一方面也是因为大多数ANR发生时并没有什么规律可寻，因此也不好重现。本篇笔者将对ANR做一个全面的介绍，并为排除ANR提出可行的方案。 ANR的检测机制 Android对于ANR有多个方面的监测机制： Input事件5秒内未处理超时导致ANR Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。 BroadCast事件处理中如果执行时间超过10秒导致ANR 本篇不打算分析Anroid系统在以上的几种检测机制的实现过程。我们只需要知道ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对操作的响应;否则，就可以认为应用程序主线程失去响应能力。 ANR 日志 CPU日志 ANR发生的进程 ANR发生的原因 CPU负载 各进程的CPU使用率 CPU使用汇总 首先发生ANR时，系统会对该异常做出响应，并在data/anr/traces.txt生成相应的信息。这些信息打印了发生ANR时相关进程堆栈状态，我们正是基于此来分析发生ANR发生的原因。下面我们看一组Anr发生时的logcat日志 123456789101112131415161718192021222324E/SensorsHal( 406): poll() failed (Interrupted system call)E/ActivityManager( 406): ANR in at.smarthome.hcomm E/ActivityManager( 406): PID: 584E/ActivityManager( 406): Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000014 (has extras) &#125;E/ActivityManager( 406): Load: 2.04 / 0.73 / 0.26E/ActivityManager( 406): CPU usage from 5849ms to 0ms ago:E/ActivityManager( 406): 8.7% 725/wpa_supplicant: 0.1% user + 8.5% kernel / faults: 1 minorE/ActivityManager( 406): 1.5% 406/system_server: 0.6% user + 0.8% kernel / faults: 118 minorE/ActivityManager( 406): 1.5% 812/RTW_CMD_THREAD: 0% user + 1.5% kernelE/ActivityManager( 406): 1% 950/com.tt.ttt: 0.3% user + 0.6% kernelE/ActivityManager( 406): 0.1% 584/at.xxx.xxx: 0.1% user + 0% kernel / faults: 29 minorE/ActivityManager( 406): 0.1% 20/kconsole: 0% user + 0.1% kernelE/ActivityManager( 406): 0% 25/irq/58-rk30-adc: 0% user + 0% kernelE/ActivityManager( 406): 0.1% 28/fb-vsync: 0% user + 0.1% kernelE/ActivityManager( 406): 0.1% 30/cfinteractive: 0% user + 0.1% kernelE/ActivityManager( 406): 0.1% 462/com.android.systemui: 0.1% user + 0% kernel / faults: 1 minorE/ActivityManager( 406): 0.1% 640/xx.yyyy.yyyy: 0% user + 0.1% kernel / faults: 12 minorE/ActivityManager( 406): 3.1% TOTAL: 0.5% user + 2.5% kernel + 0% softirqE/ActivityManager( 406): CPU usage from 1858ms to 2367ms later:E/ActivityManager( 406): 3.8% 406/system_server: 0% user + 3.8% kernelE/ActivityManager( 406): 5.7% 421/ActivityManager: 1.9% user + 3.8% kernelE/ActivityManager( 406): 1.4% 97/surfaceflinger: 0% user + 1.4% kernelE/ActivityManager( 406): 1.6% 640/yy.yyyy.yyyy: 1.6% user + 0% kernel / faults: 1 minorE/ActivityManager( 406): 0.5% TOTAL: 0% user + 0.5% kernel 从日志我们可以看到发生anr时的进程信息（包名和PID），以及发生ANR的原因，比如第一个的REASON表示在处理TIME_TICK广播消息超时。 意思是TIME_TICK是一个串行广播消息，在PID为584的进程中，执行BroadcastReceiver.onReceive()方法已经超过10秒，Load关键字表示了最近1分钟，5分钟，15分钟内CPU的负载分别是 2.04 / 0.73 / 0.26，最近1分钟内的负载为2.04，可以理解为CPU最近1分钟平均有2.04个任务处理，这样的CPU负载并不算高，那么发生ANR的具体原因应该不是因为CPU负载过重引起，可能是由于等待IO引起的。CPU关键字后面的是发生ANR时各进程的CPU负载统计 经验法则 如果iowait较高，则倾向考虑是由io读写阻塞导致的 CPU负载较高，考虑程序中是否哪里由做频繁的运算，比如ACTION_MOVE中做一些耗时的运算或者引起频繁GC导致CPU一直被占用这时候再响应Input是就会出现ANR。 内存泄漏导致的内存不足问题，此时Dalvik线程为VMWAIT状态。 死锁导致的ANR 参考 https://duanqz.github.io/2015-10-12-ANR-Analysis]]></content>
  </entry>
  <entry>
    <title><![CDATA[android 属性动画原理]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-animation2-src%2F</url>
    <content type="text"><![CDATA[概述 属性动画是在Android3.0提供的一套全新的动画Api，它和传统的补间动画相比有更大的灵活性。比如我们要使用动画更新一个button的宽度，如果使用补间动画ScaleAnimation那么最后放大后的button是变形的，而使用属性动画实现不存在这样的问题，还有最大的区别在于补间动画不会真正的改变view的属性，而属性动画会。 本篇将从源码角度对属性动画进行分析 ValueAnimation 关于属性动画，我们最常用的类便是ValueAnimation和ObjectAnimator，其中ValueAnimation是ObjectAnimator的父类。它是属性动画实现的核心，所以我们先来看看ValueAnimation的实现 ####继承关系 123public class ValueAnimator extends Animator &#123; ...&#125; ValueAnimator继承自Animator，Animator是属性动画最基本的类，它是一个抽象类，定义了一些属性动画的接口，如start，cancel,setduration，addListener等等，ValueAnimator一般是通过使用其静态的of方法来构造，这里我们看看ofInt的实现,其他of方法实现类似 12345public static ValueAnimator ofInt(int... values) &#123; ValueAnimator anim = new ValueAnimator(); anim.setIntValues(values); return anim;&#125; ofInt构造ValueAnimator实例并通过setIntValues为其设置初始值。 12345678910111213public void setIntValues(int... values) &#123; if (values == null || values.length == 0) &#123; return; &#125; if (mValues == null || mValues.length == 0) &#123; setValues(PropertyValuesHolder.ofInt("", values)); &#125; else &#123; PropertyValuesHolder valuesHolder = mValues[0]; valuesHolder.setIntValues(values); &#125; // New property/values/target should cause re-initialization prior to starting mInitialized = false;&#125; mValues是一个PropertyValuesHolder数组，从名称来看PropertyValuesHolder是属性和值的持有者，它维护属性和值的相关信息。开始mValues是null，继续调用setValues，同时使用PropertyValuesHolder的ofInt方法构造PropertyValuesHolder实例作为参数，属性名为空。 123456789101112131415public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123; return new IntPropertyValuesHolder(propertyName, values);&#125;public void setValues(PropertyValuesHolder... values) &#123; int numValues = values.length; mValues = values; mValuesMap = new HashMap&lt;String, PropertyValuesHolder&gt;(numValues); for (int i = 0; i &lt; numValues; ++i) &#123; PropertyValuesHolder valuesHolder = values[i]; mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder); &#125; // New property/values/target should cause re-initialization prior to starting mInitialized = false;&#125; mValuesMap是一个Map,key值时属性名，value是PropertyValuesHolder，对于每一个属性的PropertyValuesHolder都会保存在mValuesMap中。 1234567891011121314151617181920212223242526@Overridepublic void start() &#123; start(false);&#125;private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException("Animators may only be run on Looper threads"); &#125; mPlayingBackwards = playBackwards; mCurrentIteration = 0; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running setCurrentPlayTime(0); mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; ValueAnimation的启动默认调用了内部的private的start方法，参数playBackwards为false,表示动画是否反向执行。随后通过getOrCreateAnimationHandler创建一个AnimationHandler，然后将当前动画添加到其内部的等待队列mPendingAnimations中，这个animationHandler成员是个AnimationHandler，它是ValueAnimation内部类，如果未设置mStartDelay，则开始执行动画第一帧，随后通过notifyStartListeners通知动画Listener动画启动。 12345678910public void setCurrentPlayTime(long playTime) &#123; initAnimation();//初始化动画 long currentTime = AnimationUtils.currentAnimationTimeMillis();//当前时间 if (mPlayingState != RUNNING) &#123; mSeekTime = playTime; mPlayingState = SEEKED; &#125; mStartTime = currentTime - playTime;//计算动画执行的开始时间 doAnimationFrame(currentTime);//执行动画&#125; setCurrentPlayTime是执行playTime指定的时间点的动画，这个playTime是在[0,duration]的区间内。在setCurrentPlayTime需要先初始化动画，然后设置mSeekTime为0，执行状态为SEEKED，随后通过doAnimationFrame执行动画。 123456789void initAnimation() &#123; if (!mInitialized) &#123; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].init(); &#125; mInitialized = true; &#125;&#125; 动画只需要初始化一次，主要是对PropertyValuesHolder进行初始化，后面我们在看关于PropertyValuesHolder的初始化部分。初始化通过mInitialized标记控制。 1234567891011121314151617181920212223242526final boolean doAnimationFrame(long frameTime) &#123; if (mPlayingState == STOPPED) &#123; mPlayingState = RUNNING;//设置播放状态为RUNNING if (mSeekTime &lt; 0) &#123; mStartTime = frameTime; &#125; else &#123; mStartTime = frameTime - mSeekTime; // Now that we're playing, reset the seek time mSeekTime = -1; &#125; &#125; if (mPaused) &#123; if (mPauseTime &lt; 0) &#123; mPauseTime = frameTime; &#125; return false; &#125; else if (mResumed) &#123; mResumed = false; if (mPauseTime &gt; 0) &#123; // Offset by the duration that the animation was paused mStartTime += (frameTime - mPauseTime); &#125; &#125; final long currentTime = Math.max(frameTime, mStartTime); return animationFrame(currentTime);//如果动画结束了就返回true&#125; mSeekTime为0，mStartTime为frameTime值，即当前的时间值。如果mPaused表示暂停动画中，返回false，mResumed为true表示动画继续执行，此时根据mPauseTime重新计算mStartTime，即动画的开始执行时间，随后取frameTime和mStartTime的最大值传递给animationFrame进一步执行动画。 123456789101112131415161718192021boolean animationFrame(long currentTime) &#123; boolean done = false; switch (mPlayingState) &#123; case RUNNING: case SEEKED: float fraction = mDuration &gt; 0 ? (float)(currentTime - mStartTime) / mDuration : 1f; if (fraction &gt;= 1f) &#123; if (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123; …… &#125;else&#123; done = true; fraction = Math.min(fraction, 1.0f); &#125; &#125; …… animateValue(fraction); break; &#125; return done;&#125; animationFrame中首先根据mDuration计算fraction，fraction即时间流逝的百分比，它的值是客观均匀的，随后通过animateValue计算动画值，这个方法返回动画是否执行完毕。 1234567891011121314void animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; 通过fraction和插值器计算动画插值，我们知道插值器是能够控制动画的执行速率，它根据fraction值计算，ValueAnimation中默认的插值器是AccelerateDecelerateInterpolator，随后通过PropertyValuesHolder的calculateValue根据插值计算动画值，这个动画值就是我们在of方法指定的区间内的值，最后通过onAnimatinoUpdate来通知动画值的更新。到这里我们的动画第一帧就算执行了，那么它如何连续执行呢？这就要靠AnimationHandler了。 12protected static ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler = new ThreadLocal&lt;AnimationHandler&gt;(); 其中AnimationHandler的说明如下 123456789/*** This custom, static handler handles the timing pulse that is shared by* all active animations. This approach ensures that the setting of animation* values will happen on the UI thread and that all animations will share* the same times for calculating their values, which makes synchronizing* animations possible.** The handler uses the Choreographer for executing periodic callbacks.*/ 可以看出AnimationHandler在线程内是由所有活动的动画共享的。它可以保证animation动画值设置操作发生在UI线程，而所有的动画将共享相同的相同值来计算它们自己的值以使动画同步执行。这个handler使用Choreographer来执行周期性的回调。这个Choreographer可以看做是一个Vsync信号的观察者，它为上层应用提供监听VSync信号的接口，应用程序根据该信号刷新UI。 在start的方法最后调用了AnimationHandler的start，我们看看它的内部如何实现 1234567891011121314151617181920212223protected static class AnimationHandler implements Runnable &#123; …… public void start() &#123; scheduleAnimation();//在下一帧中安排动画 &#125; @Override public void run() &#123; mAnimationScheduled = false; doAnimationFrame(mChoreographer.getFrameTime()); &#125; //属性动画是的绘制是交给编舞者来处理绘制的 private void scheduleAnimation() &#123; if (!mAnimationScheduled) &#123; //实际上是post一个Callback给编舞者 在垂直信号到来时这个Callback的run方法会执行 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null); mAnimationScheduled = true; &#125; &#125;&#125; Animationhandler是通过Choreographer来执行动画的，在start方法中调用scheduleAnimation添加当前AnimationHandler到Choreographer的回调队列中，它的类型为Choreographer.CALLBACK_ANIMATION，Choreographer在接收到VSync信号时会通知该回调也就是调用回调的run方法，这里就是执行doAnimationFrame方法，同时重置mAnimationScheduled。所以真正执行动画的是通过doAnimationFrame来完成的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void doAnimationFrame(long frameTime) &#123; //可能有多组等待的动画，将他们启动并添加到活动列表中 while (mPendingAnimations.size() &gt; 0) &#123; ArrayList&lt;ValueAnimator&gt; pendingCopy = (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone(); mPendingAnimations.clear(); int count = pendingCopy.size(); for (int i = 0; i &lt; count; ++i) &#123; ValueAnimator anim = pendingCopy.get(i); // If the animation has a startDelay, place it on the delayed list if (anim.mStartDelay == 0) &#123; anim.startAnimation(this); &#125; else &#123; mDelayedAnims.add(anim); &#125; &#125; &#125; …… //这里将活动动画添加到临时动画中 然后执行doAnimationFrame绘制一帧动画 int numAnims = mAnimations.size(); for (int i = 0; i &lt; numAnims; ++i) &#123; mTmpAnimations.add(mAnimations.get(i)); &#125; for (int i = 0; i &lt; numAnims; ++i) &#123; ValueAnimator anim = mTmpAnimations.get(i); //根据doAnimationFrame的返回值可以知道动画是否结束了 if (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123; mEndingAnims.add(anim); &#125; &#125; mTmpAnimations.clear();//清理添加的临时动画 这里为什么需要一个mTmpAnimations？ if (mEndingAnims.size() &gt; 0) &#123; for (int i = 0; i &lt; mEndingAnims.size(); ++i) &#123; mEndingAnims.get(i).endAnimation(this); &#125; mEndingAnims.clear(); &#125; //如果有活动的动画或者延时的动画就等待下次垂直信号安排下一次绘制 if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123; scheduleAnimation();//再绘制下一帧 &#125;&#125;//将要执行的动画添加到活动列表中private void startAnimation(AnimationHandler handler) &#123; initAnimation(); handler.mAnimations.add(this); if (mStartDelay &gt; 0 &amp;&amp; mListeners != null) &#123; // Listeners were already notified in start() if startDelay is 0; this is // just for delayed animations notifyStartListeners(); &#125;&#125;private void endAnimation(AnimationHandler handler) &#123; handler.mAnimations.remove(this); handler.mPendingAnimations.remove(this); handler.mDelayedAnims.remove(this); mPlayingState = STOPPED; mPaused = false; if ((mStarted || mRunning) &amp;&amp; mListeners != null) &#123; if (!mRunning) &#123; // If it's not yet running, then start listeners weren't called. Call them now. notifyStartListeners(); &#125; ArrayList&lt;AnimatorListener&gt; tmpListeners = (ArrayList&lt;AnimatorListener&gt;) mListeners.clone(); int numListeners = tmpListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; tmpListeners.get(i).onAnimationEnd(this); &#125; &#125; mRunning = false; mStarted = false; mStartListenersCalled = false; mPlayingBackwards = false;&#125; 在doAnimationFrame中首先通过startAnimation将等待的动画启动，它其实将动画添加到活动的动画列表mAnimations并调用开始执行动画的回调。随后对于活动列表中的动画执行doAnimationFrame，它执行一帧动画。对于执行完成的动画调用endAnimation，它分别从活动列表，等待列表，延时列表中移除该动画实例。最后只要有活动的动画，就需要调用scheduleAnimation安排下一帧动画的执行。这样动画就能够连续执行了。 PropertyValuesHolder 在ValueAnimation动画的执行过程中依赖于PropertyValuesHolder，只不过这时候的PropertyName为空，在整个流程中涉及到PropertyValuesHolder的有下面几个部分： 在setValues中通过of方法实例化PropertyValuesHolder 在动画初始化initAnimation方法中调用其init方法 在animateValue中通过PropertyValuesHolder的calculateValue计算动画值 下面就分别看看这些具体是如何实现的 设置values 123public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123; return new IntPropertyValuesHolder(propertyName, values);&#125; 1234567891011121314static class IntPropertyValuesHolder extends PropertyValuesHolder &#123; …… public IntPropertyValuesHolder(String propertyName, int... values) &#123; super(propertyName); setIntValues(values); &#125; @Override public void setIntValues(int... values) &#123; super.setIntValues(values); mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet; &#125; ……&#125; 12345678910111213141516171819202122//PropertyValuesHolder.javapublic void setIntValues(int... values) &#123; mValueType = int.class; mKeyframeSet = KeyframeSet.ofInt(values);&#125;//KeyframeSet.javapublic static KeyframeSet ofInt(int... values) &#123; int numKeyframes = values.length; IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)]; if (numKeyframes == 1) &#123; keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f); keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]); &#125; else &#123; keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]); for (int i = 1; i &lt; numKeyframes; ++i) &#123; keyframes[i] = (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]); &#125; &#125; return new IntKeyframeSet(keyframes);&#125; 我们设置的values最终是以KeyFrameSet的形式存在的，KeyframeSet实际上就是关键帧的值，包含了我们设置的值，以及 每个值对应的fraction。 初始化 1234567891011121314void init() &#123; if (mEvaluator == null) &#123; // We already handle int and float automatically, but not their Object // equivalents mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null; &#125; if (mEvaluator != null) &#123; // KeyframeSet knows how to evaluate the common types - only give it a custom // evaluator if one has been set on this class mKeyframeSet.setEvaluator(mEvaluator); &#125;&#125; init实际上是为PropertyValuesHolder设置估值器，sIntEvaluator实际上就是整型的估值器，在计算动画值时使用，它的实现如下 123456public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 计算动画值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void calculateValue(float fraction) &#123; mAnimatedValue = mKeyframeSet.getValue(fraction);&#125;public Object getValue(float fraction) &#123; if (mNumKeyframes == 2) &#123;//关键帧数目为2的情况 if (mInterpolator != null) &#123;//有插值器先计算插值 fraction = mInterpolator.getInterpolation(fraction); &#125; return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue()); &#125; if (fraction &lt;= 0f) &#123;//关键帧第一帧 final Keyframe nextKeyframe = mKeyframes.get(1); final TimeInterpolator interpolator = nextKeyframe.getInterpolator(); if (interpolator != null) &#123; fraction = interpolator.getInterpolation(fraction); &#125; final float prevFraction = mFirstKeyframe.getFraction(); float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction); return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue()); &#125; else if (fraction &gt;= 1f) &#123;//关键帧最后一帧 final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2); final TimeInterpolator interpolator = mLastKeyframe.getInterpolator(); if (interpolator != null) &#123; fraction = interpolator.getInterpolation(fraction); &#125; final float prevFraction = prevKeyframe.getFraction(); float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction); return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue()); &#125; //其他关键帧 Keyframe prevKeyframe = mFirstKeyframe; for (int i = 1; i &lt; mNumKeyframes; ++i) &#123; Keyframe nextKeyframe = mKeyframes.get(i); if (fraction &lt; nextKeyframe.getFraction()) &#123; final TimeInterpolator interpolator = nextKeyframe.getInterpolator(); if (interpolator != null) &#123; fraction = interpolator.getInterpolation(fraction); &#125; final float prevFraction = prevKeyframe.getFraction(); float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction); return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue()); &#125; prevKeyframe = nextKeyframe; &#125; // shouldn't reach here return mLastKeyframe.getValue();&#125; 动画值最终是通过KeyFrameSet来计算的，我们通过of方法构造的KeyFrameSet,这里通过fraction来计算最终的动画值，fraction可能是经过插值器计算后的，对于关键帧数为2的最简单，直接通过估值器计算即可，startValue就是第一个关键帧的值，endValue就是最后一个关键帧。而当关键帧数目大于2的时候，需要这么计算，这里我举个例子比如ofInt(1,100,200),关键帧的数目为3，对应的KeyFrame分别为[0f,1],[0.5f,100],[1f,200]这里的0f,0.5f,1f分别是keyFrame对应的fraction。在getValue中根据fraction计算动画值时： 如果此时fraction小于0.5，则根据估值器进行如下计算evaluate(intervalFraction，0,100); 如果fraction大于0.5则进行如下计算evaluate(intervalFraction，100,200) ObjectAnimation ObjectAnimator是ValueAnimation的子类，它实际上同ValueAnimation的区别在于，ObjectAnimation包含一个Target和PropertyName，可以在该Target上的Property上应用动画，这个Target不仅仅可以是View。只要Target在该PropertyName上具有setter和getter方法即可。在ObjectAnimation中重载了initAnimation和animateValue方法 123456789101112@Overridevoid initAnimation() &#123; if (!mInitialized) &#123; // mValueType may change due to setter/getter setup; do this before calling super.init(), // which uses mValueType to set up the default type evaluator. int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].setupSetterAndGetter(mTarget); &#125; super.initAnimation(); &#125;&#125; ObjectAnimation相比ValueAnimation会调用PropertyValuesHolder的setupSetterAndGetter方法，从名称上看应该是建立Target的对应属性的setter和getter方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void setupSetterAndGetter(Object target) &#123; …… Class targetClass = target.getClass(); if (mSetter == null) &#123; setupSetter(targetClass);//获取mSetter方法 &#125; for (Keyframe kf : mKeyframeSet.mKeyframes) &#123; if (!kf.hasValue()) &#123; if (mGetter == null) &#123; setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; try &#123; kf.setValue(mGetter.invoke(target)); &#125; catch (InvocationTargetException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; &#125; &#125;&#125;// 获取target对应属性的set方法void setupSetter(Class targetClass) &#123; mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);&#125;//获取target对应属性的get方法private void setupGetter(Class targetClass) &#123; mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, "get", null);&#125;// PropertyValuesHolder.javaprivate Method setupSetterOrGetter(Class targetClass, HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap, String prefix, Class valueType) &#123; Method setterOrGetter = null; try &#123; // Have to lock property map prior to reading it, to guard against // another thread putting something in there after we've checked it // but before we've added an entry to it mPropertyMapLock.writeLock().lock(); HashMap&lt;String, Method&gt; propertyMap = propertyMapMap.get(targetClass); if (propertyMap != null) &#123; setterOrGetter = propertyMap.get(mPropertyName);//从缓存中取 &#125; if (setterOrGetter == null) &#123;//没有的话，就从target中取 setterOrGetter = getPropertyFunction(targetClass, prefix, valueType); if (propertyMap == null) &#123; propertyMap = new HashMap&lt;String, Method&gt;(); propertyMapMap.put(targetClass, propertyMap); &#125; propertyMap.put(mPropertyName, setterOrGetter); &#125; &#125; finally &#123; mPropertyMapLock.writeLock().unlock(); &#125; return setterOrGetter;&#125; setupSetterOrGetter方法会通过getPropertyFunction获取属性对应的get或者set方法，获取到以后缓存到propertyMapMap中，propertyMapMap以target实例为key，以一个Map&lt;String,Method&gt;为value。这个Map是用于保存属性对应的Method，其中key就是属性的名称。 12345678910111213141516171819202122232425//ObjectAnimator.java@Overridevoid animateValue(float fraction) &#123; super.animateValue(fraction); int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].setAnimatedValue(mTarget); &#125;&#125;//PropertyValuesHolder.javavoid setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; try &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125; catch (InvocationTargetException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; &#125;&#125; ObjectAnimator的animateValue和ValueAnmiation的实现是不同的，ObjectAnimator会通过PropertyValuesHolder的setAnimatedValue方法为Target设置属性值。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Tween动画原理]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-animation-src%2F</url>
    <content type="text"><![CDATA[Android提供了几种基本的动画： 帧动画 补间动画 属性动画 其中属性动画和补间动画比较常用，它们最大的区别在于补间动画并不会真正的改变View的属性，什么意思呢？比如通过补间动画将页面中的Button从左边移动到右边一段距离，如果此时点击Button，它不会对点击事件做出响应，这是因为button的作用区域(点击该区域依然可以触发click事件)依然在原来的位置，这是补间动画将其绘制在其原来的右边罢了。 本篇将首先从源码的角度对补间动画进行分析，属性动画会在下一篇中做介绍，至于补间动画的基本用法，这里就不多做介绍了。 在我们分析之前我们先提两个问题： 动画是如何进行绘制的？ 动画是怎么计算每一帧的画面的？即某一个时刻View的位置的？ 带着这两个问题，我们开始分析补间动画，这里首先从startAnimation开始分析，这是动画开始执行的方法。 1234567//frameworks\base\core\java\android\view\View.javapublic void startAnimation(Animation animation) &#123; animation.setStartTime(Animation.START_ON_FIRST_FRAME); setAnimation(animation); invalidateParentCaches(); invalidate(true);&#125; startAnimation中主要做了两件事，第一个就是通过setAnimation设置当前View的动画，然后通过invalidate重绘制View。 1234567891011121314 public void setAnimation(Animation animation) &#123; mCurrentAnimation = animation; if (animation != null) &#123; // If the screen is off assume the animation start time is now instead of // the next frame we draw. Keeping the START_ON_FIRST_FRAME start time // would cause the animation to start when the screen turns back on if (mAttachInfo != null &amp;&amp; !mAttachInfo.mScreenOn &amp;&amp; animation.getStartTime() == Animation.START_ON_FIRST_FRAME) &#123; animation.setStartTime(AnimationUtils.currentAnimationTimeMillis()); &#125; animation.reset(); &#125;&#125; setAnimation将animation保存在View的mCurrentAnimation以备使用。 接下来就是通过invalidate来重绘制View，这个我在专门的一篇中有所介绍，这里我简单说一下， invalidate实际上会从当前发起绘制的view开始向上寻找父View(ViewParent)，然后和其父View计算总的脏区域，父View再计算根据得到的脏区域计算和其父View的脏区域，这个操作一直到ViewRootImpl，即View层级树的顶部管理者，它会根据计算的脏区域触发Draw操作。也就是会走到performTraversals中，这个流程想必大家都清楚了。 View在绘制完自身的内容后，会通过dispatchDrawl来绘制其子View，动画也就是在此时进行绘制的， 123456789101112131415161718192021222324252627282930313233// frameworks/base/core/java/android/view/ViewGroup.java@Overrideprotected void dispatchDraw(Canvas canvas) &#123; final int count = mChildrenCount;//子view的个数 final View[] children = mChildren;//子view节点 int flags = mGroupFlags; …… boolean more = false; final long drawingTime = getDrawingTime(); if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime);//绘制子view &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; ……&#125; protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; dispatchDraw中会通过遍历孩子节点并未其调用drawChild来绘制子View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; …… Transformation transformToApply = null; final Animation a = getAnimation(); if (a != null) &#123; more = drawAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; &#125; transformToApply = parent.getChildTransformation(); &#125; …… if (transformToApply != null || alpha &lt; 1 || !hasIdentityMatrix() || (mPrivateFlags3&amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) &#123; if (transformToApply != null || !childHasIdentityMatrix) &#123; int transX = 0; int transY = 0; if (offsetForScroll) &#123; transX = -sx; transY = -sy; &#125; //动画的Transformation不为null if (transformToApply != null) &#123; if (concatMatrix) &#123; if (useDisplayListProperties) &#123; displayList.setAnimationMatrix(transformToApply.getMatrix()); &#125; else &#123; // Undo the scroll translation, apply the // transformation matrix, // then redo the scroll translate to get the correct // result. canvas.translate(-transX, -transY); canvas.concat(transformToApply.getMatrix()); canvas.translate(transX, transY); &#125; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; //获取Transformation的alpha值 float transformAlpha = transformToApply.getAlpha(); if (transformAlpha &lt; 1) &#123; alpha *= transformAlpha; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; &#125; if (!childHasIdentityMatrix &amp;&amp; !useDisplayListProperties) &#123; canvas.translate(-transX, -transY); canvas.concat(getMatrix()); canvas.translate(transX, transY); &#125; &#125; &#125; return more;&#125; View的这个draw方法同draw(Canvas)的那个方法不同，它只是被ViewGroupd的drawChild调用，在这个方法里，我们可以看到绘制动画的方法，首先通过getAnimation获取到我们在startAnimation中设置的动画，然后交给drawAnimation计算动画的Transformation，它被存放在transformToApply中，如果有动画执行那么transformToApply肯定不为null,这里concatMatrix未true表示动画会改变变换矩阵，比如ScaleAnimation会改变变换的Matrix，而AlpahAnimation不会改变，为true这种情况会对canvas做一些列变换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859///frameworks/base/core/java/android/view/View.javaprivate boolean drawAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) &#123; Transformation invalidationTransform; final int flags = parent.mGroupFlags; final boolean initialized = a.isInitialized(); if (!initialized) &#123; a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight()); a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop); if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler); onAnimationStart(); &#125; final Transformation t = parent.getChildTransformation(); boolean more = a.getTransformation(drawingTime, t, 1f); if (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != 1f) &#123; if (parent.mInvalidationTransformation == null) &#123; parent.mInvalidationTransformation = new Transformation(); &#125; invalidationTransform = parent.mInvalidationTransformation; a.getTransformation(drawingTime, invalidationTransform, 1f); &#125; else &#123; invalidationTransform = t; &#125; if (more) &#123; if (!a.willChangeBounds()) &#123; if ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) == ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123; parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED; &#125; else if ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) &#123; // The child need to draw an animation, potentially // offscreen, so // make sure we do not cancel invalidate requests parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION; parent.invalidate(mLeft, mTop, mRight, mBottom); &#125; &#125; else &#123; if (parent.mInvalidateRegion == null) &#123; parent.mInvalidateRegion = new RectF(); &#125; final RectF region = parent.mInvalidateRegion; a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region, invalidationTransform); // The child need to draw an animation, potentially offscreen, // so // make sure we do not cancel invalidate requests parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION; final int left = mLeft + (int) region.left; final int top = mTop + (int) region.top; parent.invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f)); &#125; &#125; return more;&#125; 这个方法是补间动画的核心处理方法，它首先对动画进行初始化initialize，接下来通过getTransformation计算动画的相关信息，并返回more,代表动画是否完成。如果是true表示还有动画需要执行，那么在最后会通过parent的invalidate重新发起绘制进行下一帧的绘制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 public boolean getTransformation(long currentTime, Transformation outTransformation, float scale) &#123; mScaleFactor = scale; return getTransformation(currentTime, outTransformation);&#125;public boolean getTransformation(long currentTime, Transformation outTransformation) &#123; if (mStartTime == -1) &#123; mStartTime = currentTime; &#125; final long startOffset = getStartOffset(); final long duration = mDuration; float normalizedTime; if (duration != 0) &#123; normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration; &#125; else &#123; // time is a step-change with a zero duration normalizedTime = currentTime &lt; mStartTime ? 0.0f : 1.0f; &#125; final boolean expired = normalizedTime &gt;= 1.0f; mMore = !expired; if (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f); if ((normalizedTime &gt;= 0.0f || mFillBefore) &amp;&amp; (normalizedTime &lt;= 1.0f || mFillAfter)) &#123; if (!mStarted) &#123; fireAnimationStart(); mStarted = true; if (USE_CLOSEGUARD) &#123; guard.open("cancel or detach or getTransformation"); &#125; &#125; if (mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f); if (mCycleFlip) &#123; normalizedTime = 1.0f - normalizedTime; &#125; final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime); applyTransformation(interpolatedTime, outTransformation); &#125; if (expired) &#123; if (mRepeatCount == mRepeated) &#123; if (!mEnded) &#123; mEnded = true; guard.close(); fireAnimationEnd(); &#125; &#125; else &#123; if (mRepeatCount &gt; 0) &#123; mRepeated++; &#125; if (mRepeatMode == REVERSE) &#123; mCycleFlip = !mCycleFlip; &#125; mStartTime = -1; mMore = true; fireAnimationRepeat(); &#125; &#125; if (!mMore &amp;&amp; mOneMoreTime) &#123; mOneMoreTime = false; return true; &#125; return mMore;&#125; getTransformation会根据当前时间和动画的持续时间执行时间流逝的进度，该进度随时间的流逝均匀的增加，如果该进度在0和1之间那么说明动画还在执行，如果动画此时还未开始会通过fireAnimationStart回调动画开始的回调，随后通过getInterpolation根据进度和插值器计算插值，插值和时间流逝的进度区别在于，插值可以根据数学模型生成任意的值，而时间流逝的进度值是客观不可变的。补间动画正是基于计算的插值来计算下一帧的动画的。计算完插值后通过applyTransformation来计算动画。我们可以看看TranslateAnimation是如何基于此计算动画的。 123456789101112@Overrideprotected void applyTransformation(float interpolatedTime, Transformation t) &#123; float dx = mFromXDelta; float dy = mFromYDelta; if (mFromXDelta != mToXDelta) &#123; dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime); &#125; if (mFromYDelta != mToYDelta) &#123; dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime); &#125; t.getMatrix().setTranslate(dx, dy);&#125; TranslateAnimation都是基于interpolatedTime计算动画偏移。如水平方向的偏移 dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime) 这里的interpolatedTime可以看作是插值器计算的动画进度，它从0f-1.0f。 完成这一步，就可以通过view的父view发起绘制动画的请求，这是通过parent.invalidate方法来发起的。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestLayout源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-requestLayout-src%2F</url>
    <content type="text"><![CDATA[invalidate是用来进行view的重绘的，它一般会导致onDraw的调用(对于ViewGroup容器来说它并不一定会调用onDraw)以使View改变自身内容，但是如果当view的大小尺寸发生了变化，此时就需要requestLayout对view进行布局请求。比如当view设置了布局参数后就需要进行布局请求。但需要注意的是requestLayout并不保证onDraw会调用，它只负责完成布局请求，调不调用onDraw取决于view的内容是否改变。所以一般情况下requestLayout和invalidate是结合着使用的。 123456public void setLayoutParams(ViewGroup.LayoutParams params) &#123; …… mLayoutParams = params; …… requestLayout();&#125; 1234567891011121314151617181920212223242526// /frameworks/base/core/java/android/view/View.javapublic void requestLayout() &#123; if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123; // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;//如果正在layout 发送请求layout if (!viewRoot.requestLayoutDuringLayout(this)) &#123; return; &#125; &#125; mAttachInfo.mViewRequestingLayout = this; &#125; //设置FLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED标记 mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123; mAttachInfo.mViewRequestingLayout = null; &#125;&#125; requestLayout是从View开始，它首先判断的当前viewRoot是否正在进行layout，如果是，则发送请求给ViewRoot，告诉它当前view需要进行layout。否则为view打上PFLAG_FORCE_LAYOUT和PFLAG_INVALIDATED标记，然后调用parent的requestLayout，这里parent即它的父view，可以是ViewGroup也可以是ViewRoot,其中ViewGroup没有覆盖requestLayout，那么依然是调用View的requestLayout。这实际上是一个递归调用为父view打上请求布局的标记。直到ViewRootImpl。 123456789///frameworks/base/core/java/android/view/ViewRootImpl.java @Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123;//如果layout请求没有在执行 checkThread(); mLayoutRequested = true;//设置layout请求标记 scheduleTraversals(); &#125;&#125; ViewRootImpl的requestLayout中设置mLayoutRequested为true,然后开启请求布局。 1234567891011121314151617181920212223242526272829303132333435363738394041private void performTraversals() &#123; …… boolean layoutRequested = mLayoutRequested &amp;&amp; !mStopped; …… if (!mStopped) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123; //获得view宽高的测量规格，lp.width和lp.height表示DecorView根布局宽和高 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//开始执行测量操作 …… &#125; &#125; final boolean didLayout = layoutRequested &amp;&amp; !mStopped;//layoutRequested 为true并且actitivy并非暂停则需要执行layout boolean triggerGlobalLayoutListener = didLayout || attachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, desiredWindowWidth, desiredWindowHeight); …… &#125; …… boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) &#123;//既没有取消绘制，也没有创建新的平面 if (!skipDraw || mReportNextDraw) &#123;// …… performDraw();//开始执行绘制操作 &#125; &#125; ……&#125; mLayoutRequested 在requestLayout中设置为true,mStopped表示当前view树所在的window状态不是停止的，一般为false，那么layoutRequested为true，didLayout为true。那么分别执行performMeasure和performLayout，下面我们分别分析。 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; ViewRootImpl的performMeasure执行view的measure方法进行测量。 1234567891011121314151617181920public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; …… if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;//清除meaure set 标记 用来检测是否调用了setMeasuredDimension …… mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; 由于mPrivateFlags在requestLayout中设置了PFLAG_FORCE_LAYOUT，所有清除PFLAG_MEASURED_DIMENSION_SET的标记，这个标记用于检测是否调用setMeasuredDimension，同时打上PFLAG_LAYOUT_REQUIRED标记，表示请求布局。 12345678910111213141516171819202122232425262728293031323334private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; ... mInLayout = true; final View host = mView; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; mHandlingLayoutInLayoutRequest = true;//表示正在进行layout请求操作 // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; …… &#125; &#125; &#125; ……&#125; performLayout负责执行viewlayout过程，同时对请求布局的view也执行requstLayout。这里host就是view树的根节点，即DecorView，它是个FrameLayout。所以我们看看ViewGroup的layout。 123456789101112@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; viewGroup调用view的layout 1234567891011121314151617181920public void layout(int l, int t, int r, int b) &#123; …… int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);//setFrame中可能会触发invalidate进行重绘置 if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;//如果布局发生了变化 则还需要对子视图进行重新布局 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; …… &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; 由于在measure过程中设置了PFLAG_LAYOUT_REQUIRED标记，那么就会调用onLayout来进行view的布局过程，这个过程完成后，清理PFLAG_LAYOUT_REQUIRED和PFLAG_FORCE_LAYOUT标记表示布局过程完成了。这里需要注意的是view在测量后大小可能发生变化，这时候通过setFrame设置其边框时会调用invalidate的调用，因此可能会导致onDraw的调用。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View invalidate的源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-invalidate-src%2F</url>
    <content type="text"><![CDATA[我们在自定义View时，通常使用invalidate方法来刷新View，本篇将对invalidate的实现进行分析。invalidate有多个重载方法， 但其最终的实现都是类似的，这里我们从invalidate()开始分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455frameworks/base/core/java/android/view/View.java/*** Invalidate the whole view. If the view is visible,* &#123;@link #onDraw(android.graphics.Canvas)&#125; will be called at some point in* the future. This must be called from a UI thread. To call from a non-UI thread,* call &#123;@link #postInvalidate()&#125;.*///使整个view无效，将会导致view的onDraw调用 即重绘view的过程public void invalidate() &#123; invalidate(true);//true表示刷新缓存也应该失效&#125;//true表示刷新缓存也应该失效，如果置位false表示view的内容或者大小没有发生变化void invalidate(boolean invalidateCache) &#123; if (skipInvalidate()) &#123;//是否应该跳出本次过程，跳过绘制的条件需满足：view不可见 且没有当前动画在执行 return; &#125; /* * 可以进行刷新的条件： * 1: 需要绘制且已经设置过边界 * 2：当前绘制缓存还是有效，但要使其失效 * 3：view将处于invalided状态 * 4: 透明度发生了变化 * */ if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || isOpaque() != mLastIsOpaque) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN;//重置绘制标记 mPrivateFlags |= PFLAG_DIRTY;//标记PFLAG_DIRTY 表示view当前已经失效 if (invalidateCache) &#123;//需要失效缓存 mPrivateFlags |= PFLAG_INVALIDATED;//标记失效 mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;//清除缓存有效的标记 &#125; final AttachInfo ai = mAttachInfo;//取到view的attch信息 final ViewParent p = mParent;//父view //noinspection PointlessBooleanExpression,ConstantConditions if (!HardwareRenderer.RENDER_DIRTY_REGIONS) &#123; if (p != null &amp;&amp; ai != null &amp;&amp; ai.mHardwareAccelerated) &#123;//开启了硬件加速 // fast-track for GL-enabled applications; just invalidate the whole hierarchy // with a null dirty rect, which tells the ViewAncestor to redraw everything p.invalidateChild(this, null);//开启硬件加速了就将view所有的区域标记为脏区域以使viewRoot重绘所有的内容 return; &#125; &#125; //未开启硬件加速 if (p != null &amp;&amp; ai != null) &#123; final Rect r = ai.mTmpInvalRect; r.set(0, 0, mRight - mLeft, mBottom - mTop);//将Rect设置为view的大小 // Don't call invalidate -- we don't want to internally scroll // our own bounds p.invalidateChild(this, r);//调用父view的invalidateChild方法 具体见ViewGroup &#125; &#125;&#125; invalidate的实现很简单，只需要满足一定的条件，就需要走绘制流程，这里需要注意两个标记一个是PFLAG_INVALIDATED，代表了View当前已经失效了， 另一个PFLAG_DRAWING_CACHE_VALID，表示View的绘制缓存有效。这里根据参数invalidateCache为true对其进行设置，对于硬件加速和非硬件加速的情况分别走 不同的流程，现在大多数其实是走硬件加速的流程，但这里我们还是看软件绘制的流程，关于硬件加速我们在别的篇章中介绍，在这里Mark~一下就好。 这里会设置一个Rect区域,这个区域实际上就是我们View的大小，也是待刷新的dirty区域，因为mRight-mLeft是View的宽度，mBottom-mTop就是View的高度，随后通过调用ViewParent的 invalidateChild方法，这里的ViewParent实际上就是当前view的父View或者view层级数的ViewRoot，所以invalidateChild是会走到ViewGroup或者ViewRootImpl 中去的。我们接着看哈~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;//child view是否在执行动画 Matrix childMatrix = child.getMatrix(); final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp; child.getAnimation() == null &amp;&amp; childMatrix.isIdentity();//发起请求的view是否是不透明的，执行动画的view则不认为它不透明 int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;//child view 的 dirty标记 …… //存放dirty region的起点坐标 final int[] location = attachInfo.mInvalidateChildLocation; location[CHILD_LEFT_INDEX] = child.mLeft; location[CHILD_TOP_INDEX] = child.mTop; …… do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; //得到的是父view的父view parent = parent.invalidateChildInParent(location, dirty); …… &#125; while (parent != null); &#125;&#125; invalidateChild接收两个参数，发起invalidate的child view即dirty区域，dirty区域的起始坐标点就是child view 在父view中的左上角坐标，随后进行do…while循环，在循环中我们忽略执行动画的情况，然后为当前父view设置dirty标记。 这个dirty标记为父view记录下子view的视图情况，后续在draw时会用到该标记判断是否需要绘制通过onDraw绘制view 随后调用invalidateChildInParent方法并返回当前父View的父View,一直到ViewRootImpl。可见这个循环其实是一个在View 层级数中从发起View的父View不断上溯到ViewRoot执行invalidateChildInParent的过程，那么在这之间，invalidateChildInParent 到底会做些什么事情呢？这里我们传递给invalidateChildInParent的是dirty区域的在当前父view的左上角的坐标和dirty区域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// /frameworks/base/core/java/android/view/ViewGroup.javapublic ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123; if ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123; if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) &#123; //计算dirty区域在当前父view中的偏移位置 dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY); if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == 0) &#123; dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; final int left = mLeft; final int top = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123; dirty.setEmpty(); &#125; &#125; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;//同时置ViewParent的PFLAG_DRAWING_CACHE_VALID标记为0 //更新location location[CHILD_LEFT_INDEX] = left; location[CHILD_TOP_INDEX] = top; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mLocalDirtyRect.union(dirty); &#125; return mParent; &#125; else &#123; mPrivateFlags &amp;= ~PFLAG_DRAWN &amp; ~PFLAG_DRAWING_CACHE_VALID; location[CHILD_LEFT_INDEX] = mLeft; location[CHILD_TOP_INDEX] = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; dirty.set(0, 0, mRight - mLeft, mBottom - mTop); &#125; else &#123; // in case the dirty rect extends outside the bounds of this container dirty.union(0, 0, mRight - mLeft, mBottom - mTop);//和当前VeiwGroup所属区域做并集 &#125; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED;//ViewGroup的标记置失效 mLocalDirtyRect.union(dirty); &#125; return mParent; &#125; &#125; return null;&#125; 在invalidateChildInParent中，首先通过offset计算dirty区域在当前父view中偏移位置，起始的dirty区域就是发起invalidate的子view 它再父view中的左上角位置就是(mLeft,mTop),随后计算dirty区域，首先判断FLAG_CLIP_CHILDREN是否设置，即我们在布局文件中 设置的android:clipChildren，默认是设置为true的，这个属性是用来限制子view是否在父view的绘制区域内的。设置为false即FLAG_CLIP_CHILDREN未设置的情况下 表示可以超出父view的绘制区域。这种情况下的话就设置dirty区域为当前父view的区域。否则FLAG_CLIP_CHILDREN设置就根据当前dirty区域和父view的区域做交集运算后 得到的dirty区域。如果没交集则dirty置空。然后更新location为当前父view在其父view中的左上角位置，为下一次计算脏区域在其父view中的偏移做准备。这样经过一层层的 计算后最终回溯到ViewRootImpl中的invalidateChildInParent中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// /frameworks/base/core/java/android/view/ViewRootImpl.java@Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (dirty == null) &#123;//脏区域为null说明要重新绘制整个view树 invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;//没有动画在执行且没有脏区域就不用绘制了 return null; &#125; if (mCurScrollY != 0 || mTranslator != null) &#123; mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) &#123; dirty.offset(0, -mCurScrollY); &#125; if (mTranslator != null) &#123; mTranslator.translateRectInAppWindowToScreen(dirty); &#125; if (mAttachInfo.mScalingRequired) &#123; dirty.inset(-1, -1); &#125; &#125; final Rect localDirty = mDirty; if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123; mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; &#125; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) &#123; localDirty.setEmpty(); &#125; /*ViewRootImpl同样是ViewParent，它和ViewGroup的invalideChildInParent的区别在于 * ViewRootImpl在统计完dirty region后会进行schedualTraversals进行绘制流程*/ if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125; return null;&#125; checkThread会检查更新的线程是否是ui线程，如果dirty区域为null说明需要绘制整个view树，如果dirty区域为空或者未执行动画也不需要 再进行下去了。如果mCurScrollY不为空说明页面有滚动过，需要据此重新计算dirty区域。随后将dirty区域添加到localDrity中即当前view树 中的dirty区域中去。接着讲当前dirty区域和整个页面区域做交集计算，intersected一般为true也就是有交集，最后通过scheduleTraversals 进行重绘的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// /frameworks/base/core/java/android/view/ViewRootImpl.java private void performDraw() &#123; boolean fullRedrawNeeded = mFullRedrawNeeded; mFullRedrawNeeded = false; …… try &#123; draw(fullRedrawNeeded, updateTranformHint); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; …… &#125; private void draw(boolean fullRedrawNeeded, boolean updateTranformHint) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123;//surface无效的话就返回 return; &#125; …… final Rect dirty = mDirty; //如果是绘制整个页面 就设置dirty为整个屏幕的大小 if (fullRedrawNeeded) &#123; attachInfo.mIgnoreDirtyState = true; dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); &#125; …… //重绘区域不为空 或者正在执行动画 if (!dirty.isEmpty() || mIsAnimating) &#123; //开启了硬件加速 if (attachInfo.mHardwareRenderer != null &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123; …… &#125;else&#123; …… //软件绘制 dirty描述绘制区域 if (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; &#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; Canvas canvas; try &#123; int left = dirty.left; int top = dirty.top; int right = dirty.right; int bottom = dirty.bottom; …… //根据重绘区域获取一个Canvas canvas = mSurface.lockCanvas(dirty); &#125;catch(...)&#123; …… &#125; try&#123; mView.draw(canvas);//view的绘制 &#125;finally&#123; …… surface.unlockCanvasAndPost(canvas); …… &#125; return true;&#125; scheduleTraversals通过performDraw来绘制view，这里实际上是调用draw(boolean fullRedrawNeeded, boolean updateTranformHint)方法， 对应非硬件加速的情况，这个方法内部调用drawSoftware来进行绘制，注意这里的dirty实际上就是当前view树计算后得到的脏区域。当然也包括了我们之前 调用view的invalidate后计算的脏区域。通过这个脏区域通过在mSurface中设置一个裁剪区域并返回一个Canvas，随后的绘制就在此Canvas的裁剪区域中进行绘制。 View的draw绘制过程主要包括以下方面： Draw the background If necessary, save the canvas’ layers to prepare for fading Draw view’s content Draw children If necessary, draw the fading edges and restore layers Draw decorations (scrollbars for instance) 1234567891011121314public void draw(Canvas canvas) &#123; …… final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); //子view是否不透明且未执行动画 …… background.draw(canvas); if (!dirtyOpaque) onDraw(canvas);//子视图不透明 会覆盖掉当前视图 所以skip dispatchDraw(canvas); onDrawScrollBars(canvas); ……&#125; 在draw流程中是否回调onDraw是由dirtyOpaque决定的，而dirtyOpaque是根据标记PFLAG_DIRTY_OPAQUE是否设置来决定的， 还记得在上面invalidateChild时会为父view设置这个标记？这个标记表明子view是不透明的且没有在执行动画，那么此时 就没必要对view进行绘制了，因为子view是在父view之上的，会覆盖掉当前view的视图，所有就没有必要绘制了。 需要注意的是，ViewGroup作为一个容器控件，默认情况下是没有任何东西可画的，它是一个透明控件。 draw过程中的dispatchDraw用来绘制子view，我们看下ViewGroup中实现 12345678910111213141516171819202122232425262728// /frameworks/base/core/java/android/view/ViewGroup.java @Overrideprotected void dispatchDraw(Canvas canvas) &#123;//绘制子视图 final int count = mChildrenCount; final View[] children = mChildren; …… if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;//子视图可见或者设置了动画 more |= drawChild(canvas, child, drawingTime);//绘制子视图 &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; ……&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; drawChild会调用view的另一个重载方法，它有三个参数。 123456789101112131415161718192021222324252627282930313233343536// /frameworks/base/core/java/android/view/View.javaboolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; …… mPrivateFlags |= PFLAG_DRAWN; /*quickReject判断当前View的区域是否落在Canvas的裁剪区域之外，如果是返回true，表示跳过当前view的绘制*/ if (!concatMatrix &amp;&amp; (flags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp; canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == 0) &#123; /* 1. view没有关联的matrix矩阵 * 2. view的绘制区域落在Canvas裁剪区域之外 * 3. clipchild设置为true * 4. 没有执行动画 * **/ mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED; return more; &#125; …… if (!layerRendered) &#123; if (!hasDisplayList) &#123; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas);//绘制子视图 &#125; else &#123; draw(canvas);//绘制本身及子视图 &#125; &#125; else &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags); &#125; &#125; ……&#125; 从draw方法中可以看出，子view的并不是每次进行绘制流程时候都需要绘制一遍，尤其是当view通过invalidate触发绘制时， 因此此时Canvas根据dirty区域设置了裁剪区域，而ViewGroup在绘制子view时会判断其区域是否落在这个裁剪区域内，如果 不在就没有必要进行绘制了，直接返回。这是通过canvas的quickReject进行判断的.随后就是字view的绘制，这里面会判断是否 设置了PFLAG_SKIP_DRAW，这个标记用来控制是否需要对View进行绘制，对ViewGroup来说默认是设置了的，所以它直接通过 dispatchDraw来绘制子view，并不会对自身进行绘制，onDraw也不会进行调用。如果想要使它绘制可以通过setWillNotDraw(false) 来清除PFLAG_SKIP_DRAW标记。这样会进入view(ViewGroup)的draw流程，但具体能不能调用onDraw还要做以下判断 final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); //子view是否不透明且未执行动画 1234567891011121314151617181920212223public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);&#125;void setFlags(int flags, int mask) &#123; …… if ((changed &amp; DRAW_MASK) != 0) &#123; if ((mViewFlags &amp; WILL_NOT_DRAW) != 0) &#123; if (mBackground != null) &#123; mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW; mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND; &#125; else &#123; mPrivateFlags |= PFLAG_SKIP_DRAW; &#125; &#125; else &#123; mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW; &#125; requestLayout(); invalidate(true);//通过invalidate刷新 &#125; ……&#125; 到这里invalidate的流程就分析完了，需要注意的是，invalidate会触发绘制流程，但是并不会触发onMeasure和onLayout。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Surface绘图缓冲区的创建流程]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surface-buffer-src%2F</url>
    <content type="text"><![CDATA[Android View绘制是GUI系统的核心，而绘制view是需要缓冲区的，也就是我们说的画布，因此了解这个缓冲区的分配流程是有必要的，本篇将对该缓冲区的分配进行解释。 Activity结构剖析 Acitivty实际上在WMS端只是个Window，是以WindowState进行描述的，在AMS端它是一个ActivityRecord，在Activity内部它持有一个mWindow，它实际上为一个PhoneWindow实例，在PhoneWindow中维护了一个DecorView，也就是view树，这个PhoneWindow实例由一个WindowManagerImpl进行管理，在WindowManagaerImpl内部持有一个WindowManagerGlobal单例，它内部持有WMS的本地代理IWindowManager和由其打开的一个IWindowSession负责和WMS进行会话，另一方面它负责整个应用的窗口视图的管理，也就是DecorView及ViewRootImpl的管理。每个新添加的window最终会在WMS端以WidowState的形式存在于WMS，WMS不关心window的View树的内容，它只关心Window的大小样式以及Z序等，而绘制的流程是由我们应用程序进行的，实际上就是由ViewRootImp进行绘制的。那么相应的ViewRootImpl在进行绘制前是需要一个画布进行view树的绘制的，这个画布就是Surface。接下来我们将围绕这个Surface进行话题的展开。 画布的分配 在ViewRootImpl创建时同时会new一个Surface对象 1private final Surface mSurface = new Surface(); 接下来我们看下这个Surface的内部会做些什么。 1234567891011public class Surface implements Parcelable &#123; ^ int mNativeObject; // package scope only for SurfaceControl access private int mLockedObject; private int mGenerationId; // incremented each time mNativeObject changes private final Canvas mCanvas = new CompatibleCanvas(); …… public Surface() &#123; &#125; ……&#125; 可以看到Surface的构造方法只是个空实现，而貌似mCanvas可能会是真正的画布，我们继续看看Canvas的代码 12345678910111213141516171819public class Canvas &#123; /** @hide */ public int mNativeCanvas; // may be null private Bitmap mBitmap; // optional field set by the caller private DrawFilter mDrawFilter; …… public Canvas() &#123; if (!isHardwareAccelerated()) &#123; // 0 means no native bitmap mNativeCanvas = initRaster(0); mFinalizer = new CanvasFinalizer(mNativeCanvas); &#125; else &#123; mFinalizer = null; &#125; &#125; ……&#125; 在Canava的构造方法中也并没有相关缓冲区分配的动作，这么说new出来的Surface并非真的分派了缓冲区，而只是一个空壳。想想也就能理解，我们知道ViewRootImpl分派的时机是WindowManagerGlobal通过addView来添加view树的时候分配的时候，这时候WMS还不知道这个Window的存在的(最起码得知道分配多大吧)，那么给view树分配缓冲区的确为时过早。那么什么时候分配合适呢？当然是准备绘制view树的时候。view树的绘制是在performTraversal中进行的。 1234567891011121314151617181920212223private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView;//viewRoot管理的view树 decorView …… boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp; frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp; frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight)); …… if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mConfigurationChanged) &#123; relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); …… &#125; …… performMeasure(); …… performLayout(); …… performDraw();&#125; performTraversals函数比较长，我这里只取跟本篇相关的内容，在performTraversals并非仅仅只有三大绘制流程performMeasure,performLayout和performDraw,实际上在这三个流程之前还是做了很多事情的，我简单的说下： 计算期望的窗口大小，如果Window带状态栏，那么在其大小中应该除去状态栏的那部分宽高。否则大小应该为整个屏幕的大小 如果窗口大小发生了变化也需要记录下来 计算窗口的内容区域边衬是否变化 如果可见性发生了变化也需要记录，同时通知view树子视图可见性发生了变化 根据条件判断是否需要relayoutWindow，在relayoutWindow中会重新计算窗口大小。需要满足的条件至少为以下一种： &lt;1&gt;. Activity窗口是第一次执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true。 &lt;2&gt;. 前面得到的变量windowShouldResize的值等于true，即Activity窗口的大小的确是发生了变化。 &lt;3&gt;. 前面得到的变量insetsChanged的值等于true，即Activity窗口的内容区域边衬发生了变化。 &lt;4&gt;. Activity窗口的可见性发生了变化，即变量viewVisibilityChanged的值等于true。 &lt;5&gt;. Activity窗口的属性发生了变化，即变量params指向了一个WindowManager.LayoutParams对象 6.执行绘制流程，这个在另外的篇幅再做介绍 在relayoutWindow中会计算窗口的大小，同时这里会为窗口分配缓冲区。 123456789101112131415private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; …… int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingConfiguration, mSurface); …… return relayoutResult;&#125; 通过mWindowSession和WMS进行会话调用relayout计算窗口的大小并将mSurface传递给WMS。IWindowSession的服务端为Session，我们看看它的实现 12345678910public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outConfig, outSurface);//调用WMS的relayoutWindow return res;&#125; Session的relayout会通过WMS的relayoutWindow来完成。 1234567891011121314151617181920212223242526272829303132public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Configuration outConfig, Surface outSurface) &#123; synchronized(mWindowMap) &#123; WindowState win = windowForClientLocked(session, client, false); if (win == null) &#123; return 0; &#125; WindowStateAnimator winAnimator = win.mWinAnimator; …… try &#123; if (!win.mHasSurface) &#123; surfaceChanged = true; &#125; //创建SurfaceControl 准备画布 SurfaceControl surfaceControl = winAnimator.createSurfaceLocked(); if (surfaceControl != null) &#123; outSurface.copyFrom(surfaceControl); &#125; else &#123; // For some reason there isn't a surface. Clear the // caller's object so they see the same state. outSurface.release(); &#125; &#125; …… &#125;&#125; relayoutWindow的参树client为ViewRootImpl传递的W对象，是一个Binder对象，WMS通过client来通知应用窗口的变化。最后一个参数从命名上来看，它是一个出参，也就是通过这个方法可以拿到真正可用的Surface。可以看到outSurface是由copyFrom从SurfaceControl得来的。这个surfaceControl是通过winAnimator.createSurfaceLocked()来创建的。这个winAnimator是一个WindowStateAnimator，在我们为Window创建WindowState时创建的，它和WindowState是一一对应的。 123456789101112frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.javaSurfaceControl createSurfaceLocked() &#123; if (mSurfaceControl == null) &#123; …… mSurfaceControl = new SurfaceControl( mSession.mSurfaceSession, attrs.getTitle().toString(), w, h, format, flags); …… &#125; return mSurfaceControl;&#125; mSurfaceControl在WindowStateAnimator中只会创建一次，这里的mSession实际上就是应用端和WMS进行会话的session，即IWindowSession，在创建时会指定缓冲区大小，格式以及标记。那么mSurfaceSession是什么呢，在哪里创建的呢？我们继续看 12345678910111213141516171819frameworks/base/services/java/com/android/server/wm/WindowManagerService.java //为客户端创建一个Session会话，后面客户端使用这个Session同WMS进行会话 @Overridepublic IWindowSession openSession(IInputMethodClient client, IInputContext inputContext) &#123; Session session = new Session(this, client, inputContext); return session;&#125;public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; …… win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); …… win.attach() ……&#125; 1234567frameworks/base/services/java/com/android/server/wm/WindowState.javavoid attach() &#123; if (WindowManagerService.localLOGV) Slog.v( TAG, "Attaching " + this + " token=" + mToken + ", list=" + mToken.windows); mSession.windowAddedLocked();&#125; 12345678frameworks/base/services/java/com/android/server/wm/Session.javavoid windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; mSurfaceSession = new SurfaceSession(); mService.mSessions.add(this); &#125; mNumWindow++;&#125; 在WMS为应用打开一个会话session后并没有立马去创建mSurfaceSession，而是在Window添加到WMS的时候创建完WindowState后通过attach方法创建的。它同样的对于一个Session只会创建一个，也就是说我们的应用程序只会有一个SurfaceSession，因为它是Session的成员嘛。 123456789101112131415public final class SurfaceSession &#123; // Note: This field is accessed by native code. private int mNativeClient; // SurfaceComposerClient* private static native int nativeCreate(); private static native void nativeDestroy(int ptr); private static native void nativeKill(int ptr); /** Create a new connection with the surface flinger. */ public SurfaceSession() &#123; mNativeClient = nativeCreate(); &#125; ……&#125; SurfaceSession的实现很简单，因为它的工作都放在native层完成了。 123456frameworks/base/core/jni/android_view_SurfaceSession.cppstatic jint nativeCreate(JNIEnv* env, jclass clazz) &#123; SurfaceComposerClient* client = new SurfaceComposerClient();//SurfaceComposerClient是处于客户端的 client-&gt;incStrong((void*)nativeCreate); return reinterpret_cast&lt;jint&gt;(client);&#125; 实际上它是创建了一个SurfaceComposerClient对象并放在mNativeClient中。这个对象是用来和SurfaceFlinger打交道的，但它并不是SurfaceFlinger的本地代理。SurfaceFlinger负责界面图层的合成，这之间会涉及我们的缓冲区，所以分配缓冲区的工作需要经过SurfaceFlinger来进行。 弄清楚SurfaceSession是什么后，接下来我们看SurfaceControl的创建，它会用到SurfaceSession。 123456789public class SurfaceControl &#123; int mNativeObject; public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException &#123; mName = name; mNativeObject = nativeCreate(session, name, w, h, format, flags);//通过native层创建SurfaceControl &#125;&#125; 同样的，它的工作也是在native层进行的。 1234567891011121314frameworks/base/core/jni/android_view_SurfaceControl.cppstatic jint nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags) &#123; ScopedUtfChars name(env, nameStr); sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj)); sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface( String8(name.c_str()), w, h, format, flags);//创建SurfaceHolder if (surface == NULL) &#123; jniThrowException(env, OutOfResourcesException, NULL); return 0; &#125; surface-&gt;incStrong((void *)nativeCreate); return int(surface.get());//这里返回创建的SurfaceControl&#125; 123456frameworks/base/core/jni/android_view_SurfaceSession.cppsp&lt;SurfaceComposerClient&gt; android_view_SurfaceSession_getClient( JNIEnv* env, jobject surfaceSessionObj) &#123; return reinterpret_cast&lt;SurfaceComposerClient*&gt;( env-&gt;GetIntField(surfaceSessionObj, gSurfaceSessionClassInfo.mNativeClient));&#125; 在nativeCreate中首先通过android_view_SurfaceSession_getClient从SurfaceSession中取到之前创建的SurfaceComoserClient对象，然后通过该对象调用的CreateSurface创建SurfaceControl。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/frameworks/native/libs/gui/SurfaceComposerClient.cppvoid SurfaceComposerClient::onFirstRef() &#123; sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService()); if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();//与surfaceflinger建立连接 if (conn != 0) &#123; mClient = conn;//mClient对应服务端Client mStatus = NO_ERROR; &#125; &#125;&#125;sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123; ComposerService&amp; instance = ComposerService::getInstance();//实例采用单例 Mutex::Autolock _l(instance.mLock); if (instance.mComposerService == NULL) &#123; ComposerService::getInstance().connectLocked(); assert(instance.mComposerService != NULL); ALOGD("ComposerService reconnected"); &#125; return instance.mComposerService;&#125;void ComposerService::connectLocked() &#123; const String16 name("SurfaceFlinger"); while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;//获取surfaceflinger服务 usleep(250000); &#125; ……&#125;sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags)&#123; sp&lt;SurfaceControl&gt; sur; if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp);//在Client服务端创建相应的Layer ALOGE_IF(err, "SurfaceComposerClient::createSurface error %s", strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp);//同时创建一个SurfaceControl，这个gbp即是对应Layer的BufferQueue &#125; &#125; return sur;&#125; SurfaceComposerClient在创建完后，强引用的会首先会执行onFirstRef 在这个方法里会通过 ComposerService::getComposerService获取到SurfaceFlinger的Binder本地代理sm，这是在ComposerService::connectLocked中通过getService获取的，SurfaceFlinger是实名Binder，因此可以通过ServiceManager查询得到。获取到SurfaceFlinger的本地代理后，就可以通过createConnection创建ISurfaceComposerClient，它是一个匿名Binder,是SurfaceFlinger服务中Client 的本地代理。Client也是个Binder Server,SurfaceFlinger为每个于其建立连接的应用进程维护一个Client便于管理。 123456789101112131415161718192021222324252627282930313233343536373839404142frameworks/native/services/surfaceflinger/Client.cpp//应用程序创建Surfacestatus_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; //message最终通过这个handler进行处理 virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp);//创建过程由sf的createLayer完成，客户端创建一个Surface，对应的在sf中创建一个Layer return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg);//通过消息队列的方式来处理请求，主要是因为sf是为多个应用服务的，用这样的方式便于处理多个请求。 return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();&#125; 在Client中createSurfac会通过请求参数构造一个MessageBase然后post到SurfaceFlinger的MessageQueue，最终事件会通过MessageBase的handleMessage进行处理，在handleMessage中调用了虚方法handler进行消息的处理。也就是MessageCreateLayer的handler进行处理。 1234void MessageBase::handleMessage(const Message&amp;) &#123; this-&gt;handler();//调用handler方法 barrier.open();&#125;; 在MessageCreateLayer的handler中又会通过SurfaceFlinger的createLayout为客户端创建一个Layer，这个Layer即图层，它对应于应用端的Window。 12345678910111213141516171819202122232425262728293031status_t SurfaceFlinger::createLayer( const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)//为客户端创建Layer&#123; …… sp&lt;Layer&gt; layer; switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;//支持两种类型的Layer Normal和Dim case ISurfaceComposerClient::eFXSurfaceNormal: result = createNormalLayer(client, name, w, h, flags, format, handle, gbp, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceDim: result = createDimLayer(client, name, w, h, flags, handle, gbp, &amp;layer); break; default: result = BAD_VALUE; break; &#125; if (result == NO_ERROR) &#123; addClientLayer(client, *handle, *gbp, layer);//将创建的Layer添加到用户的队列中 setTransactionFlags(eTransactionNeeded); &#125; return result;&#125; 在SurfaceFlinger的createLayer中会根据flag来创建不同的layer，分别为Normal和Dim类型的，创建完layer后会将其添加到client中去。这里我们看下CreateNormalLayer的实现即可。 1234567891011121314151617181920212223242526272829303132status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)//创建Normal类型的Layer&#123; // initialize the surfaces switch (format) &#123; case PIXEL_FORMAT_TRANSPARENT: case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break; case PIXEL_FORMAT_OPAQUE: #ifdef NO_RGBX_8888 format = PIXEL_FORMAT_RGB_565; #else format = PIXEL_FORMAT_RGBX_8888; #endif break; &#125;#ifdef NO_RGBX_8888 if (format == PIXEL_FORMAT_RGBX_8888) format = PIXEL_FORMAT_RGBA_8888;#endif *outLayer = new Layer(this, client, name, w, h, flags);//创建Layouer 在第一次引用该Layer时会创建其BufferQueue和Consumer status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);//设置layer大小和格式 if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getBufferQueue();//获取Layer对应的BufferQueue &#125; return err;&#125; 创建Layer的实例后就可以通过getBufferQueue获取到layer内部的BufferQueue，这个BufferQueue是个Binder Server,它是一个缓冲队列，用来维护layer的缓冲区。它是在Layer的onFirstRef中创建的，我们缓冲区的分配在SurfaceFligner端实际实际上就是通过它来分配的。同时，它既是缓冲区的消费者又是生产者，对于应用端来说，它扮演生产者的角色，因为应用端是填充数据的一方，而对于surfaceFligner来说它又扮演消费者的角色，因为SurfaceFlinger是合成layer层，取出缓冲区进行显示的。 123456789101112void Layer::onFirstRef() &#123;//在第一次引用时创建一个bufferqueue // Creates a custom BufferQueue for SurfaceFlingerConsumer to use mBufferQueue = new SurfaceTextureLayer(mFlinger);//创建一个BufferQueue用于管理Layer的图形缓冲区 …… &#125;class SurfaceTextureLayer : public BufferQueue &#123;//父类是BufferQueue sp&lt;SurfaceFlinger&gt; flinger;public: SurfaceTextureLayer(const sp&lt;SurfaceFlinger&gt;&amp; flinger); virtual ~SurfaceTextureLayer();&#125;; 这里的SurfaceTextureLayer它实际上就是个BufferQueue。 1234567891011121314151617181920sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags)&#123; sp&lt;SurfaceControl&gt; sur; if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp);//在Client服务端创建相应的Layer ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error %s&quot;, strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp);//同时创建一个SurfaceControl，这个gbp即是对应Layer的BufferQueue &#125; &#125; return sur;&#125; 我们创建好layer后通过getBufferQueue后是以IGraphicBufferProducer的角色返回的，它代表了这个BufferQueue将作为一个生产者供应用端使用。紧接着在本地创建一个SurfaceControl 需要注意这个时候gbd是在我们的应用进程中了，它是BufferQueue的本地代理binder对象了。 我们通过这个代理对象来创建SurfaceControl。 1234567SurfaceControl::SurfaceControl( const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbp) : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)&#123;&#125; 这里我们创建好本地的SurfaceControl，然后保存在java层的SurfaceControl的mNativeObject中。但是这个时候好像并没有真正去分配缓冲区，那么创建这个SurfaceControl给上层到底是干嘛用的？没错，就是用来分配缓冲区的，因为它内部这时候是有一个IGraphicBufferProducer的，它是layer中的BufferQueue代理binder。 在WMS的relayoutWindow中创建完SurfaceControl后，会通过Surface的copyFrom来初始化它，在这之前Surface还是个空壳。 1234567891011121314151617181920212223public class Surface implements Parcelable &#123; …… public void copyFrom(SurfaceControl other) &#123; if (other == null) &#123; throw new IllegalArgumentException("other must not be null"); &#125; int surfaceControlPtr = other.mNativeObject;//取到指向SurfaceControl的本地对象指针 if (surfaceControlPtr == 0) &#123; throw new NullPointerException( "SurfaceControl native object is null. Are you using a released SurfaceControl?"); &#125; int newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);//通过SurfaceControl来创建新的Surface synchronized (mLock) &#123; if (mNativeObject != 0) &#123; nativeRelease(mNativeObject); &#125; setNativeObjectLocked(newNativeObject); &#125; &#125; ……&#125; java层的Surface是通过nativeCreateFromSurfaceControl，并将native层的SurfaceControl对象指针传递给它。 123456789static jint nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jint surfaceControlNativeObj) &#123; sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)); sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());//返回surfacecontrol管理的surface if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner); &#125; return reinterpret_cast&lt;jint&gt;(surface.get());&#125; 通过native层的SurfaceControl指针，可以通过getSurface获取到一个Surface。 12345678910sp&lt;Surface&gt; SurfaceControl::getSurface() const//获取内部持有的Surface&#123; Mutex::Autolock _l(mLock); if (mSurfaceData == 0) &#123;//第一次为空时创建 // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false);//这个surface是sf中消费的。 &#125; return mSurfaceData;&#125; 123456789101112private void setNativeObjectLocked(int ptr) &#123; if (mNativeObject != ptr) &#123; if (mNativeObject == 0 &amp;&amp; ptr != 0) &#123; mCloseGuard.open("release"); &#125; else if (mNativeObject != 0 &amp;&amp; ptr == 0) &#123; mCloseGuard.close(); &#125; mNativeObject = ptr; mGenerationId += 1; &#125;&#125; SurfaceControl 并不直接去分配缓冲区，而是通过管理一个本地Surface对象来管理缓冲区，它通过mGraphicBufferProducer构造，这个就是之前我们取到的IGraphicBufferProducer binder代理对象，构造的本地Surface最终会通过setNativeObjectLocked 保存在java层Surface的mNativeObject中。到这里java层的Surface就算创建完了，最终返回给ViewRootImpl使用。 Surface的使用 从Surface中取缓冲区 123456789101112131415private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; Canvas canvas; …… canvas = mSurface.lockCanvas(dirty); try &#123; …… mView.draw(canvas); &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; &#125; return true;&#125; Surface首先通过lockCanvas获取到一个Canvas对象，这个Canvas实际上为就是通过Surface的缓冲区填充的画布。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123; synchronized (mLock) &#123; …… mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas; &#125;&#125;//jni层的surface lockCanvas调用static jint nativeLockCanvas(JNIEnv* env, jclass clazz, jint nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123; sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));//这个surface由surfaceControl创建的 if (!isSurfaceValid(surface)) &#123; doThrowIAE(env); return 0; &#125; Rect dirtyRect; Rect* dirtyRectPtr = NULL; if (dirtyRectObj) &#123; dirtyRect.left = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left); dirtyRect.top = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top); dirtyRect.right = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right); dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom); dirtyRectPtr = &amp;dirtyRect; &#125; ANativeWindow_Buffer outBuffer;//ANativeWindow_Buffer定义在native_window.h中 status_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr); if (err &lt; 0) &#123; const char* const exception = (err == NO_MEMORY) ? OutOfResourcesException : "java/lang/IllegalArgumentException"; jniThrowException(env, exception, NULL); return 0; &#125; // Associate a SkCanvas object to this surface env-&gt;SetIntField(canvasObj, gCanvasClassInfo.mSurfaceFormat, outBuffer.format);//将skCanvas是关联到surface SkBitmap bitmap;//准备画布 ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format); bitmap.setConfig(convertPixelFormat(outBuffer.format), outBuffer.width, outBuffer.height, bpr);//设置画布大小及格式 if (outBuffer.format == PIXEL_FORMAT_RGBX_8888) &#123; bitmap.setAlphaType(kOpaque_SkAlphaType); &#125; if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123; bitmap.setPixels(outBuffer.bits);//给画布设置缓冲区 &#125; else &#123; // be safe with an empty bitmap. bitmap.setPixels(NULL); &#125; SkCanvas* nativeCanvas = SkNEW_ARGS(SkCanvas, (bitmap));//将画布作为native的Canvase返回给上层使用 swapCanvasPtr(env, canvasObj, nativeCanvas); if (dirtyRectPtr) &#123; nativeCanvas-&gt;clipRect( SkRect::Make(reinterpret_cast&lt;const SkIRect&amp;&gt;(dirtyRect)) ); &#125; if (dirtyRectObj) &#123; env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left, dirtyRect.left); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top, dirtyRect.top); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right, dirtyRect.right); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom); &#125; sp&lt;Surface&gt; lockedSurface(surface); lockedSurface-&gt;incStrong(&amp;sRefBaseOwner); return (int) lockedSurface.get();&#125; Surface的localCanvas是通过nativeLockCanvas,首先通过mNativeObject取到本地的Surface对象，通过这个本地的Surface进行lock取到缓冲区outBuffer，它是一个ANativeWindow_Buffer，随后通过这个缓冲区初始化一个SkBitmap画布，并设置其格式大小等，通过SkBitmap创建一个SkCanvas返回给java层Surface的mCanvas，我们在Draw方法中使用的Canvas就是这个SkCanvas. 1234567891011121314151617181920212223242526272829303132333435status_t Surface::lock( ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)&#123; …… ANativeWindowBuffer* out;// 定义在window.h int fenceFd = -1; status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);//分配缓冲区 ……&#125;//申请图形缓冲区int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123; ATRACE_CALL(); Mutex::Autolock lock(mMutex); int buf = -1; int reqW = mReqWidth ? mReqWidth : mUserWidth; int reqH = mReqHeight ? mReqHeight : mUserHeight; …… sp&lt;Fence&gt; fence; status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, mSwapIntervalZero, reqW, reqH, mReqFormat, mReqUsage); …… sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer); …… if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123;//未分配 或者需要重新映射 result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);//Surface通过调用 requestBuffer将图形缓冲区映射到Surface所在进程 if (result != NO_ERROR) &#123; ALOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result); return result; &#125; &#125; …… *buffer = gbuf.get();//获取缓冲区 return OK;&#125; 首先通过mGraphicBufferProducer通过dequeueBuffer分配缓冲区，实际是由BufferQueue完成的，它实际上是取到BufferQueue中BufferSlot槽的索引buf，有了这个索引，通过requestBuffer就真正的创建buffer并将该buffer映射到Surface所在进程。这样我们的应用程序就可以使用了。 提交绘制好的缓冲区 123456789public void unlockCanvasAndPost(Canvas canvas) &#123; …… synchronized (mLock) &#123; …… nativeUnlockCanvasAndPost(mLockedObject, canvas); nativeRelease(mLockedObject); mLockedObject = 0; &#125;&#125; 同样的应用层绘制完后，需要将该缓冲区unlock并且提交给BufferQueue。这个是通过nativeUnlockCanvasAndPost进行的。 1234567891011121314151617static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jint nativeObject, jobject canvasObj) &#123; sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); if (!isSurfaceValid(surface)) &#123; return; &#125; // detach the canvas from the surface SkCanvas* nativeCanvas = SkNEW(SkCanvas); swapCanvasPtr(env, canvasObj, nativeCanvas);//把canvas从surface分离 // unlock surface status_t err = surface-&gt;unlockAndPost();//提交结果 if (err &lt; 0) &#123; doThrowIAE(env); &#125;&#125; 123456789101112status_t Surface::unlockAndPost()//提交Locked的Buffer&#123; if (mLockedBuffer == 0) &#123; ALOGE("Surface::unlockAndPost failed, no locked buffer"); return INVALID_OPERATION; &#125; status_t err = mLockedBuffer-&gt;unlock(); err = queueBuffer(mLockedBuffer.get(), -1);//将该Buffer queue mPostedBuffer = mLockedBuffer;//locked的buffer变为posted …… return err;&#125; Surfae的unlockAndPost调用queueBuffer方法完成buffer的提交 123456int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;//buffer queue进行消费 …… status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);//通过调用GBP的 …… return err;&#125; 通过mGraphicBufferProducer入队这个buffer，此时生产者的任务完毕，layer端的Consumer即SurfaceFlinger会监听到这个有效的缓冲区，然后准备合成显示layer，最终将绘制的东西显示在屏幕上。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View绘制流程分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-performtraversal-src%2F</url>
    <content type="text"><![CDATA[View的绘制流程是Android GUI系统中的关键部分，因为最终view中绘制的内容是要呈现给用户的。本篇基于Android4.4(KitKat)将对view绘制流程做一个全面的分析。 绘制缓冲区 在View绘制流程中首先是需要一块缓冲区提供给应用程序进行内容绘制的， 这个缓冲区在上层以Surface的形式提供给使用者，这个Surface就是view绘制流程的绘图表面。在&lt;Surface绘图缓冲区的创建流程&gt; 一篇中我们介绍了Surface绘图缓冲区的绘制。所以关于这部分的内容不再做介绍。 绘制的时机 在&lt;Activity启动分析(二)&gt;一篇中，我们知道在handleResumeActivity通过addView添加view，将window加入到WMS后，会通过updateViewLayout更新视图 12345678910111213141516171819202122frameworks/base/core/java/android/view/WindowManagerGlobal.java //更新视图public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams);//设置view布局参数 synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index);//找到对应的viewroot mParams.remove(index);//移除之前的params mParams.add(index, wparams);//添加新的params root.setLayoutParams(wparams, false);//通过root设置参数 false代表view已经添加过 这里会对view树重新绘制 &#125;&#125; 123456void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) &#123; synchronized (this) &#123; …… scheduleTraversals();//设置完成后就准备绘制 &#125;&#125; 在root.setLayoutParams中会通过scheduleTraversals()绘制view。view树的绘制流程是在ViewRootImpl中完成的。 绘制流程 123456789101112131415161718192021222324252627282930313233void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); //请求同步信号，信号到来时会调用mTraversalRunnable执行doTravels scheduleConsumeBatchedInput(); &#125;&#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().removeSyncBarrier(mTraversalBarrier); …… try &#123; performTraversals();//真正的绘制流程是从这里开始的 &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; …… &#125;&#125; 绘制流程需要配合Vsync信号来进行，这个是通过Choreographer来进行的，在scheduleTraversals中通过mChoreographer请求同步信号， 信号到来时会调用mTraversalRunnable的doTraversal。在doTraversal中调用performTraversals来开始真正的绘制流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void performTraversals() &#123; …… relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); …… if (!mStopped) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123; //获得view宽高的测量规格，lp.width和lp.height表示DecorView根布局宽和高 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//开始执行测量操作 …… &#125; &#125; …… final boolean didLayout = layoutRequested &amp;&amp; !mStopped; boolean triggerGlobalLayoutListener = didLayout || attachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, desiredWindowWidth, desiredWindowHeight); …… &#125; …… boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) &#123;//既没有取消绘制，也没有创建新的平面 if (!skipDraw || mReportNextDraw) &#123;// if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw();//开始执行绘制操作 &#125; &#125; ……&#125; 在performTraversals中会做很多事情，这里我们主要绘制的主要流程，即measure,layout和draw的过程，在&lt;Surface绘图缓冲区的创建流程&gt;一篇中我们知道了在绘制之前是需要准备画布的，这个画布就是ViewRootImpl的mSurface，它会通过relayoutWindow创建。 measure过程 measure过程主要进行view树中所有的view的大小的测量，我们看到测量并不一定会在performTraversals中进行，而是需要满足一定的条件： Window的状态不能为stopped，即mStopped=false 窗口的触摸模式发生了变化，由此引发了Activity窗口当前获焦点的控件发生了变化，即变量focusChangedDueToTouchMode的值等于true。这个检查是通过调用ensureTouchModeLocally来实现的。 窗口前面测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight不等于WindowManagerService服务计算出来的宽度mWidth和高度mHeight。这里的host为DecorView 窗口的内容区域边衬大小和可见区域边衬大小发生了变化， 即contentInsetsChanged的值等于true 只有满足上述条件，measure流程才会进行，在执行measure前，首先会根据DecorView的宽高获取测量规格MesaureSpec，它的前两位为mode，有三种，分别为： UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大 EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。 AT_MOST：子容器可以是声明大小内的任意大小 这个测量规格会传递给子view,子view结合自身LayoutParams算出view的大小。子view测量完成后，通过setMeasureDimentions将测量结果保存。 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 在performMeasure之前会通过getRootMeasureSpec获取根view的MeasureSpec，它默认为屏幕的大小， 这里的mView是DecorView，它是一个FrameLayout，通过它我们来看看测量过程是如何进行的。 12345678910111213141516public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; …… int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimension((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ……&#125; measure方法是在view中定义的，这里需要注意measure是一个final方法，在内部它通过调用onMeasure来完成实际的测量工作。如果我们需要自定义view，就需要覆盖onMeasure在其中完成view大小的测量，我们看下默认的onMeasure实现： 1234567891011121314151617181920protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;//标记已经调用了setMeasuredDimension&#125; onMeasure默认通过setMeasuredDimension设置mMeasuredWidth和mMeasuredHeight的值。通过这个方法完成测量过程。默认值是通过getDefaultSize计算得到的,它的第一个参数是通过getSuggestedMinimumxx获取到的，用来获取建议的最小宽高。 1234567891011121314151617181920protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 这个建议的最小高度值由layout:minHeight 和 BackGround的最小高度决定，最小宽度值也是类似。getDefaultSize会通过父view传递给view的MeasureSpec来计算最终宽高。对于MeasureSpec.AT_MOST和MeasureSpec.EXACTLY两种最常见的模式，最终的大小是由specSize,也就是MeasureSpec决定的。而不是由建议值。 layout过程 在测量完view大小后，通过layout来确定view的位置，layout流程需满足下面的条件： 1final boolean didLayout = layoutRequested &amp;&amp; !mStopped; 通过requestLayout发起过layout请求 Window的状态不为stopped 1234567private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; final View host = mView; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());&#125; 同样是从view根部开始，我们看看DecorView的layout实现 12345678910111213frameworks/base/core/java/android/view/ViewGroup.java@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 如果LayoutTransitiond动画未执行，那么直接调用View的layout，否则设置mLayoutCalledWhileSuppressed = true，等待动画完成后再进行requestyLayout。 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;//如果布局 发生了变化 则还需要对子视图进行重新布局 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; layout的布局是通过onLayout来实现的，在View中onLayout的实现是空的实现,因为view是通过其父view即viewGroup进行layout的 123protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; ViewGroup的onLayout,它是个抽象方法，所有ViewGroup的子类都需要实现此方法以完成其子view的布局。 12protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 我们通过以LinearLayout为例说明ViewGroup是如何进行子view的布局的。 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 根据不同的oriention来调用不同的布局方法，这里我们看看layoutVertical。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; // Space available for child int childSpace = width - paddingLeft - mPaddingRight; final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; draw过程 12345678910111213141516171819202122232425262728private void performTraversals() &#123; …… boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) &#123;//既没有取消绘制，也没有创建新的Surface if (!skipDraw || mReportNextDraw) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw();//开始执行绘制操作 &#125; &#125; else &#123; if (viewVisibility == View.VISIBLE) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; ……&#125; draw流程需要满足： 未取消绘制也没有创建新的Surface,dispatchOnPreDraw返回true或者View不可见则取消绘制 未跳过此次绘制，即skipDraw为false,或者mReportNextDraw为true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void performDraw() &#123; …… try &#123; draw(fullRedrawNeeded, updateTranformHint); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ……&#125;private void draw(boolean fullRedrawNeeded, boolean updateTranformHint) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123; return; &#125; …… //重绘区域不为空或者正在执行动画 if (!dirty.isEmpty() || mIsAnimating) &#123; //开启了硬件加速 if (attachInfo.mHardwareRenderer != null &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123; // Draw with hardware renderer. mIsAnimating = false; mHardwareYOffset = yoff; mResizeAlpha = resizeAlpha; mCurrentDirty.set(dirty); dirty.setEmpty(); // 硬件加速绘制 attachInfo.mHardwareRenderer.draw(mView, attachInfo, this, animating ? null : mCurrentDirty); &#125; else &#123; …… //软件绘制 if (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; ……&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; …… canvas = mSurface.lockCanvas(dirty); mView.draw(canvas); surface.unlockCanvasAndPost(canvas); ……&#125; performDraw中会调用draw方法来完成绘制，draw方法中会通过attachInfo.mHardwareRenderer来判断是否启用了硬件加速，关于硬件加速我们在后面的篇幅进行讨论，这里我们假设未开启硬件加速关注软件绘制，即drawSoftware这个方法，这个方法首先会通过mSurface来取得绘制得画布canvas，并以dirty作为裁剪区域进行view绘制，最后通过unlockCanvasAndPost提交绘制得结果。这里mView就是我们的DecorView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109frameworks/base/core/java/android/view/View.javapublic void draw(Canvas canvas) &#123; if (mClipBounds != null) &#123; canvas.clipRect(mClipBounds); &#125; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; final Drawable background = mBackground; if (background != null) &#123; …… if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125; &#125; &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we're done... return; &#125; …… // Step 2, save the canvas' layers …… saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers …… canvas.restoreToCount(saveCount); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125;&#125; 绘制流程的代码有点长，我做了稍微精简了下,从注释中我们可以看到绘制的具体流程分为6步： 绘制背景(Draw the background) 如果需要，为view的淡隐淡出效果保存layers(If necessary, save the canvas’ layers to prepare for fading) 绘制view的内容(Draw view’s content) 绘制子view(Draw children) 如果需要，绘制淡隐淡出效果并恢复保存的layers If necessary, draw the fading edges and restore layers 绘制装饰内容，比如滚动条等 Draw decorations (scrollbars for instance) draw的第一步是进行view背景的绘制，但并不是必须的，背景资源存放在mBackground中，scrollX和scrollY都为0说明该view不用滚动，可以直接绘制其背景，否则需要进行坐标转换。一般情况下view是不带fading效果的，这时候就不需要进行第2步和第5步，否则就需要进行2到6的所有步骤。绘制view的content是通过onDraw来实现的，即真正的内容是通过子类来进行绘制的。因为view的onDraw是个空实现。绘制好自身的内容后可能该view还有子view，这时候就需要通过dispatchDraw来通知子view进行绘制，记住我们绘制的流程是从decorView开始的，它是个ViewGroup，也是整个view树的根view。我们知道ViewGroup是所有父容器的父类，所以dispatchDraw放在其中实现最合适不过了。 1234567891011121314151617@Overrideprotected void dispatchDraw(Canvas canvas) &#123; final int count = mChildrenCount; final View[] children = mChildren; …… for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; ……&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 这里主要遍历父view的所有子view通过drawChild来进行绘制。在drawChild中又回到我们view的draw绘制流程，其中会通过onDraw来进行child view的内容的绘制。整个绘制流程就是这样的。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件化/热修复原理]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-plugin-res%2F</url>
    <content type="text"><![CDATA[前述 加载插件资源 独立式 获取插件的Resources对象 通过插件资源ID 1234567891011121314151617181920212223/** * 获取对应插件的Resource对象 * @param context 宿主apk的上下文 * @param pluginPath 插件apk的路径，带apk名 * @return */public static Resources getPluginResources(Context context, String pluginPath) &#123; try &#123; AssetManager assetManager = AssetManager.class.newInstance(); // 反射调用方法addAssetPath(String path) Method addAssetPath = assetManager.getClass().getMethod("addAssetPath", String.class); // 将插件Apk文件添加进AssetManager addAssetPath.invoke(assetManager, pluginPath); // 获取宿主apk的Resources对象 Resources superRes = context.getResources(); // 获取插件apk的Resources对象 Resources mResources = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration()); return mResources; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 123456789101112131415161718192021222324/*** 加载apk获得内部资源id* @param context 宿主上下文* @param pluginPath apk路径*/public static int getResId(Context context, String pluginPath, String apkPackageName, String resName) &#123; try &#123; //在应用安装目录下创建一个名为app_dex文件夹目录,如果已经存在则不创建 File optimizedDirectoryFile = context.getDir("dex", Context.MODE_PRIVATE); // 构建插件的DexClassLoader类加载器，参数： // 1、包含dex的apk文件或jar文件的路径， // 2、apk、jar解压缩生成dex存储的目录， // 3、本地library库目录，一般为null， // 4、父ClassLoader DexClassLoader dexClassLoader = new DexClassLoader(pluginPath, optimizedDirectoryFile.getPath(), null, ClassLoader.getSystemClassLoader()); //通过使用apk自己的类加载器，反射出R类中相应的内部类进而获取我们需要的资源id Class&lt;?&gt; clazz = dexClassLoader.loadClass(apkPackageName + ".R$drawable"); Field field = clazz.getDeclaredField(resName);//得到名为resName的这张图片字段 return field.getInt(R.id.class);//得到图片id &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0;&#125; 1234int resId = getResId(MainActivity.this.getApplication(), PATH, PLUGIN_PACKAGE_NAME, "ic_launcher"); Resources resources = getPluginResources(MainActivity.this.getApplication(), PATH); Drawable drawable = resources.getDrawable(resId); mIvTest.setImageDrawable(drawable); 共享式 创建一个新的 AssetManager 对象，并将宿主和插件的资源都能过addAssetPath方法塞入 通过新的AssetManager对象来创建出一个新的Resources对象 将新的Resources对象替换ContextImpl中的mResources变量、LoadedApk变量里的mResources变量 以及 至空mThem变量 12345678910111213141516171819202122232425262728293031323334353637383940414243private static void mergePluginResources(Application application, String apkName) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; // 创建一个新的 AssetManager 对象 AssetManager newAssetManagerObj = AssetManager.class.newInstance(); Method addAssetPath = AssetManager.class.getMethod("addAssetPath", String.class); // 塞入原来宿主的资源 addAssetPath.invoke(newAssetManagerObj, application.getBaseContext().getPackageResourcePath()); // 塞入插件的资源 File optDexFile = application.getBaseContext().getFileStreamPath(apkName); addAssetPath.invoke(newAssetManagerObj, optDexFile.getAbsolutePath()); // ---------------------------------------------- // 创建一个新的 Resources 对象 Resources newResourcesObj = new Resources(newAssetManagerObj, application.getBaseContext().getResources().getDisplayMetrics(), application.getBaseContext().getResources().getConfiguration()); // ---------------------------------------------- // 获取 ContextImpl 中的 Resources 类型的 mResources 变量，并替换它的值为新的 Resources 对象 Field resourcesField = application.getBaseContext().getClass().getDeclaredField("mResources"); resourcesField.setAccessible(true); resourcesField.set(application.getBaseContext(), newResourcesObj); // ---------------------------------------------- // 获取 ContextImpl 中的 LoadedApk 类型的 mPackageInfo 变量 Field packageInfoField = application.getBaseContext().getClass().getDeclaredField("mPackageInfo"); packageInfoField.setAccessible(true); Object packageInfoObj = packageInfoField.get(application.getBaseContext()); // 获取 mPackageInfo 变量对象中类的 Resources 类型的 mResources 变量，，并替换它的值为新的 Resources 对象 // 注意：这是最主要的需要替换的，如果不需要支持插件运行时更新，只留这一个就可以了 Field resourcesField2 = packageInfoObj.getClass().getDeclaredField("mResources"); resourcesField2.setAccessible(true); resourcesField2.set(packageInfoObj, newResourcesObj); // ---------------------------------------------- // 获取 ContextImpl 中的 Resources.Theme 类型的 mTheme 变量，并至空它 // 注意：清理mTheme对象，否则通过inflate方式加载资源会报错, 如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null Field themeField = application.getBaseContext().getClass().getDeclaredField("mTheme"); themeField.setAccessible(true); themeField.set(application.getBaseContext(), null);&#125; 共享式的插件资源会有ID冲突的问题，针对资源冲突的目前有两个方案： 合并资源后重新生成resources.arsc，主要是针对resouces.arsc进行修改 修改aapt命令，对appt进行扩展。 每个资源ID都是一个十六进制数，它由三部分构成 PackageId 是apk包的id，默认是0x7f，默认不可变 TypeId 资源类型Id，比如像layout、string、drawable、id等等，它们对应的是：0x7f04?0x7f06?0x7f02?0x7f0b 等等，它们是按顺序从1开始递增的 ItemValue 类型Id下的资源值，从0开始递增 通过修改aapt命令从而修改插件apk的PackageId解决资源ID的冲突问题。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android6.0 动态权限机制]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-permission-src%2F</url>
    <content type="text"><![CDATA[Android6.0以后引入了动态权限机制，一些系统权限的分配需要在app运行中进行分配，而不只是在AndroidManifest中指定。 本篇将针对动态权限的底层分配过程进行分析(基于Android-6.0.1)。 权限分配 我们先看一下请求分配权限的代码 1234567891011121314151617181920212223242526272829//frameworks/support/v4/java/android/support/v4/app/ActivityCompat.javapublic static void requestPermissions(final @NonNull Activity activity, final @NonNull String[] permissions, final int requestCode) &#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123;//对于Android M 以及以上的权限的分配 ActivityCompatApi23.requestPermissions(activity, permissions, requestCode); &#125; else if (activity instanceof OnRequestPermissionsResultCallback) &#123;//Android M以下的权限分配 Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; //请求分配的权限结果，如分配就是PERMISSION_GRANTED final int[] grantResults = new int[permissions.length]; PackageManager packageManager = activity.getPackageManager(); String packageName = activity.getPackageName(); final int permissionCount = permissions.length; //通过包管理的checkPermission来检验是否分配权限 for (int i = 0; i &lt; permissionCount; i++) &#123; grantResults[i] = packageManager.checkPermission( permissions[i], packageName); &#125; ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult( requestCode, permissions, grantResults); &#125; &#125;); &#125;&#125; requestPermissions对于Android M的前后版本都分别做了处理，Android M以上通过ActivityCompatApi23.requestPermissions进行权限的请求，而Android M以下通过PackageManager来检查Permission的分配情况。 12345678910111213141516171819202122232425262728//frameworks/support/v4/api23/android/support/v4/app/ActivityCompat23.javaclass ActivityCompatApi23 &#123; ... public static void requestPermissions(Activity activity, String[] permissions, int requestCode) &#123; if (activity instanceof RequestPermissionsRequestCodeValidator) &#123; ((RequestPermissionsRequestCodeValidator) activity) .validateRequestPermissionsRequestCode(requestCode); &#125; //通过Android M的Activity处理 activity.requestPermissions(permissions, requestCode); &#125; ...&#125;//frameworks/base/core/java/android/app/Activity.javapublic final void requestPermissions(@NonNull String[] permissions, int requestCode) &#123; if (mHasCurrentPermissionsRequest) &#123; Log.w(TAG, "Can reqeust only one set of permissions at a time"); // Dispatch the callback with empty arrays which means a cancellation. onRequestPermissionsResult(requestCode, new String[0], new int[0]); return; &#125; //通过请求的权限构造Intent，弹出请求的窗口 Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions); startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null); mHasCurrentPermissionsRequest = true;&#125; ActivityCompat23将请求权限的任务交给Activity来完成，在Activity中，通过请求的permission来构造一个Intent随后启动Activity来弹出请求的界面。Intent的构造是通过PackageManager的buildRequestPermissionsIntent方法构造的。 123456789public Intent buildRequestPermissionsIntent(@NonNull String[] permissions) &#123; if (ArrayUtils.isEmpty(permissions)) &#123; throw new NullPointerException("permission cannot be null or empty"); &#125; Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS); intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions); intent.setPackage(getPermissionControllerPackageName()); return intent;&#125; Intent的action是ACTION_REQUEST_PERMISSIONS，它是这么定义的 12public static final String ACTION_REQUEST_PERMISSIONS = "android.content.pm.action.REQUEST_PERMISSIONS"; 随后一个参数就是具体请求的permission数组和一个权限分派控制的相关的包名。所以activity的请求窗口是通过隐式启动的。 12345678910/packages/apps/PackageInstaller/AndroidManifest.xml&lt;activity android:name=".permission.ui.GrantPermissionsActivity" android:configChanges="orientation|keyboardHidden|screenSize" android:excludeFromRecents="true" android:theme="@style/GrantPermissions"&gt; &lt;intent-filter&gt; &lt;action android:name="android.content.pm.action.REQUEST_PERMISSIONS" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 从intent-fliter可以看到，这个GrantPermissionsActivity就是我们进行权限分配的弹出窗口。GrantPermissionsActivity它的布局文件定义在packages/apps/PackageInstaller/res/layout/grant_permissions.xml，从GrantPermissionsActivity的实现来看它就是一个长的像Dialog的activity，这里我们重点关注在该Activity中对权限的允许和拒绝的处理。 12345678910111213141516171819202122//packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/ui/GrantPermissionsDefaultViewHandler.javapublic void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.permission_allow_button://允许 if (mResultListener != null) &#123; view.clearAccessibilityFocus(); mResultListener.onPermissionGrantResult(mGroupName, true, false); &#125; break; case R.id.permission_deny_button://拒绝 mAllowButton.setEnabled(true); if (mResultListener != null) &#123; view.clearAccessibilityFocus(); mResultListener.onPermissionGrantResult(mGroupName, false, mDoNotAskCheckbox.isChecked()); &#125; break; case R.id.do_not_ask_checkbox://不再询问 mAllowButton.setEnabled(!mDoNotAskCheckbox.isChecked()); break; &#125;&#125; 这里是通过GrantPermissionsDefaultViewHandler来控制GrantPermissionsActivity的ui视图，按钮的点击事件是通过GrantPermissionsViewHandler.ResultListener接口来处理的，GrantPermissionsActivity实现了该接口。 1234567891011121314151617181920212223@Overridepublic void onPermissionGrantResult(String name, boolean granted, boolean doNotAskAgain) &#123; if (isObscuredTouch()) &#123; showOverlayDialog(); finish(); return; &#125; GroupState groupState = mRequestGrantPermissionGroups.get(name); if (groupState.mGroup != null) &#123; if (granted) &#123; groupState.mGroup.grantRuntimePermissions(doNotAskAgain);//权限组内部的权限分配 groupState.mState = GroupState.STATE_ALLOWED;//重置权限组的状态 &#125; else &#123; groupState.mGroup.revokeRuntimePermissions(doNotAskAgain); groupState.mState = GroupState.STATE_DENIED; &#125; updateGrantResults(groupState.mGroup); &#125; //下一个组权限的授权 if (!showNextPermissionGroupGrantRequest()) &#123; setResultAndFinish(); &#125;&#125; onPermissionGrantResult的三个参数分别是name代表了权限组的名字，granted表示是否进行权限分配，doNotAskAgain代表是否询问权限。内部的mRequestGrantPermissionGroups是一个LinkedHashMap&lt;String, GroupState&gt;，它的key是权限组名，值为GroupState，它代表了待授权的权限组Map。需要注意的是权限和权限组的概念是不同的，一个权限所属一个权限组，要给权限组可以对应多个权限。而我们传递给GrantPermissionsActivity的是权限数组(注意并不是权限组)，在GrantPermissionsActivity创建的时候，会将我们请求的权限分别匹配到其对应的权限组中，这会重新计算权限组的状态。这个方法对name对应的权限组进行授权或者拒绝，然后处理下一个权限组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/ui/GrantPermissionsActivity.javapublic class GrantPermissionsActivity extends OverlayTouchActivity implements GrantPermissionsViewHandler.ResultListener &#123; private String[] mRequestedPermissions;//请求的权限数组 private int[] mGrantResults;//权限分配的结果数组 //请求的权限数组对应的权限组Map private LinkedHashMap&lt;String, GroupState&gt; mRequestGrantPermissionGroups = new LinkedHashMap&lt;&gt;(); ... @Override public void onCreate(Bundle icicle) &#123; ... //加载应用权限组 mAppPermissions = new AppPermissions(this, callingPackageInfo, null, false, new Runnable() &#123; @Override public void run() &#123; setResultAndFinish(); &#125; &#125;); //遍历权限组 for (AppPermissionGroup group : mAppPermissions.getPermissionGroups()) &#123; boolean groupHasRequestedPermission = false; for (String requestedPermission : mRequestedPermissions) &#123; //如果请求的权限在该组内则标记groupHasRequestedPermission为true if (group.hasPermission(requestedPermission)) &#123; groupHasRequestedPermission = true; break; &#125; &#125; if (!groupHasRequestedPermission) &#123; continue; &#125; // We allow the user to choose only non-fixed permissions. A permission // is fixed either by device policy or the user denying with prejudice. if (!group.isUserFixed() &amp;&amp; !group.isPolicyFixed()) &#123; switch (permissionPolicy) &#123; case DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT: &#123; if (!group.areRuntimePermissionsGranted()) &#123; group.grantRuntimePermissions(false); &#125; group.setPolicyFixed(); &#125; break; case DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY: &#123; if (group.areRuntimePermissionsGranted()) &#123; group.revokeRuntimePermissions(false); &#125; group.setPolicyFixed(); &#125; break; default: &#123; //权限组是否已经分配了Runtime Permission,如果没有，则添加到mRequestGrantPermissionGroups中 if (!group.areRuntimePermissionsGranted()) &#123; mRequestGrantPermissionGroups.put(group.getName(), new GroupState(group)); &#125; else &#123; group.grantRuntimePermissions(false); updateGrantResults(group); &#125; &#125; break; &#125; &#125; else &#123; // if the permission is fixed, ensure that we return the right request result updateGrantResults(group); &#125; &#125; ... if (!showNextPermissionGroupGrantRequest()) &#123; setResultAndFinish(); &#125; &#125;&#125; 在GrantPermissionsActivity的onCreate方法中，根据请求的权限计算所属权限组的状态，首先创建AppPermissions对象，这时会去加载应用的权限组。同时遍历用于请求的权限数组并找到其对应的权限组，同时判断该权限组是否已经分配了动态权限，如果未授权则添加到待授权的权限组Map中。到这里我们还未看到真正的授权过程，在前面onPermissionGrantResult方法中，授权是通过GroupState中的成员mGroup的grantRuntimePermissions方法进一步进行权限分配的。而GroupState的定义如下 123456789101112private static final class GroupState &#123; static final int STATE_UNKNOWN = 0; static final int STATE_ALLOWED = 1; static final int STATE_DENIED = 2; final AppPermissionGroup mGroup; int mState = STATE_UNKNOWN; GroupState(AppPermissionGroup group) &#123; mGroup = group; &#125;&#125; GroupState有三个状态STATE_UNKNOWN，STATE_ALLOWED，STATE_DENIED，它内部的mGroup实际上是个AppPermissionGroup，这些AppPermissionGroup是在AppPermissions加载的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/model/AppPermissionGroup.javapublic boolean grantRuntimePermissions(boolean fixedByTheUser) &#123; final boolean isSharedUser = mPackageInfo.sharedUserId != null; final int uid = mPackageInfo.applicationInfo.uid; // We toggle permissions only to apps that support runtime // permissions, otherwise we toggle the app op corresponding // to the permission if the permission is granted to the app. //遍历权限组对应的权限 for (Permission permission : mPermissions.values()) &#123; if (mAppSupportsRuntimePermissions) &#123;//支持动态权限分配 // Do not touch permissions fixed by the system. if (permission.isSystemFixed()) &#123;//系统权限则返回 return false; &#125; // Ensure the permission app op enabled before the permission grant. //打开permssion可以被grant的选项 if (permission.hasAppOp() &amp;&amp; !permission.isAppOpAllowed()) &#123; permission.setAppOpAllowed(true); mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_ALLOWED); &#125; // Grant the permission if needed. //进行动态分配，通过PMS完成 if (!permission.isGranted()) &#123; permission.setGranted(true); mPackageManager.grantRuntimePermission(mPackageInfo.packageName, permission.getName(), mUserHandle); &#125; // Update the permission flags. if (!fixedByTheUser) &#123; // Now the apps can ask for the permission as the user // no longer has it fixed in a denied state. if (permission.isUserFixed() || permission.isUserSet()) &#123; permission.setUserFixed(false); permission.setUserSet(true); mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, PackageManager.FLAG_PERMISSION_USER_FIXED | PackageManager.FLAG_PERMISSION_USER_SET, 0, mUserHandle); &#125; &#125; &#125; else &#123;//Adnroid M以下的版本权限分配 .... &#125; &#125; return true;&#125; 权限的分配最终是通过PMS的grantRuntimePermission方法来完成的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java@Overridepublic void grantRuntimePermission(String packageName, String name, final int userId) &#123; ... mContext.enforceCallingOrSelfPermission( android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS, "grantRuntimePermission"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "grantRuntimePermission"); final int uid; final SettingBase sb; synchronized (mPackages) &#123; //取到Package对象 final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; throw new IllegalArgumentException("Unknown package: " + packageName); &#125; //取到全局设置中的权限信息 final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; throw new IllegalArgumentException("Unknown permission: " + name); &#125; enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp); uid = UserHandle.getUid(userId, pkg.applicationInfo.uid); sb = (SettingBase) pkg.mExtras;//从pkg中取到应用的设置信息SettingBase if (sb == null) &#123; throw new IllegalArgumentException("Unknown package: " + packageName); &#125; //取到权限状态 final PermissionsState permissionsState = sb.getPermissionsState(); final int flags = permissionsState.getPermissionFlags(name, userId); if ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) &#123; throw new SecurityException("Cannot grant system fixed permission: " + name + " for package: " + packageName); &#125; if (bp.isDevelopment()) &#123; // Development permissions must be handled specially, since they are not // normal runtime permissions. For now they apply to all users. if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; scheduleWriteSettingsLocked(); &#125; return; &#125; //通过PermissionsState进行动态权限的分配 final int result = permissionsState.grantRuntimePermission(bp, userId); .... &#125; .....&#125; 在PMS的grantRuntimePermission方法中首先根据包名取到应用安装时的Package对象，这个Package对象中包含了应用的一些设置信息，通过这个设置信息可以取到当前应用的PermissionState，它维护了当前应用的权限授予情况。同时根据参数name,也就是权限名获取全新的配置信息BasePermission对象，它时从mSettings中取到的，mSettings是PMS的全局设置，它在PMS启动的时候初始化，里面包含了平台支持的所有权限。最后权限的分配进一步通过PermissionState来完成 123456789101112131415161718192021222324252627282930313233//frameworks/base/services/core/java/com/android/server/pm/PermissionsState.java//动态权限的分配public int grantRuntimePermission(BasePermission permission, int userId) &#123; enforceValidUserId(userId); if (userId == UserHandle.USER_ALL) &#123; return PERMISSION_OPERATION_FAILURE; &#125; return grantPermission(permission, userId);&#125;private int grantPermission(BasePermission permission, int userId) &#123; if (hasPermission(permission.name, userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //计算用户组id final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId)); final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS; //将权限包装成PermissionData添加到应用的权限列表中 PermissionData permissionData = ensurePermissionData(permission); //授予权限，修改PermissionState的mGranted属性 if (!permissionData.grant(userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; if (hasGids) &#123; final int[] newGids = computeGids(userId);//重新计算用户的权限组id //权限组id是否发生变化 if (oldGids.length != newGids.length) &#123; return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED; &#125; &#125; return PERMISSION_OPERATION_SUCCESS;&#125; 在grantPermission方法中首先会计算当前用户进程当前拥有的组id，然后再通过ensurePermissionData将权限添加到应用的PermissionData列表中，这里返回一个PermissionData，通过该对象的grant方法进行最终的分配，事实上它其实是修改内部PermissionState成员的mGranted状态为true。最后会对用户的组id进行重新计算，如果发生变化则返回PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED，否则返回PERMISSION_OPERATION_SUCCESS 1234567891011121314151617181920212223242526272829303132333435363738//保证权限被添加到用户列表中private PermissionData ensurePermissionData(BasePermission permission) &#123; if (mPermissions == null) &#123; mPermissions = new ArrayMap&lt;&gt;(); &#125; PermissionData permissionData = mPermissions.get(permission.name); if (permissionData == null) &#123; permissionData = new PermissionData(permission); mPermissions.put(permission.name, permissionData); &#125; return permissionData;&#125;//根据用户权限列表计算用户的gidpublic int[] computeGids(int userId) &#123; enforceValidUserId(userId); int[] gids = mGlobalGids; if (mPermissions != null) &#123; final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; String permission = mPermissions.keyAt(i); if (!hasPermission(permission, userId)) &#123; continue; &#125; PermissionData permissionData = mPermissions.valueAt(i); //取到权限对应的组id数组，可见权限可以通过多个gid描述 final int[] permGids = permissionData.computeGids(userId); if (permGids != NO_GIDS) &#123; //将权限对应的组id添加到用户的组id数组中 gids = appendInts(gids, permGids); &#125; &#125; &#125; return gids;&#125; ensurePermissionData方法确保将权限对应的PermissionData添加到PermissonsState的权限列表中，后续通过computeGids计算用户userId对应的组id，并将其添加到用户的组id数组mGlobalGids中。其中内置权限的gid映射是定义在/etc/permission/platform.xml 12345678910111213141516&lt;permissions&gt; ··· &lt;permission name="android.permission.READ_EXTERNAL_STORAGE" &gt; &lt;group gid="sdcard_r" /&gt; &lt;/permission&gt; &lt;permission name="android.permission.WRITE_EXTERNAL_STORAGE" &gt; &lt;group gid="sdcard_r" /&gt; &lt;group gid="sdcard_rw" /&gt; &lt;/permission&gt; &lt;permission name="android.permission.INTERNET" &gt; &lt;group gid="inet" /&gt; &lt;/permission&gt; ···&lt;/permissions&gt; 至此，我们明白了权限的本质实际上就是一组gid，这组gid对应的是一些整型，这些映射关系存放在system/core/include/private/android_filesystem_config.h中，其中的定义如下 1234567891011121314#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */#define AID_NET_BT 3002 /* bluetooth: create sco, rfcomm or l2cap sockets */#define AID_INET 3003 /* can create AF_INET and AF_INET6 sockets */#define AID_SDCARD_RW 1015 /* external storage write access */static const struct android_id_info android_ids[] = &#123; ... &#123; "bluetooth", AID_BLUETOOTH, &#125;, &#123; "sdcard_rw", AID_SDCARD_RW, &#125;, &#123; "net_bt_admin", AID_NET_BT_ADMIN, &#125;, &#123; "net_bt", AID_NET_BT, &#125;, &#123; "inet", AID_INET, &#125;, ...&#125; 通过将权限映射成一组gid，然后作为补充gid赋值给用户进程，也就是权限分配的本质。 1234567891011121314151617181920//PermisssionsState.PermissionDatapublic boolean grant(int userId) &#123; if (!isCompatibleUserId(userId)) &#123; return false; &#125; if (isGranted(userId)) &#123; return false; &#125; PermissionState userState = mUserStates.get(userId); if (userState == null) &#123; userState = new PermissionState(mPerm.name); mUserStates.put(userId, userState); &#125; //分配权限置true userState.mGranted = true; return true;&#125; 通过PermissionData的grant方法，为对应的用户创建PermissionState，并将mGranted置为true表示分配了该权限给 该用户。 当然权限分配完成后，下次不需要再次分配，当我们重新启动手机后，并需要再次对权限进行分配，这是因为PMS为所有的package记录了权限分配的情况，在Android6.0之前，package所有的权限信息都是存放在data/system/packages.xml配置文件中,在应用中启动时候读取该配置就可以直到权限分配了哪些权限。但在Android6.0后，运行时权限放在了data/system/users/0/runtime-permissions.xml中，而普通权限保持不变依然存放在packages.xml中，而且默认granted就是true。那么在分配完成权限后需要将权限的分配信息持久化到该文件中。 12345678910111213141516171819202122232425//packages.xml&lt;package name="com.feelschaotic.demo" codePath="/data/app/com.feelschaotic.demo-Gi5ksdF6mUDLakfOugCcwQ==" nativeLibraryPath="/data/app/com.feelschaotic.demo-Gi5ksdF6mUDLakfOugCcwQ==/lib" primaryCpuAbi="x86" publicFlags="945307462" privateFlags="0" ft="16348dc3870" it="16343f1d6aa" ut="16348dc4c4d" version="8220" userId="10102"&gt; &lt;sigs count="1"&gt; &lt;cert index="20" key="..." /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;!-- 此处普通权限的 granted 全都默认是 true，且不可改变 granted 值--&gt; &lt;item name="android.permission.CHANGE_NETWORK_STATE" granted="true" flags="0" /&gt; &lt;item name="android.permission.INTERNET" granted="true" flags="0" /&gt; &lt;item name="android.permission.CHANGE_WIFI_STATE" granted="true" flags="0" /&gt; &lt;item name="android.permission.ACCESS_NETWORK_STATE" granted="true" flags="0" /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier="48" /&gt; &lt;/package&gt; 123456789&lt;pkg name="com.feelschaotic.demo"&gt; &lt;!-- 该demo我们故意拒绝了定位权限，可以看到：ACCESS_FINE_LOCATION 和 ACCESS_COARSE_LOCATION 的 granted 为 false --&gt; &lt;item name="android.permission.ACCESS_FINE_LOCATION" granted="false" flags="1" /&gt; &lt;item name="android.permission.READ_EXTERNAL_STORAGE" granted="true" flags="0" /&gt; &lt;item name="android.permission.ACCESS_COARSE_LOCATION" granted="false" flags="1" /&gt; &lt;item name="android.permission.READ_PHONE_STATE" granted="true" flags="0" /&gt; &lt;item name="android.permission.WRITE_EXTERNAL_STORAGE" granted="true" flags="0" /&gt; ...&lt;/pkg&gt; 在PMS的grantRuntimePermission分配完运行时权限后，最后会调用writeRuntimePermissionsForUserLPr将权限信息持久化到配置文件runtime-permissions.xml中,我们看看这个过程 1234567public void writeRuntimePermissionsForUserLPr(int userId, boolean sync) &#123; if (sync) &#123; mRuntimePermissionsPersistence.writePermissionsForUserSyncLPr(userId); &#125; else &#123; mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId); &#125;&#125; 无论时同步方式还是异步方式的持久化，最后都会调用下面的方法进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//写入权限到配置文件private void writePermissionsSync(int userId) &#123; //要写入的文件/data/system/users/0/runtime-permissions.xml AtomicFile destination = new AtomicFile(getUserRuntimePermissionsFile(userId)); ArrayMap&lt;String, List&lt;PermissionState&gt;&gt; permissionsForPackage = new ArrayMap&lt;&gt;(); ArrayMap&lt;String, List&lt;PermissionState&gt;&gt; permissionsForSharedUser = new ArrayMap&lt;&gt;(); synchronized (mLock) &#123; mWriteScheduled.delete(userId); //对所有的package进行处理 final int packageCount = mPackages.size(); for (int i = 0; i &lt; packageCount; i++) &#123; String packageName = mPackages.keyAt(i); //取到PackageSetting PackageSetting packageSetting = mPackages.valueAt(i); if (packageSetting.sharedUser == null) &#123;//没有sharedUser的情况 //取到PermissionsState，这个对象描述了包的权限信息 PermissionsState permissionsState = packageSetting.getPermissionsState(); List&lt;PermissionState&gt; permissionsStates = permissionsState .getRuntimePermissionStates(userId);//获取全新分配列表 if (!permissionsStates.isEmpty()) &#123; //存放在permissionsForPackage这个Map中，以包名为键 permissionsForPackage.put(packageName, permissionsStates); &#125; &#125; &#125; //有shareUser的情况 final int sharedUserCount = mSharedUsers.size(); for (int i = 0; i &lt; sharedUserCount; i++) &#123; String sharedUserName = mSharedUsers.keyAt(i); SharedUserSetting sharedUser = mSharedUsers.valueAt(i); PermissionsState permissionsState = sharedUser.getPermissionsState(); List&lt;PermissionState&gt; permissionsStates = permissionsState .getRuntimePermissionStates(userId); if (!permissionsStates.isEmpty()) &#123; permissionsForSharedUser.put(sharedUserName, permissionsStates); &#125; &#125; &#125; //写配置 FileOutputStream out = null; try &#123; //取到输出流 out = destination.startWrite(); XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, StandardCharsets.UTF_8.name()); serializer.setFeature( "http://xmlpull.org/v1/doc/features.html#indent-output", true); serializer.startDocument(null, true); serializer.startTag(null, TAG_RUNTIME_PERMISSIONS); String fingerprint = mFingerprints.get(userId); if (fingerprint != null) &#123; serializer.attribute(null, ATTR_FINGERPRINT, fingerprint); &#125; //先写当前package的permission final int packageCount = permissionsForPackage.size(); for (int i = 0; i &lt; packageCount; i++) &#123; String packageName = permissionsForPackage.keyAt(i); List&lt;PermissionState&gt; permissionStates = permissionsForPackage.valueAt(i); serializer.startTag(null, TAG_PACKAGE);//package serializer.attribute(null, ATTR_NAME, packageName); writePermissions(serializer, permissionStates); serializer.endTag(null, TAG_PACKAGE); &#125; //写其shareUser进程的permission final int sharedUserCount = permissionsForSharedUser.size(); for (int i = 0; i &lt; sharedUserCount; i++) &#123; String packageName = permissionsForSharedUser.keyAt(i); List&lt;PermissionState&gt; permissionStates = permissionsForSharedUser.valueAt(i); serializer.startTag(null, TAG_SHARED_USER); serializer.attribute(null, ATTR_NAME, packageName); writePermissions(serializer, permissionStates); serializer.endTag(null, TAG_SHARED_USER); &#125; serializer.endTag(null, TAG_RUNTIME_PERMISSIONS); serializer.endDocument(); destination.finishWrite(out); if (Build.FINGERPRINT.equals(fingerprint)) &#123; mDefaultPermissionsGranted.put(userId, true); &#125; // Any error while writing is fatal. &#125; catch (Throwable t) &#123; Slog.wtf(PackageManagerService.TAG, "Failed to write settings, restoring backup", t); destination.failWrite(out); &#125; finally &#123; IoUtils.closeQuietly(out); &#125;&#125; writePermissionsSync写配置的过程很简单，先打开配置文件/data/system/users/0/runtime-permissions.xml，随后对PMS中的每个package和sharedUser分别将其对应的权限分配列表按照包名和shareUserName存放在permissionsForPackage和permissionsForSharedUser中，随后打开输出流分别将其对应的运行时权限分配情况写入文件。 123456789101112private void writePermissions(XmlSerializer serializer, List&lt;PermissionState&gt; permissionStates) throws IOException &#123; for (PermissionState permissionState : permissionStates) &#123; serializer.startTag(null, TAG_ITEM); serializer.attribute(null, ATTR_NAME,permissionState.getName()); serializer.attribute(null, ATTR_GRANTED, String.valueOf(permissionState.isGranted())); serializer.attribute(null, ATTR_FLAGS, Integer.toHexString(permissionState.getFlags())); serializer.endTag(null, TAG_ITEM); &#125;&#125; writePermissions负责写tag 为package下的一条权限分配信息，如 1&lt;item name="android.permission.WRITE_EXTERNAL_STORAGE" granted="true" flags="0" /&gt; 权限的检测 权限检测是通过Context的checkSelfPermission方法来进行的。我们看下它的实现 123456789101112131415161718192021@Overridepublic int checkSelfPermission(String permission) &#123; if (permission == null) &#123; throw new IllegalArgumentException("permission is null"); &#125; return checkPermission(permission, Process.myPid(), Process.myUid());&#125;@Overridepublic int checkPermission(String permission, int pid, int uid) &#123; if (permission == null) &#123; throw new IllegalArgumentException("permission is null"); &#125; try &#123; return ActivityManagerNative.getDefault().checkPermission( permission, pid, uid); &#125; catch (RemoteException e) &#123; return PackageManager.PERMISSION_DENIED; &#125;&#125; 最终还是通过AMS的checkPermission来进行权限检查。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//frameworks/base/core/java/android/app/ActivityManager.java@Overridepublic int checkPermission(String permission, int pid, int uid) &#123; if (permission == null) &#123; return PackageManager.PERMISSION_DENIED; &#125; return checkComponentPermission(permission, pid, uid, -1, true);&#125;int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) &#123; if (pid == MY_PID) &#123; return PackageManager.PERMISSION_GRANTED; &#125; return ActivityManager.checkComponentPermission(permission, uid, owningUid, exported);&#125;/** @hide */public static int checkComponentPermission(String permission, int uid, int owningUid, boolean exported) &#123; // Root, system server get to do everything. final int appId = UserHandle.getAppId(uid); if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) &#123; return PackageManager.PERMISSION_GRANTED; &#125; // Isolated processes don't get any permissions. if (UserHandle.isIsolated(uid)) &#123; return PackageManager.PERMISSION_DENIED; &#125; // If there is a uid that owns whatever is being accessed, it has // blanket access to it regardless of the permissions it requires. if (owningUid &gt;= 0 &amp;&amp; UserHandle.isSameApp(uid, owningUid)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; // If the target is not exported, then nobody else can get to it. if (!exported) &#123; /* RuntimeException here = new RuntimeException("here"); here.fillInStackTrace(); Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid, here); */ return PackageManager.PERMISSION_DENIED; &#125; if (permission == null) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //通过PMS进行check try &#123; return AppGlobals.getPackageManager() .checkUidPermission(permission, uid); &#125; catch (RemoteException e) &#123; // Should never happen, but if it does... deny! Slog.e(TAG, "PackageManager is dead?!?", e); &#125; return PackageManager.PERMISSION_DENIED;&#125; 在AMS中的一系列调用中，最终的权限还是通过PMS的checkUidPermission来进行check的。 12345678910111213141516171819202122232425262728293031323334353637383940//PMS@Overridepublic int checkUidPermission(String permName, int uid) &#123; final int userId = UserHandle.getUserId(uid); if (!sUserManager.exists(userId)) &#123; return PackageManager.PERMISSION_DENIED; &#125; synchronized (mPackages) &#123; Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid)); if (obj != null) &#123; final SettingBase ps = (SettingBase) obj; final PermissionsState permissionsState = ps.getPermissionsState(); //通过PermissionsState来检查 if (permissionsState.hasPermission(permName, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //定位权限的检测特殊处理 // Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; permissionsState .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; else &#123; ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid); if (perms != null) &#123; if (perms.contains(permName)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; perms .contains(Manifest.permission.ACCESS_FINE_LOCATION)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; &#125; &#125; return PackageManager.PERMISSION_DENIED;&#125; checkUidPermission首先根据userId从PMS的配置对象中取到SettingBase,然后取到用户对应的PermissionsState，再通过permissionsState的hasPermission判断是否有该权限。 123456789101112//检测权限public boolean hasPermission(String name, int userId) &#123; enforceValidUserId(userId); if (mPermissions == null) &#123; return false; &#125; //取到权限对应的PermissionData PermissionData permissionData = mPermissions.get(name); //通过isGranted来判断 return permissionData != null &amp;&amp; permissionData.isGranted(userId);&#125; 从PermissionsState的权限列表中取到PermissionData，通过PermissionData的PermissionState对象的mGranted成员就知道权限是否分配了。 总结 在Android6.0之前的版本中，应用在安装的时候会将manifest中request的权限(即通过申请的权限)添加到Package对象的PackageSetting中，PMS为每个安装的app创建一个Package对象，这个是在安装过程中创建的，同时在安装过程中也会为每个app创建一个PackageSetting对象，并将其保存在Package对象的mExtra中，在PackageSetting内部保存了应用的签名信息和授予的权限列表，实际上PackageSetting本身就是继承自GrantedPermissions类，这个类从名字看就知道它负责已授权的permission。应用中授权的权限在安装完成后会将应用的信息(包括了权限，签名和应用的基本信息等)写入到pacakge.xml文件中，这样下次系统启动就可以通过读取该文件获取应用的授权信息。 在Aandroid6.0之后，google为了防止应用滥用权限对权限的授予进行了收缩，将危险的权限授予过程交给用户来决定，为了适应这样的变化，必须要将安装权限和运行时权限进行区分处理，安装权限保持原有的逻辑不变，对于动态权限的分配必然要对PackageSetting进行一个大手术，在Android6.0中PackageSetting不再继承自GrantedPermissions，而是继承自于SettingBase，它的内部也比以前复杂了一些，简单来说它内部维护了一个PermissionsState，它负责管理应用的权限，因此它内部存放着应用的授权的权限列表(实际上是一个ArrayMap&lt;String, PermissionData&gt;)，以及权限组对应的gids，此时的权限不再是仅仅是一个String，而是一个PermissionData，而PermissionData内部持有PermissionState即permission的状态，可以看到最终我们还是通过改变PermissionData的PermissionState来达到动态授权的目的。另外授予的动态权限最终会保存在runtime-permission.xml中。 参考 https://www.jianshu.com/p/a17c8bed79d9]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeakCanary内存泄漏检测机制原理]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-libray-leakcanary-src%2F</url>
    <content type="text"><![CDATA[LeakCanary是Square公司基于MAT开发的一个用于检测内存泄露的库,它能检测应用存在的内存泄露，并通过界面直观的展示给开发者，极大的方便调试和开发健壮可靠的程序。 内存泄露 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。比如在c++中通过new的内存忘记delete掉，或者java中对象使用完成后没有释放对象引用d导致GC不能正常的回收该对象而继续占用内存。 使用 LeakCanary的使用也很简单，首先在gradle文件中添加 1234dependencies &#123; debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'&#125; 然后在Application的onCreate中调用如下代码就可以使用LeakCanary了 1LeakCanary.install(this); 检测原理 下面我们就从install方法开始阅读下LeakCanary的源码，从而理解LeakCanary的检测原理。 123456789101112131415public static RefWatcher install(Application application) &#123; return install(application, DisplayLeakService.class, AndroidExcludedRefs.createAppDefaults().build());&#125;public static RefWatcher install(Application application, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass, ExcludedRefs excludedRefs) &#123; if(isInAnalyzerProcess(application)) &#123; return RefWatcher.DISABLED; &#125; else &#123; enableDisplayLeakActivity(application); ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, listenerServiceClass); RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs); ActivityRefWatcher.installOnIcsPlus(application, refWatcher); return refWatcher; &#125;&#125; LeakCanary的install方法先判断当前进程是否在LeakCanary所在进程，因为LeakCanary分析时是在独立的进程中进行的，Applciation会有多个实例分别对应不同的进程，如果在的话就直接返回RefWatcher.DISABLED，否则就是在我们的自己的App进程中，这里首先启用DisplayLeakActivity这个页面最终会显示内存泄露的情况，随后创建一个ServiceHeapDumpListener，这个类实现了HeapDump的Listener接口，这个接口提供了analyze方法，这个方法从来分析dump下来的Mat文件。 123456public static RefWatcher androidWatcher(Context context, Listener heapDumpListener, ExcludedRefs excludedRefs) &#123; AndroidDebuggerControl debuggerControl = new AndroidDebuggerControl(); AndroidHeapDumper heapDumper = new AndroidHeapDumper(context); heapDumper.cleanup(); return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT, heapDumper, heapDumpListener, excludedRefs);&#125; 随后通过androidWatcher创建一个RefWatcher，这个是用来分析内存泄露用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void installOnIcsPlus(Application application, RefWatcher refWatcher) &#123; if(VERSION.SDK_INT &gt;= 14) &#123; ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); activityRefWatcher.watchActivities(); &#125;&#125;接下来还创建了一个ActivityRefWatcher，这watcher用来监听Activity的生命周期。这个是通过watchActivities来完成的。public void watchActivities() &#123; this.stopWatchingActivities(); this.application.registerActivityLifecycleCallbacks(this.lifecycleCallbacks);&#125;watchActivities会通过registerActivityLifecycleCallbacks注册Ativity生命周期的回调，这个方法会通过回调lifecycleCallbacks监听应用中所有activity的生命周期。private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() &#123; public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; public void onActivityStarted(Activity activity) &#123; &#125; public void onActivityResumed(Activity activity) &#123; &#125; public void onActivityPaused(Activity activity) &#123; &#125; public void onActivityStopped(Activity activity) &#123; &#125; public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity); &#125;&#125;;void onActivityDestroyed(Activity activity) &#123; this.refWatcher.watch(activity);&#125; 可以看到在生命周期回调lifecycleCallbacks中，只在onActivityDestroyed中进行了处理，这里会调用RefWather的watch方法来分析是否有内存泄露。 12345678910111213141516171819public void watch(Object watchedReference) &#123; this.watch(watchedReference, "");&#125;public void watch(Object watchedReference, String referenceName) &#123; Preconditions.checkNotNull(watchedReference, "watchedReference"); Preconditions.checkNotNull(referenceName, "referenceName"); if(!this.debuggerControl.isDebuggerAttached()) &#123; final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); this.retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue); this.watchExecutor.execute(new Runnable() &#123; public void run() &#123; RefWatcher.this.ensureGone(reference, watchStartNanoTime); &#125; &#125;); &#125;&#125; watch方法会将当前Activity实例引用封装为一个KeyedWeakReference，从名字来看它是一个WeakRefrence,同时对应一个key，key是一个UUID，同时这个key是被添加在retainedKeys中，它是一个CopyOnWriteArraySet。 需要注意的是在创建KeyedWeakReference，我们提供了一个ReferenceQueue队列，这样当WeakRefrence对象被回收时，回收的对象的引用是会被添加到该队列中的。准备完这些工作后开启线程调用ensureGone开始检测内存是否有泄露。 12345678910111213141516171819202122232425262728293031void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = TimeUnit.NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); this.removeWeaklyReachableReferences(); if(!this.gone(reference) &amp;&amp; !this.debuggerControl.isDebuggerAttached()) &#123; this.gcTrigger.runGc(); this.removeWeaklyReachableReferences(); if(!this.gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = TimeUnit.NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = this.heapDumper.dumpHeap(); if(heapDumpFile == HeapDumper.NO_DUMP) &#123; return; &#125; long heapDumpDurationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; &#125;&#125;private boolean gone(KeyedWeakReference reference) &#123; return !this.retainedKeys.contains(reference.key);&#125;private void removeWeaklyReachableReferences() &#123; KeyedWeakReference ref; while((ref = (KeyedWeakReference)this.queue.poll()) != null) &#123; this.retainedKeys.remove(ref.key); &#125;&#125; 这里先调用removeWeaklyReachableReferences，这里会从ReferenceQueue中取出一个KeyedWeakReference，如果不为null说明已经回收，然后将Set中对应的key也删除即可，这个属于没有泄露的情况。当然如果为null，就继续ensureGone后面的操作，先调用依次GC，然后通过removeWeaklyReachableReferences再检查一次，类似第一次，如果回收就会从Set中移除key属于正常的情况，否则就是有内存泄露了，这次就需要通过heapDumper生成dump文件，这个文件保存了内存堆的信息。后面基于这个文件对内存泄露进行分析。 前面我们知道heapdumpListener 就是ServiceHeapDumpListener，这里我们通过它的analyze方法来分析内存泄露。这里会通过我们dump文件创建一个HeapDump对象。 12345678910111213141516public final class ServiceHeapDumpListener implements Listener &#123; private final Context context; private final Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass; public ServiceHeapDumpListener(Context context, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123; LeakCanaryInternals.setEnabled(context, listenerServiceClass, true); LeakCanaryInternals.setEnabled(context, HeapAnalyzerService.class, true); this.listenerServiceClass = (Class)Preconditions.checkNotNull(listenerServiceClass, "listenerServiceClass"); this.context = ((Context)Preconditions.checkNotNull(context, "context")).getApplicationContext(); &#125; public void analyze(HeapDump heapDump) &#123; Preconditions.checkNotNull(heapDump, "heapDump"); HeapAnalyzerService.runAnalysis(this.context, heapDump, this.listenerServiceClass); &#125;&#125; 接着调用HeapAnalyzerService服务来分析，它是一个IntentService 123456789101112131415161718192021222324public final class HeapAnalyzerService extends IntentService &#123; private static final String LISTENER_CLASS_EXTRA = "listener_class_extra"; private static final String HEAPDUMP_EXTRA = "heapdump_extra"; public static void runAnalysis(Context context, HeapDump heapDump, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123; Intent intent = new Intent(context, HeapAnalyzerService.class); intent.putExtra("listener_class_extra", listenerServiceClass.getName()); intent.putExtra("heapdump_extra", heapDump); context.startService(intent); &#125; public HeapAnalyzerService() &#123; super(HeapAnalyzerService.class.getSimpleName()); &#125; protected void onHandleIntent(Intent intent) &#123; String listenerClassName = intent.getStringExtra("listener_class_extra"); HeapDump heapDump = (HeapDump)intent.getSerializableExtra("heapdump_extra"); ExcludedRefs androidExcludedDefault = AndroidExcludedRefs.createAndroidDefaults().build(); HeapAnalyzer heapAnalyzer = new HeapAnalyzer(androidExcludedDefault, heapDump.excludedRefs); AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey); AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result); &#125;&#125; 在onHandleIntent中主要是通过HeapAnalyzer来调用checkForLeak来分析的。 12345678910111213141516171819202122232425262728293031323334public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123; long analysisStartNanoTime = System.nanoTime(); if(!heapDumpFile.exists()) &#123; IllegalArgumentException snapshot1 = new IllegalArgumentException("File does not exist: " + heapDumpFile); return AnalysisResult.failure(snapshot1, this.since(analysisStartNanoTime)); &#125; else &#123; ISnapshot snapshot = null; AnalysisResult className; try &#123; snapshot = this.openSnapshot(heapDumpFile); IObject e = this.findLeakingReference(referenceKey, snapshot); if(e == null) &#123; className = AnalysisResult.noLeak(this.since(analysisStartNanoTime)); return className; &#125; String className1 = e.getClazz().getName(); AnalysisResult result = this.findLeakTrace(analysisStartNanoTime, snapshot, e, className1, true); if(!result.leakFound) &#123; result = this.findLeakTrace(analysisStartNanoTime, snapshot, e, className1, false); &#125; AnalysisResult var9 = result; return var9; &#125; catch (Exception var13) &#123; className = AnalysisResult.failure(var13, this.since(analysisStartNanoTime)); &#125; finally &#123; this.cleanup(heapDumpFile, snapshot); &#125; return className; &#125;&#125; checkForLeak主要用来分析dump文件，通过heapDumpFile打开一个快照对象ISnapshot，然后通过findLeakingReference查找可能存在的泄露的引用对象，然后再通过findLeakTrace为这个泄露的引用对象生成输出路径，最后通过AnalysisResult作为结果返回，最终这个结果会被显示出来。 12345678910111213141516171819202122private IObject findLeakingReference(String key, ISnapshot snapshot) throws SnapshotException &#123; Collection refClasses = snapshot.getClassesByName(KeyedWeakReference.class.getName(), false); if(refClasses.size() != 1) &#123; throw new IllegalStateException("Expecting one class for " + KeyedWeakReference.class.getName() + " in " + refClasses); &#125; else &#123; IClass refClass = (IClass)refClasses.iterator().next(); int[] weakRefInstanceIds = refClass.getObjectIds(); int[] arr$ = weakRefInstanceIds; int len$ = weakRefInstanceIds.length; for(int i$ = 0; i$ &lt; len$; ++i$) &#123; int weakRefInstanceId = arr$[i$]; IObject weakRef = snapshot.getObject(weakRefInstanceId); String keyCandidate = PrettyPrinter.objectAsString((IObject)weakRef.resolveValue("key"), 100); if(keyCandidate.equals(key)) &#123; return (IObject)weakRef.resolveValue("referent"); &#125; &#125; throw new IllegalStateException("Could not find weak reference with key " + key); &#125;&#125; 查找泄露对象的引用首先通过snapshot的getClassesByName查找名字为KeyedWeakReference的引用，然后获取到对应这个类的弱引用实例对象的id,通过id可以取到对应的弱引用对象，然后读取它内部的key值，如果和我们查找的key匹配就说明这个引用就是我们要查找的泄露对象。]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Framework Ethernet模块添加接口]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-ethernet-build%2F</url>
    <content type="text"><![CDATA[EthernetService 本篇内容基于Android 6.0.1，涉及到的framework类 frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetService.java frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetServiceImpl.java \frameworks\base\core\java\android\net\EthernetManager.java \frameworks\base\core\java\android\net\IEthernetManager.aidl \frameworks\base\core\java\android\net\IpConfiguration.java /frameworks/base/services/core/java/com/android/server/SystemServiceManager.java 以太网中在一般的Android Phone中是不存在的，不过在一些智能硬件中带有以太网的模块，因此需要有一系列的 接口来访问以太网的状态信息。比如当前的以太网的模式和连接状态等 但是，EthernetService的服务接口只是在framework层可用，并没有开放给用户。实际上看过源码可以看到一些@hide标记的 api和类，这也说明它们对用户层不可用。那么我们如何去获取以太网的状态信息呢？ 本篇将介绍如何在framework中EthernetService中添加这样的接口来供用户访问，这里以添加获取当前的以太网的模式为例，我们知道Android 中Service提供服务是通过Binder来支持的，而AIDL为跨进程访问提供用户访问的接口，而以太网服务的接口是通过IEthernetManager.aidl来定义的 在SystemService启动时会去注册一系列的Service到ServiceManager中去，这里我们先看EthernetService是如何启动的。 1234567891011121314151617181920212223242526272829public final class SystemServer &#123; …… private static final String ETHERNET_SERVICE_CLASS = "com.android.server.ethernet.EthernetService"; public static void main(String[] args) &#123; new SystemServer().run(); &#125; private void run() &#123; try&#123; ... startOtherServices(); ... &#125; .... &#125; private void startOtherServices() &#123; if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123; mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS); &#125; &#125;&#125; 在SystemService中会去通过一个SystemServiceManager的startService方法来启动，从参数大概可以猜出来它会通过反射去创建Service实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@SuppressWarnings("unchecked")public SystemService startService(String className) &#123; final Class&lt;SystemService&gt; serviceClass; try &#123; serviceClass = (Class&lt;SystemService&gt;)Class.forName(className); &#125; catch (ClassNotFoundException ex) &#123; Slog.i(TAG, "Starting " + className); throw new RuntimeException("Failed to create service " + className + ": service class not found, usually indicates that the caller should " + "have called PackageManager.hasSystemFeature() to check whether the " + "feature is available on this device before trying to start the " + "services that implement it", ex); &#125; return startService(serviceClass);&#125; //SystemServiceManager public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; final String name = serviceClass.getName(); Slog.i(TAG, "Starting " + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException("Failed to create " + name + ": service must extend " + SystemService.class.getName()); &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException("Failed to create service " + name + ": service could not be instantiated", ex); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException("Failed to create service " + name + ": service must have a public constructor with a Context argument", ex); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException("Failed to create service " + name + ": service must have a public constructor with a Context argument", ex); &#125; catch (InvocationTargetException ex) &#123; throw new RuntimeException("Failed to create service " + name + ": service constructor threw an exception", ex); &#125; // Register it. mServices.add(service); // Start it. try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException("Failed to start service " + name + ": onStart threw an exception", ex); &#125; return service;&#125; 通过反射创建EthernetService实例，并添加到列表中管理起来。随后调用onStart启动它。我们先看看EthernetService，它有可能就是我们的要找的Binder Server。 12345678910111213141516171819202122232425262728package com.android.server.ethernet;import android.content.Context;import android.util.Log;import com.android.server.SystemService;public final class EthernetService extends SystemService &#123; private static final String TAG = "EthernetService"; final EthernetServiceImpl mImpl; public EthernetService(Context context) &#123; super(context); mImpl = new EthernetServiceImpl(context); &#125; @Override public void onStart() &#123; Log.i(TAG, "Registering service " + Context.ETHERNET_SERVICE); publishBinderService(Context.ETHERNET_SERVICE, mImpl); &#125; @Override public void onBootPhase(int phase) &#123; if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) &#123; mImpl.start(); &#125; &#125;&#125; EthernetService的实现很简单，它并不是真正的Binder Server，它的任务很简单是就是去注册一个服务EthernetServiceImpl,注册到哪去了呢？ 这还用问？当然是ServiceManager中，这里EthernetService继承自SystemService，publishBinderService正是在它里面实现的，它将服务实体 注册到ServiceManager中去。那么毋庸置疑，这里的EthernetServiceImpl就是Binder Server了。 1234567891011121314151617/** * EthernetServiceImpl handles remote Ethernet operation requests by implementing * the IEthernetManager interface. * * @hide */public class EthernetServiceImpl extends IEthernetManager.Stub &#123; //在service中实现我们添加的接口 @Override public int getEthernetMode() &#123; Log.d(TAG,"getEthernetMode=="+(mIpConfiguration.ipAssignment == IpAssignment.DHCP)); return (mIpConfiguration.ipAssignment == IpAssignment.DHCP) ? 0 : 1; &#125;&#125; 从其实现来看它的确是，因为它继承了IEthernetManager.Stub，从而有了跨进程的能力。我们看看它提供了的接口定义 123456789101112131415/** &#123;@hide&#125; */interface IEthernetManager&#123; IpConfiguration getConfiguration(); void setConfiguration(in IpConfiguration config); boolean isAvailable(); void addListener(in IEthernetServiceListener listener); void removeListener(in IEthernetServiceListener listener); int getEthernetConnectState(); boolean setEthernetEnabled(in boolean enable); int getEthernetIfaceState(); //添加的服务接口 int getEthernetMode(); &#125; 看过context的同学可能知道ContextImpl在创建的时候会去注册一些服务管理对象，这些都是被添加到静态实例中，以供多个context实例共享使用，这也是我们为什么 能够通过Context.getSystemService获取服务的原因，而EthernetService是通过EthernetManager来管理的。 12345678registerService(Context.ETHERNET_SERVICE, EthernetManager.class, new CachedServiceFetcher&lt;EthernetManager&gt;() &#123; @Override public EthernetManager createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(Context.ETHERNET_SERVICE); IEthernetManager service = IEthernetManager.Stub.asInterface(b); return new EthernetManager(ctx.getOuterContext(), service); &#125;&#125;); 那么我们为什么不能用Context获取getSystemService来获取EthernetService的管理者从而访问其服务接口呢？ 原因是Context中不允许我们这么做，对ETHERNET_SERVICE使用了@hide，这样我们就不能取到ETHERNET_SERVICE的服务， 如果我们在代码中直接引用EthernetManager也会报错，因为EthernetManager对上层是不可见的。 public abstract class Context { 12345678910111213 2832 /** 2833 * Use with &#123;@link #getSystemService&#125; to retrieve a &#123;@link 2834 * android.net.EthernetManager&#125; for handling management of 2835 * Ethernet access. 2836 * 2837 * @see #getSystemService 2838 * @see android.net.EthernetManager 2839 * 2840 * @hide 2841 */ 2842 public static final String ETHERNET_SERVICE = "ethernet";&#125; 这可如何是好？有一个办法，那就是通过反射，通过反射可以取到service的实例，从而进行访问service这些隐藏的api，当然这也有很大的局限性， 而且会带来可能存在的风险，比如当系统版本变动后就会带来不可预知的问题。但对于特定的硬件产品(系统确定且不会再变更)来说，这也算是一种有效的方法。为了避免可能存在的问题，我们最好添加一些先验条件来使用。 123456789101112131415161718192021222324252627282930private static int getEthernetMode(Context context)&#123; int result = -1; if(/*一些校验条件*/) &#123; try &#123; String ETHERNET_SERVICE = (String) Context.class.getField("ETHERNET_SERVICE").get(null); Class&lt;?&gt; ethernetManagerClass = Class.forName("android.net.EthernetManager"); Object ethernetManager = context.getSystemService(ETHERNET_SERVICE); Field mService = ethernetManagerClass.getDeclaredField("mService"); mService.setAccessible(true); Object mServiceObject = mService.get(ethernetManager); Class&lt;?&gt; iEMgrClass = Class.forName("android.net.IEthernetManager"); Method[] methods = iEMgrClass.getDeclaredMethods(); for (Method ms : methods) &#123; if (ms.getName().equals("getEthernetMode")) &#123; result = (Integer) ms.invoke(mServiceObject); break; &#125; &#125; &#125; catch (InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; L.d("ethernet", "exception==&gt;" + e.getMessage()); // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return result;&#125; ###编译 编译 framework.jar 在上述的内容中我们添加了getEthernetMode以获取以太网的模式，即是动态还是静态的。我们的改动主要在aidl和service中，因此需要编译相关的模块。 首先执行 1234source ./build/envsetup.shlunch xxxcd frameworks/basemm -B 编译得到 framework.jar ，它的位置在 out\target\product\xxx\system\framework\framework.jar 编译完成后我们也可以看到生成的IEthernetManager.java了，它的位置在 \out\target\common\obj\JAVA_LIBRARIES\framework_intermediates\src\core\java\android\net\IEthernetManager.java IEthernetManager.java为IEthernetManager.aidl对应的java文件，打开它就可以看到我们定义的接口 编译ethernet-service.jar 12cd frameworks/opt/net/ethernet/mm -B 编译得到ethernet-service.jar ，它的位置在 out\target\product\xxx\system\framework\ethernet-service.jar 最后将framework.jar和ethernet-service.jar push到system/framework/目录下重启后就可以在客户程序中通过getEthernetMode使用我们提供的接口服务了。 完。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View事件分发机制]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-inputevent-dispatch-src%2F</url>
    <content type="text"><![CDATA[本篇将介绍输入事件在View树中的分发机制。 事件产生 输入事件是通过InputManager的InputDispatcher分派给WMS的，在创建ViewRootImpl时会建立和WMS的关联，实际上是两个InputChannel，这两个InputChannel是一个socketpair分别负责读和写事件信息。这样事件就可以通过ViewRootImpl分发给view树。 1234567891011121314151617181920212223242526272829303132final class ViewPostImeInputStage extends InputStage &#123; @Override protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; …… final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; …… &#125; &#125;&#125;private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; if (mView.dispatchPointerEvent(event)) &#123; return FINISH_HANDLED; &#125; return FORWARD;&#125;public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; 产生的事件最终是交给DecorView也就是view树的根节点进行分发的，对于Touch事件，它是通过dispatchTouchEvent进行分发的，DecorView实际上是一个ViewGroup，这里我们看它的dispatchTouchEvent方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; …… // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; …… final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final View[] children = mChildren; final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = children[childIndex]; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = childIndex; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; …… &#125; return handled;&#125; 在ViewGroup的dispatchTouchEvent中，主要做了以下事情： 判断是否有允许事件拦截，如果允许拦截则通过onInterceptTouchEvent拦截事件，并将处理的结果保存。 如果未进行拦截处理，就需要为ACTION_DOWN寻找一个TargetView，实际上就是将事件分发给子view进行处理，如果子view对其进行处理即在dispatchTransformedTouchEvent返回true，则它就是TargetView,后续ACTION_MOVE,ACTION_UP事件会分发给它。 如果没有找到TargetView，则交由ViewGroup自身进行事件处理。 12345678910111213141516171819202122public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; if (onFilterTouchEventForSecurity(event)) &#123; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; if (onTouchEvent(event)) &#123; return true; &#125; &#125; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; return false;&#125; 子View对于事件先通过onTouch进行处理，如果onTouch消费了此次事件，则直接返回true表示子view处理了本次事件，否则通过onTouchEvent进行处理，同样的，返回true表示处理了本次事件，View的dispatchTouchEvent类似。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; …… final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled;&#125; 在dispatchTransformedTouchEvent中当child为null时，即没有子view或者子view都不对事件进行处理，则通过ViewGroup自身的dispatchTouchEvent进行消化处理，否则是交给子view进行处理，处理的结果handled作为事件是否被消费的依据，如果handled为true表示事件被消费了，这样事件就不需要在view树中进行传递了。 view树的事件传递机制比较简答，读者可以分别阅读view和viewGroup的dispatchTouchEvent部分相关的代码即可。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InputMangerService之Input事件分发流程]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-inputmanager-input-dispatch-src%2F</url>
    <content type="text"><![CDATA[InputManagerService负责Android输入设备的事件管理，输入事件是Android应用程序最重要的组成部分，因此我们有必要对整个事件的流程进行分析。我们知道输入事件如触摸事件的分发流程是从view树的根部开始向下传递的，但本篇不对此进行分析，而是从事件发生的源头到该步所做的工作进行梳理。那么既然IMS最终要将事件投递到view树中，即DecorView对象上，那么可以想到IMS必然和WMS有不可分割的关系，其实，也可以想到，输入事件要被应用进行处理，必然投递到某一个前台窗口，后面我们会看到他们之间的紧密关系。 事件输入的流程启动 我们知道SystemServer在启动的时候会启动众多的系统服务，这些服务中就包括了WMS和IMS。下面我们看看他们分别是如何启动的。 frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112131415161718192021222324252627public void initAndLoop()&#123; …… // Create a handler thread just for the window manager to enjoy. HandlerThread wmHandlerThread = new HandlerThread("WindowManager"); wmHandlerThread.start(); //为WMS单独创建的HandlerThread Handler wmHandler = new Handler(wmHandlerThread.getLooper()); …… //创建输入管理服务 inputManager = new InputManagerService(context, wmHandler); Slog.i(TAG, "Window Manager"); wm = WindowManagerService.main(context, power, display, inputManager, wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);//创建WMS 同时这里将输入管理服务和其关联在一起 ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); …… //为输入管理服务设置回调 这个回调来自WMS inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start();//启动输入管理的流程 ……&#125; SystemServer进程在启动时会调用其Main方法进行一些初始化工作，initAndLoop就是在整个时候进行的，它会注册多个系统服务到Sm中去，这里我们关注WMS和IMS即可。 首先创建IMS的实例，并将其作为参数传递给WMS，随后将这两个服务的实例都加入到SM中 这里我们先看IMS的实例创建过程，它需要一个context和一个Handler作为参数来构造。这个Handler时为WMS创建的，这里传给IMS，说明他们之间共享这个Handler. SystemServer中通过该构造方法创建IMS 注意这个handler是供WMS使用的，它里传过来说明它想和WMS共享handler frameworks/base/services/java/com/android/server/input/InputManagerService.java 123456789public InputManagerService(Context context, Handler handler) &#123; this.mContext = context; this.mHandler = new InputManagerHandler(handler.getLooper()); mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack); mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); //创建native层的InputManager对象，结果保存在mPtr&#125; IMS的构造很简单，它实际上调用natvieInit来创建native层的InputManger对象，对应于java层的IMS，结果返回给mPtr，注意这里的第三个参数为handler的MessageQueue. frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 1234567891011121314//创建Native层的InputManager对象static jint nativeInit(JNIEnv* env, jclass clazz, jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, "MessageQueue is not initialized."); return 0; &#125; NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper());//直接看NativeInputManager的实现 im-&gt;incStrong(0); return reinterpret_cast&lt;jint&gt;(im);&#125; 首先我们得到java层传进来的MessageQueue对象，然后通过它构造一个NativeInputManager对象，并返回给上层。我们接着看其构造 frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 12345678910111213141516171819//Native层的InputManger构造方法NativeInputManager::NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : mLooper(looper) &#123; JNIEnv* env = jniEnv(); mContextObj = env-&gt;NewGlobalRef(contextObj); mServiceObj = env-&gt;NewGlobalRef(serviceObj); &#123; AutoMutex _l(mLock); mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE; mLocked.pointerSpeed = 0; mLocked.pointerGesturesEnabled = true; mLocked.showTouches = false; &#125; sp&lt;EventHub&gt; eventHub = new EventHub(); mInputManager = new InputManager(eventHub, this, this);&#125; 这里我们主要创建两个对象，一个EventHub对象，它是用来监听输入事件，也就是输入设备产生的Input事件。另一个对象为InputManager，它以eventHub对象作为其参数构造，这个InputMangager才是真正c++层的IMS服务，NativeInputManager只能算是一个壳，它持有InputMangaer的引用罢了，真正的事情应该是在InputManager中进行的。 frameworks/base/services/input/InputManager.cpp 1234567891011121314151617//c++层真正的IMS服务类InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; //创建分派对象，用来分派Input事件 例如KeyEvent，MotionEvent mDispatcher = new InputDispatcher(dispatcherPolicy); //创建事件reader，这个是InputManger中的Input事件源，实际上它是通过eventHub得到事件的。 //同时，它和mDispatcher关联是因为需要将事件交给它来分派 mReader = new InputReader(eventHub, readerPolicy, mDispatcher); initialize();//初始化&#125;void InputManager::initialize() &#123; mReaderThread = new InputReaderThread(mReader); mDispatcherThread = new InputDispatcherThread(mDispatcher);&#125; InputManager的构造方法做了三件事： 创建InputDispatcher对象，这个对象使用来分派Input事件的 创建InputReader对象，它的主要任务从EventHub读取事件并交给InputDispatcher处理，所里在其构造中我们可以看到eventHub和mDispatcher 初始化InputManger，分别为InputReader和InputDispatcher创建线程，InputManager的主要工作就是在这两个线程中完成的。 到这里InputManager就创建完成了，但它并没有开始工作，因为线程还未跑起来，其实在我们之前SystemServer可以看到，IMS在创建好实例后还需要关联上WMS，然后设置一个Window回调后才调用start启动工作。这个start流程会调用nativeStart进行native层的InputManager来启动真正的工作。 12345678910111213141516status_t InputManager::start() &#123; status_t result = mDispatcherThread-&gt;run("InputDispatcher", PRIORITY_URGENT_DISPLAY); if (result) &#123; ALOGE("Could not start InputDispatcher thread due to error %d.", result); return result; &#125; result = mReaderThread-&gt;run("InputReader", PRIORITY_URGENT_DISPLAY); if (result) &#123; ALOGE("Could not start InputReader thread due to error %d.", result); mDispatcherThread-&gt;requestExit(); return result; &#125; return OK;&#125; 在InputManager的start中我们会启动初始化中创建的两个线程，分别用来处理读取Input事件和分派Input事件。接下来我们就从这两个线程的工作入手分析Input事件从下到上的整个流程。 输入事件在IMS中的分派 我们先看Reader线程的工作，它就是不断的通过mReader的loopOnce读取事件。所以具体的工作还是InputReader进行的，我们接下来就看InputReader的实现。 frameworks/base/services/input/InputReader.cpp 1234bool InputReaderThread::threadLoop() &#123; mReader-&gt;loopOnce(); return true;&#125; frameworks/base/services/input/InputReader.cpp 12345678910111213141516InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, const sp&lt;InputListenerInterface&gt;&amp; listener) : mContext(this), mEventHub(eventHub), mPolicy(policy), mGlobalMetaState(0), mGeneration(1), mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX), mConfigurationChangesToRefresh(0) &#123; mQueuedListener = new QueuedInputListener(listener); &#123; // acquire lock AutoMutex _l(mLock); refreshConfigurationLocked(0); updateGlobalMetaStateLocked(); &#125; // release lock&#125; 在InputReader的构造中我们传递了EventHub作为事件传递的源，还有InputDispatcher作为事件的分派者的listener，其中通过该listener构造了QueueInputListener对象，这个对象的用途后面我们再介绍。 frameworks/base/services/input/InputReader.cpp 123456789101112131415161718192021222324252627void InputReader::loopOnce() &#123; int32_t oldGeneration; int32_t timeoutMillis; bool inputDevicesChanged = false; Vector&lt;InputDeviceInfo&gt; inputDevices; …… size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock AutoMutex _l(mLock); mReaderIsAliveCondition.broadcast(); if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; &#125; …… // Flush queued events out to the listener. // This must happen outside of the lock because the listener could potentially call // back into the InputReader's methods, such as getScanCodeState, or become blocked // on another thread similarly waiting to acquire the InputReader lock thereby // resulting in a deadlock. This situation is actually quite plausible because the // listener is actually the input dispatcher, which calls into the window manager, // which occasionally calls into the input reader. mQueuedListener-&gt;flush();&#125; InputReader的线程的主要工作就是调用loopOnce，在这个方法中会通过我们在构造方法中传递的mEventHub对象来获取Input事件，结果保存在mEventBuffer,并返回count代表我们读取的事件数目，接着通过processEventsLocked进行处理，实际上这里会将读取的事件保存在一个缓冲队列中，最后调用mQueueListener的flush将事件发送出去。下面我们接着看着个流程。 frameworks/base/services/input/InputReader.cpp 12345678910111213141516171819202122232425262728293031323334353637void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; int32_t deviceId = rawEvent-&gt;deviceId; while (batchSize &lt; count) &#123; if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT || rawEvent[batchSize].deviceId != deviceId) &#123; break; &#125; batchSize += 1; &#125;#if DEBUG_RAW_EVENTS ALOGD("BatchSize: %d Count: %d", batchSize, count);#endif processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; else &#123; switch (rawEvent-&gt;type) &#123; case EventHubInterface::DEVICE_ADDED: addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::DEVICE_REMOVED: removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::FINISHED_DEVICE_SCAN: handleConfigurationChangedLocked(rawEvent-&gt;when); break; default: ALOG_ASSERT(false); // can't happen break; &#125; &#125; count -= batchSize; rawEvent += batchSize; &#125;&#125; 我们看到事件消息一开始是作为一个RawEvent对象来根据其类型分别进行处理的，最基本的设备添加移除都通过专门的方法处理，其他事件都通过processEventsForDeviceLocked进行处理。至于addDeviceLocked，它是在添加输入设备时调用，用来添加输入设备的，在里面会对设备创建相应的InputDevice对象，同时创建会创建一些InputMapper，比如KeyboardInputMapper，TouchInputMapper等，这些InputMapper都保存在mMappers的列表中，后面我们会看到输入事件会交给这些mapper来进行处理。 12345678910111213141516void InputReader::processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count) &#123; ssize_t deviceIndex = mDevices.indexOfKey(deviceId); if (deviceIndex &lt; 0) &#123; ALOGW("Discarding event for unknown deviceId %d.", deviceId); return; &#125; InputDevice* device = mDevices.valueAt(deviceIndex); if (device-&gt;isIgnored()) &#123; //ALOGD("Discarding event for ignored deviceId %d.", deviceId); return; &#125; device-&gt;process(rawEvents, count);&#125; 这一步我们通过mDevices取到对应的InputDevice,然后调用process进一步处理输入事件。 frameworks/base/services/input/InputReader.cpp 1234567891011void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123; if()&#123; …… &#125; else &#123; for (size_t i = 0; i &lt; numMappers; i++) &#123; InputMapper* mapper = mMappers[i]; mapper-&gt;process(rawEvent); &#125; &#125;&#125; 到这一步，input事件就交给Device，这里我们看看KeyboardInputMapper对键盘输入事件的处理。 frameworks/base/services/input/InputReader.cpp 123456789101112131415161718192021void KeyboardInputMapper::process(const RawEvent* rawEvent) &#123; switch (rawEvent-&gt;type) &#123; case EV_KEY: &#123; int32_t scanCode = rawEvent-&gt;code; int32_t usageCode = mCurrentHidUsage; mCurrentHidUsage = 0; if (isKeyboardOrGamepadKey(scanCode)) &#123; int32_t keyCode; uint32_t flags; if (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123; keyCode = AKEYCODE_UNKNOWN; flags = 0; &#125; processKey(rawEvent-&gt;when, rawEvent-&gt;value != 0, keyCode, scanCode, flags); &#125; break; &#125; …… &#125;&#125; 在process进一步调用processKey，表示处理按键事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode, int32_t scanCode, uint32_t policyFlags) &#123; if (down) &#123; // Rotate key codes according to orientation if needed. if (mParameters.orientationAware &amp;&amp; mParameters.hasAssociatedDisplay) &#123; keyCode = rotateKeyCode(keyCode, mOrientation); &#125; // Add key down. ssize_t keyDownIndex = findKeyDown(scanCode); if (keyDownIndex &gt;= 0) &#123; // key repeat, be sure to use same keycode as before in case of rotation keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode; &#125; else &#123; // key down if ((policyFlags &amp; POLICY_FLAG_VIRTUAL) &amp;&amp; mContext-&gt;shouldDropVirtualKey(when, getDevice(), keyCode, scanCode)) &#123; return; &#125; mKeyDowns.push(); KeyDown&amp; keyDown = mKeyDowns.editTop(); keyDown.keyCode = keyCode; keyDown.scanCode = scanCode; &#125; mDownTime = when; &#125; else &#123; // Remove key down. ssize_t keyDownIndex = findKeyDown(scanCode); if (keyDownIndex &gt;= 0) &#123; // key up, be sure to use same keycode as before in case of rotation keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode; mKeyDowns.removeAt(size_t(keyDownIndex)); &#125; else &#123; // key was not actually down ALOGI("Dropping key up from device %s because the key was not down. " "keyCode=%d, scanCode=%d", getDeviceName().string(), keyCode, scanCode); return; &#125; &#125; …… NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime); getListener()-&gt;notifyKey(&amp;args);&#125; 这里首先对按键进行适当的处理，比如按键按下时，需要根据屏幕方向对按键的code进行旋转，这么做的原因可能是因为不同屏幕方向的key code表示的意义是不同的。还有如果对按下事件，如果已经存在了，就会发送持续的发送前一次的key code，否则就是按下事件，最后需要将key事件封装为一个NotifyKeyArgs参数，这些被封装的对象都是继承自NotifyArgs通过mQueuedListener,即QueuedInputListener的notifyKey分发这次Input消息。 frameworks/base/services/input/InputListener.cpp 123void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) &#123; mArgsQueue.push(new NotifyKeyArgs(*args));&#125; 这个NotifyKey只是将封装的事件参数添加到一个参数队列mArgsQueue中，真正的发送是在flush中进行,它是在loopOnce中的最后调用的表示要将事件派发出去了。 frameworks/base/services/input/InputListener.cpp 12345678910111213void QueuedInputListener::flush() &#123; size_t count = mArgsQueue.size(); for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args; &#125; mArgsQueue.clear();&#125;void NotifyKeyArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123; listener-&gt;notifyKey(this);&#125; 在flush中实际上调用的是NotifyArgs的notify方法。在其方法中调用了Listener的notifyKey这个listener即 QueuedInputListener的mInnerListener，这个mInnerListener即是在创建QueuedInputListener时传递的参数InputDispatcher，这个就是我们的派发者对象。因为InputReader的主要任务就是将读取的Input事件交给InputDispatcher进行处理。 frameworks/base/services/input/InputDispatcher.cpp 1234567891011121314151617181920void InputDispatcher::notifyKey(const NotifyKeyArgs* args) &#123; …… bool needWake; &#123; // acquire lock mLock.lock(); …… int32_t repeatCount = 0; KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, args-&gt;keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime); needWake = enqueueInboundEventLocked(newEntry); mLock.unlock(); &#125; // release lock if (needWake) &#123; mLooper-&gt;wake(); &#125;&#125; InputDipatcher通过notifyKey来处理InputReader交给的事件，这里通过事件参数args来构造一个KeyEntry对象，并通过enqueuInboundEventLocked将其加入到一个队列中去，等待进行处理，并根据needWake来决定唤醒Looper。 frameworks/base/services/input/InputDispatcher.cpp 1234567891011121314151617181920212223242526272829bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; bool needWake = mInboundQueue.isEmpty(); mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); switch (entry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; // Optimize app switch latency. // If the application takes too long to catch up then we drop all events preceding // the app switch key. KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry); if (isAppSwitchKeyEventLocked(keyEntry)) &#123; if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123; mAppSwitchSawKeyDown = true; &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123; if (mAppSwitchSawKeyDown) &#123;#if DEBUG_APP_SWITCH ALOGD("App switch is pending!");#endif mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT; mAppSwitchSawKeyDown = false; needWake = true; &#125; &#125; &#125; break; &#125;&#125;&#125; return needWake;&#125; enqueueInboundEventLocked将新的keyEvent加入到mInboundQueue中去，如果一开始这个队列是空的，就需要唤醒Looper了表示有新的事件需要处理。当事件到来后就会触发InputDipatcher的dispatchOnce，还记得？这个方法是在InputDipatcherThread的threadloop中循环调用进行事件处理的。我们看看它的具体实现 123456789101112131415161718192021222324void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis);&#125; 这里事件的真正处理是在dispatchOnceInnerLocked中进行处理的。它会负责处理队列中的输入事件。然后通过pollOnce将事件发送出去，这是InputDispatcher的职责。下面我们看看dispatchOnceInnerLocked的具体实现。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213141516171819202122232425void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); …… if (! mPendingEvent) &#123; if (mInboundQueue.isEmpty()) &#123; …… &#125; else &#123; // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.dequeueAtHead(); traceInboundQueueLengthLocked(); &#125; …… // Get ready to dispatch the event. resetANRTimeoutsLocked();//重置ANR &#125; switch (mPendingEvent-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); …… done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; &#125; ……&#125; 这个方法首先判断mInboundQueue队列是否有事件要处理，有的话就先取出队头的事件放到mPendingEvent中，根据事件类型分别进行处理，这里我们看类型为TYPE_KEY的输入事件。然后调用dispatchKeyLocked进行处理。 12345678910111213141516171819202122bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; …… // Identify targets. Vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); if (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123; return false; &#125; setInjectionResultLocked(entry, injectionResult); if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123; return true; &#125; addMonitoringTargetsLocked(inputTargets); // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; 取出待处理的事件后通过dispatchKeyLocked进行处理，这个方法首先根据 findFocusedWindowTargetsLocked找到需要派发的目标对象inputTargets，然后通过 dispatchEventLocked进一步处理。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123; …… for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; else &#123; &#125; &#125;&#125; dispatchEventLocked方法主要是将待发送的输入事件发送给目标对象，这个目标对象是实际上为一个Connection，内部通过InputChannel构造，它是通过registerInputChannel中添加到一个mConnectionByFd的map中维护的。 123456void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; // Not splitting. Enqueue dispatch entries for the event as is. enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);&#125; prepareDispatchCycleLocked进一步调用enqueueDispatchEntriesLocked 1234567891011121314151617181920212223void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.isEmpty(); // Enqueue dispatch entries for the requested modes. enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_OUTSIDE); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection); &#125;&#125; 再接着调用startDispatchCycleLocked 1234567891011121314151617181920212223242526272829303132333435void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; …… while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125; …… &#125; …… // Re-enqueue the event on the wait queue. connection-&gt;outboundQueue.dequeue(dispatchEntry); traceOutboundQueueLengthLocked(connection); connection-&gt;waitQueue.enqueueAtTail(dispatchEntry); traceWaitQueueLengthLocked(connection); &#125;&#125; 到这里其实InputDispatcher的任务基本结束了，它已经将任务转给了具体的Connection进行处理，这个Connection即是再Dispatcher中注册的客户。下面我们分析这些Connection是如何注册到InputDispatcher的。这里我们从底层到上层追上去进行回顾整个流程 首先registerInputChannel是再NativeInputManager的registerInputChannel中调用的，而后者也应该是再Java层的InputManagerService中调用的，那么谁回去调用IMS的registerInputChannel呢？ InputChannel的注册 回顾我们之前再SystemServer中所做的事情，再IMS创建后会关联到WMS上，因为输入事件最终是要交给WMS负责分发给客户端的应用程序的。所以注册channel应该是再WMS上进行的。我们下来就看看这个注册的流程以及最终的事件是如何发布到上层的。首先我们去看那WMS的main方法 12345678910111213141516171819202122232425262728public static WindowManagerService main(final Context context, final PowerManagerService pm, final DisplayManagerService dm, final InputManagerService im, final Handler wmHandler, final boolean haveInputMethods, final boolean showBootMsgs, final boolean onlyCore) &#123; final WindowManagerService[] holder = new WindowManagerService[1]; wmHandler.runWithScissors(new Runnable() &#123; @Override public void run() &#123; holder[0] = new WindowManagerService(context, pm, dm, im, haveInputMethods, showBootMsgs, onlyCore);//创建WMS实例 &#125; &#125;, 0); return holder[0];&#125;``` Main主要负责创建WMS实例，所以我们看看其构造方法。```javaprivate WindowManagerService(Context context, PowerManagerService pm, DisplayManagerService displayManager, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) &#123; …… //WMS内部持有IMS的引用 mInputManager = inputManager; // Must be before createDisplayContentLocked. …… &#125; 在构造方法中实际上只是将IMS的实例保存在mInputManager中罢了，并没有任何注册的线索。那么注册的流程是在哪里呢？其实可以想象的到，当应用启动后，只有当界面显示出来的时候才能够接受输入事件，而且只有当前有焦点的窗口才可以对事件进行处理，而那些在任务栈中处于停止状态的窗口不对其进行处理。那么当窗口加入到WMS中时应该回去注册相应的channel用来接收事件。 12345678910111213141516171819public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; …… ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; root.setView(view, wparams, panelParentView); ……&#125; 这里我们主要看看ViewRootImpl的setView 12345678910111213141516171819202122232425262728293031323334353637383940414243public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; …… //这次layout是为接受输入事件做准备，最重要的工作就是设置当前窗口为WMS中具 有焦点的窗口 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; //为窗口创建一个Client端的InputChannel,它是用来监听Input事件的。 mInputChannel = new InputChannel(); &#125; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException("Adding window failed", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; …… if (mInputChannel != null) &#123;//前面为该window创建了InputChannel所以不为null if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue();//创建一个InputQueue mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ……&#125; 在setView中会去创建InputChannel，在这之前会调用一次requestLayout，这里的主要工作就是设置当前窗口为WMS中具有焦点的窗口，为接受输入事件做准备。那么这个InputChannel会去注册到InputDispatcher中？实际上不是的，注意这个方法还在我们的应用端。而接受InputDispather也就是IMS的输入事件的是WMS，那么事件的流程应该是IMS到WMS然后再到应用端程序。下面我们追踪mInputChannel来看看具体是怎么样的。 我们先看到mInputChannel，它的创建过程，它的构造方法是个空方法，这么说InputChannel现在在java层只是一个空壳，而真正的初始化是在native层的。接着我们看到mInputChannel被传递给了addToDisplay,这个方法将当前窗口添加到WMS中，它会通过Binder调用WMS的addWindow方法。所以我们去WMS中看看addWindow的实现 frameworks/base/services/java/com/android/server/wm/WindowManagerService.java 12345678910111213141516public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; …… if (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; String name = win.makeInputChannelName(); InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); win.setInputChannel(inputChannels[0]); inputChannels[1].transferTo(outInputChannel); mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); &#125; ……&#125; 这里的outInputChannel就是我们客户端传递的mInputChannel，这里我们看到首先我们调用InputChannel的openInputChannelPair方法打开了一对InputChannel，这一对InputChannel分别是为Client和Server端的channel,用来负责应用端以及WMS的输入事件的接受通道。其中索引为0的为服务端的，而索引为1的为客户端的。我们看到inputChannels[0]先被保存在win中，也即是WindowState中，WindowState表示当前窗口，随后通过mInputManager调用registerInputChannel注册到InputDispatcher中。 而inputchanel[1]被转换为outInputChannel作为出参传递给应用端。这里我们先分析注册到InputDispatcher的这个InputChannel，随后再分析传递到客户端的inputchannel。 首先我们分析openInputChannelPair流程。 frameworks/base/core/java/android/view/InputChannel.java 12345678910public static InputChannel[] openInputChannelPair(String name) &#123; if (name == null) &#123; throw new IllegalArgumentException("name must not be null"); &#125; if (DEBUG) &#123; Slog.d(TAG, "Opening input channel pair '" + name + "'"); &#125; return nativeOpenInputChannelPair(name);&#125; 这个方法直接调用了native层的nativeOpenInputChannelPair方法 frameworks/base/core/jni/android_view_InputChannel.cpp 1234567891011121314151617181920212223242526272829303132333435363738static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL); String8 name(nameChars); env-&gt;ReleaseStringUTFChars(nameObj, nameChars); sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); if (result) &#123; String8 message; message.appendFormat("Could not open input channel pair. status=%d", result); jniThrowRuntimeException(env, message.string()); return NULL; &#125; jobjectArray channelPair = env-&gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; jobject serverChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(serverChannel)); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; jobject clientChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(clientChannel)); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; env-&gt;SetObjectArrayElement(channelPair, 0, serverChannelObj); env-&gt;SetObjectArrayElement(channelPair, 1, clientChannelObj); return channelPair;&#125; 这个方法调用c++层的InputChannle(定义在InputTransport中)打开一对InputChannel对象，serverChannel和clientChannel，随后通过这两个对象调用android_view_input_channel_createInputChannel构造java层的InputChannel对象。 frameworks/native/libs/input/InputTransport.cpp 123456789101112131415161718192021222324252627status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE("channel '%s' ~ Could not create socket pair. errno=%d", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); String8 serverChannelName = name; serverChannelName.append(" (server)"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(" (client)"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK;&#125; 首先通过socketpair创建一对相互连接的unnamed socket，这两个socket都可以互相进行读写，相比以前的管道通信，它是全双工的通信，即一端的socket既可以读又可以写。 创建好后，通过这两个socket分别去构造两个InputChannel作为服务端和客户端的读写通道。传递好后就可以将他们传递给java层使用了，这是通过android_view_input_channel_createInputChannel实现的。 123456789101112131415static jobject android_view_InputChannel_createInputChannel(JNIEnv* env, NativeInputChannel* nativeInputChannel) &#123; jobject inputChannelObj = env-&gt;NewObject(gInputChannelClassInfo.clazz, gInputChannelClassInfo.ctor); if (inputChannelObj) &#123; android_view_InputChannel_setNativeInputChannel(env, inputChannelObj, nativeInputChannel); &#125; return inputChannelObj;&#125;static void android_view_InputChannel_setNativeInputChannel(JNIEnv* env, jobject inputChannelObj, NativeInputChannel* nativeInputChannel) &#123; env-&gt;SetIntField(inputChannelObj, gInputChannelClassInfo.mPtr, reinterpret_cast&lt;jint&gt;(nativeInputChannel));&#125; java层持有的其实是NativeInputChannel，它内部持有我们之前构造的InputChannel。 这个对象的地址会保存在java层的InputChannel的mPtr中。 创建好channel后接下来我们看看IMS是如何注册我们的服务端的InputChannel的 在之前addWindow中我们看到创建好Channel pair后就会调用IMS的registerInputChannel来注册服务端的Channel. frameworks/base/services/java/com/android/server/input/InputManagerService.java 12345678public void registerInputChannel(InputChannel inputChannel, InputWindowHandle inputWindowHandle) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException("inputChannel must not be null."); &#125; nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);&#125; frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 123456status_t NativeInputManager::registerInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel( inputChannel, inputWindowHandle, monitor);&#125; 这个mINputManager就是我们c++层的InputMnager，通过getDispatcher获取到的InputDispatcher对象就是我们在创建InputManger对象时创建的mDispatcher。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213141516171819202122232425262728status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; &#123; // acquire lock AutoMutex _l(mLock); if (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123; ALOGW("Attempted to register already registered input channel '%s'", inputChannel-&gt;getName().string()); return BAD_VALUE; &#125; sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; 这里我们通过传递进来的InputChannel先创建一个Connection对象，随后添加到一个mConnectionsByFd这个Map中去。需要注意的是在注册完成之后会去为这个描述符注册回调handleReceiveCallBack中。 123456InputDispatcher::Connection::Connection(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) : status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle), monitor(monitor), inputPublisher(inputChannel), inputPublisherBlocked(false) &#123;&#125; 这里可以看到通过InputChannel构造一个InputPublisher对象，这个InputChannel是我们服务端的Channel,它最终是给WMS使用的。还记得？在InputDispater中正是通过它的publishKeyEvent方法来发布输入事件到WMS的。 12345678910111213141516171819202122232425262728status_t InputPublisher::publishKeyEvent( uint32_t seq, int32_t deviceId, int32_t source, int32_t action, int32_t flags, int32_t keyCode, int32_t scanCode, int32_t metaState, int32_t repeatCount, nsecs_t downTime, nsecs_t eventTime) &#123; InputMessage msg; msg.header.type = InputMessage::TYPE_KEY; msg.body.key.seq = seq; msg.body.key.deviceId = deviceId; msg.body.key.source = source; msg.body.key.action = action; msg.body.key.flags = flags; msg.body.key.keyCode = keyCode; msg.body.key.scanCode = scanCode; msg.body.key.metaState = metaState; msg.body.key.repeatCount = repeatCount; msg.body.key.downTime = downTime; msg.body.key.eventTime = eventTime; return mChannel-&gt;sendMessage(&amp;msg);&#125; 在publishKeyEvent中我们通过调用InputChannel的sendMessage将事件发送出去。 123456789status_t InputChannel::sendMessage(const InputMessage* msg) &#123; size_t msgLength = msg-&gt;size(); ssize_t nWrite; do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); …… return OK;&#125; 在sendMessage中实际上我们使用的是为WMS注册InputChannel来发送的事件消息，它的接收端位于我们应用程序的另一个InputChannel。接下来我们就需要看看应用程序是如何接受这个输入事件的。 应用端输入事件的接受 在WMS的addView中我们构造了一对InputChannel，其中一个作为服务端注册到了InputDispatcher中，另一个作为结果返回给了应用端，应用端正是使用这个InputChannel来监听输入事件的。 在ViewRootImpl的setView中调用了addToDisplay后就得到了这个InputChannel,随后又使用该InputChannel构造了一个一个WindowInputEvetnReceiver对象 12345678if (mInputChannel != null) &#123;//前面为该window创建了InputChannel所以不为null if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue();//创建一个InputQueue mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());&#125; 这个WindowInputEventReceiver的实现如下 123456789101112131415161718192021final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; @Override public void onBatchedInputEventPending() &#123; scheduleConsumeBatchedInput(); &#125; @Override public void dispose() &#123; unscheduleConsumeBatchedInput(); super.dispose(); &#125;&#125; 从其实现来看它继承自InputEventReceiver，是用来接受输入事件的，其中onInputEvent重载了接受事件的方法。 123456789101112131415public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException("inputChannel must not be null"); &#125; if (looper == null) &#123; throw new IllegalArgumentException("looper must not be null"); &#125; mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open("dispose");&#125; 这里的inputChannel是客户端使用的，它会通过nativeInit进行初始化，同时这个Looper是我们的主线程的Looper。 12345678910111213141516171819202122232425262728static jint nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); if (inputChannel == NULL) &#123; jniThrowRuntimeException(env, "InputChannel is not initialized."); return 0; &#125; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, "MessageQueue is not initialized."); return 0; &#125; sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); status_t status = receiver-&gt;initialize(); if (status) &#123; String8 message; message.appendFormat("Failed to initialize input event receiver. status=%d", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jint&gt;(receiver.get());&#125; nativeInit在native层创建对应的NativeInputEventReceiver对象，并调用了initialize进行初始化,同时将该native对象作为结果返回给java层的InputEventReceiver的mReceiverPtr成员。 123456789101112NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mInputConsumer(inputChannel), mMessageQueue(messageQueue), mBatchedInputEventPending(false), mFdEvents(0) &#123;&#125;status_t NativeInputEventReceiver::initialize() &#123; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125; NativeInputEventReceiver的构造方法很简单，会通过inputchannel构造一个InputConsumer mInputConsumer，从名字来看它是一个输入事件的消费者，也就是我们客户端程序。 1234567891011void NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里将InputChannel的描述符fd取出来，然后通过主线程的Looper进行监听，当需要读取输入事件时会触发handleEVent回调。 1234567891011int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) &#123; …… if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, "handleReceiveCallback"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125; ……&#125; 随后调用consumeEvents进一步对事件进行消费 123456789101112131415161718192021222324252627status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; …… ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (status) &#123; …… return status; &#125; …… if (inputEventObj) &#123; env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); env-&gt;DeleteLocalRef(inputEventObj); &#125; else &#123; ALOGW("channel '%s' ~ Failed to obtain event object.", getInputChannelName()); skipCallbacks = true; &#125; &#125; …… &#125;&#125; 这里先调用InputConsumer的consume方法进行事件的读取，随后通过gInputReceiverClassInfo的dispatchInputEvent方法发布到java层的InputEventReceiver frameworks/native/libs/input/InputTransport.cpp 123456789101112131415161718192021222324252627282930313233status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; *outSeq = 0; *outEvent = NULL; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; if (mMsgDeferred) &#123; // mMsg contains a valid input message from the previous call to consume // that has not yet been processed. mMsgDeferred = false; &#125; else &#123; // Receive a fresh message. status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); …… &#125; switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; KeyEvent* keyEvent = factory-&gt;createKeyEvent(); if (!keyEvent) return NO_MEMORY; initializeKeyEvent(keyEvent, &amp;mMsg); *outSeq = mMsg.body.key.seq; *outEvent = keyEvent; break; &#125; …… &#125; return OK;&#125; 这里首先通过Client端的InputChannel来读取服务发送的输入事件，然后将结果保存在outEvent中 frameworks/native/libs/input/InputTransport.cpp 12345678status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; nRead = ::recv(mFd, msg, sizeof(InputMessage), MSG_DONTWAIT); &#125; while (nRead == -1 &amp;&amp; errno == EINTR); …… return OK;&#125; 接下来就到java层看看我们如何接受输入事件的，刚才说过，输入事件最终是通过InputEventReceiver的dispatchInputEvent接受的。 123456// Called from native code.@SuppressWarnings("unused")private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; 在dispatchInputEvent中是通过onInputEvent处理的，它真正的工作是它的子类WindowInputEventReceiver中进行处理的，它是在ViewRootImpl中定义的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; @Override public void onBatchedInputEventPending() &#123; scheduleConsumeBatchedInput(); &#125; @Override public void dispose() &#123; unscheduleConsumeBatchedInput(); super.dispose(); &#125;&#125;void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; mPendingInputEventCount += 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); if (processImmediately) &#123; doProcessInputEvents(); &#125; else &#123; scheduleProcessInputEvents(); &#125;&#125; 这里先将待处理的事件入队，并调用doProcessInputEvents进一步处理。 123456789101112131415161718192021222324void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); deliverInputEvent(q); &#125; // We are done processing all input events that we can process right now // so we can clear the pending flag immediately. if (mProcessInputEventsScheduled) &#123; mProcessInputEventsScheduled = false; mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS); &#125;&#125; doProcessInputEvents的处理逻辑很简单，如果队列中有待处理的事件就循环调用deliverInputEvent进行处理。 123456789101112131415161718192021222324252627private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "deliverInputEvent"); try &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125;public final void deliver(QueuedInputEvent q) &#123; if ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123; forward(q); &#125; else if (shouldDropInputEvent(q)) &#123; finish(q, false); &#125; else &#123; apply(q, onProcess(q)); &#125;&#125; 在deliverInputEvent中，事件被交给一个InputStage进行处理，这个InputState实际上是一个职责链，事件沿着职责链进行传递，当某个Stage需要处理的话就调用apply来调用onProcess进行事件的消费。这个职责链是在ViewRootImpl的setview中创建的。 123456789101112131415// Set up the input pipeline.CharSequence counterSuffix = attrs.getTitle();InputStage syntheticInputStage = new SyntheticInputStage();InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage);InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);mFirstInputStage = nativePreImeStage;mFirstPostImeInputStage = earlyPostImeStage; 对于处理键盘输入事件，我们会交给viewPostImeStage进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final class ViewPostImeInputStage extends InputStage &#123; public ViewPostImeInputStage(InputStage next) &#123; super(next); &#125; @Override protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; // If delivering a new non-key event, make sure the window is // now allowed to start updating. handleDispatchDoneAnimating(); final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q); &#125; else &#123; //处理触摸事件 return processGenericMotionEvent(q); &#125; &#125; &#125; private int processKeyEvent(QueuedInputEvent q) &#123; final KeyEvent event = (KeyEvent)q.mEvent; if (event.getAction() != KeyEvent.ACTION_UP) &#123; // If delivering a new key event, make sure the window is // now allowed to start updating. handleDispatchDoneAnimating(); &#125; // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) &#123; return FINISH_HANDLED; &#125; …… &#125; return FORWARD; &#125; private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; if (mView.dispatchPointerEvent(event)) &#123; return FINISH_HANDLED; &#125; return FORWARD; &#125; …… private int processGenericMotionEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; // Deliver the event to the view. if (mView.dispatchGenericMotionEvent(event)) &#123; return FINISH_HANDLED; &#125; return FORWARD; &#125;&#125; 在onProcess中如果事件类型为keyevent会交给processKeyEvent进行处理，后者会将事件投递给mView，即我们的DecorView，这样输入事件就可以view树上进行传递了。关于在view树中的处理流程，我们在另一篇中再做介绍。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKHttp的缓存策略]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-library-okhttp3-3-src-md%2F</url>
    <content type="text"><![CDATA[OKhttp的缓存是通过CacheInterceptor这个拦截器实现的，它的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public final class CacheInterceptor implements Interceptor &#123; final InternalCache cache; public CacheInterceptor(InternalCache cache) &#123; this.cache = cache; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null;//先从缓存中取出Request对应的Response，可能为null long now = System.currentTimeMillis(); //通过Request和Response构造CacheStrategy CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //缓存监控 if (cache != null) &#123; cache.trackResponse(strategy); &#125; //cacheCandidate无效，关闭它 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. //networkReqeust和cacheResponse都为null表示禁止使用网络且缓存不够用，这是返回504响应 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. //缓存有效的情况，不需要进行网络请求 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse))//配置Response的cacheResponse，但并不需要持有body所以这里剔除掉body .build(); &#125; Response networkResponse = null; try &#123; //进行网络请求 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. //如果缓存也存在 if (cacheResponse != null) &#123; //响应304码表示服务器认为资源未改变 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response;//返回cacheResponse的内容 &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //网络请求的Response Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; //将最新的请求存储到缓存中 if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;//返回结果 &#125; //将Response的body剔除 private static Response stripBody(Response response) &#123; return response != null &amp;&amp; response.body() != null ? response.newBuilder().body(null).build() : response; &#125; ……&#125; CacheInterceptor内部持有一个InternalCache，它负责缓存的存取，而CacheStrategy用来控制缓存的存取，决定什么时候用缓存，什么时候使用网络进行请求。它是通过其内部的networkRequest和cacheResponse决定的，当networkRequest的值为null表示缓存有效不进行网络请求，而当cacheResponse为null是表示缓存失效或者未命中，需要进行网络请求。当它们都不为null，则根据响应结果来判断缓存是否失效。 CacehStrategy通过Request和候选的缓存进行构造的，我们看看它的内部是如何实现的 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public final class CacheStrategy &#123; /** The request to send on the network, or null if this call doesn't use the network. */ public final @Nullable Request networkRequest; /** The cached response to return or validate; or null if this call doesn't use a cache. */ public final @Nullable Response cacheResponse; public static class Factory &#123; final long nowMillis; final Request request; final Response cacheResponse; /** The server's time when the cached response was served, if known. */ private Date servedDate; private String servedDateString; /** The last modified date of the cached response, if known. */ private Date lastModified; private String lastModifiedString; /** * The expiration date of the cached response, if known. If both this field and the max age are * set, the max age is preferred. */ private Date expires; /** * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was * first initiated. */ private long sentRequestMillis; /** * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was * first received. */ private long receivedResponseMillis; /** Etag of the cached response. */ private String etag; /** Age of the cached response. */ private int ageSeconds = -1; public Factory(long nowMillis, Request request, Response cacheResponse) &#123; this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse;//将候选的缓存保存下来 //从候选的缓存中解析出一些信息 if (cacheResponse != null) &#123; this.sentRequestMillis = cacheResponse.sentRequestAtMillis(); this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis(); Headers headers = cacheResponse.headers();//获取到缓存响应头部 for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; String fieldName = headers.name(i); String value = headers.value(i); if ("Date".equalsIgnoreCase(fieldName)) &#123; servedDate = HttpDate.parse(value);//得到服务器的日期 servedDateString = value; &#125; else if ("Expires".equalsIgnoreCase(fieldName)) &#123; expires = HttpDate.parse(value);//得到失效时间 &#125; else if ("Last-Modified".equalsIgnoreCase(fieldName)) &#123; lastModified = HttpDate.parse(value);//得到资源上次修改的时间 lastModifiedString = value; &#125; else if ("ETag".equalsIgnoreCase(fieldName)) &#123; etag = value;//得到资源对应的ETag &#125; else if ("Age".equalsIgnoreCase(fieldName)) &#123; ageSeconds = HttpHeaders.parseSeconds(value, -1); &#125; &#125; &#125; &#125; /** * Returns a strategy to satisfy &#123;@code request&#125; using the a cached response &#123;@code response&#125;. */ public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123; // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); &#125; return candidate; &#125; /** Returns a strategy to use assuming the request can use the network. */ private CacheStrategy getCandidate() &#123; // No cached response. //没有命中的缓存，使用网络进行请求 if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; // Drop the cached response if it's missing a required handshake. //如果是https，但是缓存中缺少了握手信息，同样进行网络请求 if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; // If this response shouldn't have been stored, it should never be used // as a response source. This check should be redundant as long as the // persistence store is well-behaved and the rules are constant. //如果该缓存是不应该被缓存的，则同样进行网络请求 if (!isCacheable(cacheResponse, request)) &#123; return new CacheStrategy(request, null); &#125; //得到请求头部的CacheControl CacheControl requestCaching = request.cacheControl(); //如果不进行缓存则直接进行网络请求 if (requestCaching.noCache() || hasConditions(request)) &#123; return new CacheStrategy(request, null); &#125; long ageMillis = cacheResponseAge(); long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) &#123; freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; CacheControl responseCaching = cacheResponse.cacheControl(); if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //可以缓存且缓存有效，不需要进行网络请求 if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\""); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\""); &#125; return new CacheStrategy(null, builder.build()); &#125; // Find a condition to add to the request. If the condition is satisfied, the response body // will not be transmitted. String conditionName; String conditionValue; if (etag != null) &#123;//etag不为null conditionName = "If-None-Match"; conditionValue = etag;//将If-None-Match配合etag进行请求，服务端可以基于ETag判断资源是否匹配。 &#125; else if (lastModified != null) &#123;//在请求头部添加If-Modified-Since结合lastModifiedString判断资源是否被修改，如果未修改返回304 conditionName = "If-Modified-Since"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123;//在请求头部添加If-Modified-Since conditionName = "If-Modified-Since"; conditionValue = servedDateString; &#125; else &#123; return new CacheStrategy(request, null); // No condition! Make a regular request. &#125; Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse); &#125; &#125;&#125; 在getCandidate方法中实现了构造CacheStrategy实例的逻辑，总的来说： 一 使用网络进行请求的包括，即networkRequest != null ： 缓存未命中 https请求缺少handshake信息 request指定的CacheControl不进行缓存 缓存的Response头部没有缓存相关的信息如ETag，If-None-Match，If-Modified-Since等 二 使用缓存请求的情况,即cacheResponse != null 缓存有效，未超过其失效时间 三 networkRequest != null 且 cacheResponse != null 缓存是否有效，要根据响应结果来判断 缓存的写入 在CacheInterceptor内部它对Response进行缓存的实现如下： 123456789101112131415if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125;&#125; 写入缓存是在Cache类中实现的，它内部持有一个internalCache，它正是CacheInterceptor拦截器内部的缓存引用。 这里我们先看cache put方法的实现 1234567891011121314151617181920212223242526272829303132333435363738@Nullable CacheRequest put(Response response) &#123; String requestMethod = response.request().method();//获取requestMethod //判断是否为失效的缓存 if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; //只对GET响应进行缓存 if (!requestMethod.equals("GET")) &#123; // Don't cache non-GET responses. We're technically allowed to cache // HEAD requests and some POST requests, but the complexity of doing // so is high and the benefit is low. return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; //构造Entry Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; //得到DiskLruCache.Editor 可以看到OkHttp缓存是通过DiskLruCache实现的 editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; entry.writeTo(editor);//写入缓存 return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125;&#125; 关于DiskLruCache将在另外的篇章中介绍。]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp源码分析(二)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-library-okhttp3-2-src%2F</url>
    <content type="text"><![CDATA[OkHttp的请求过程 在上一篇中我们大概了解了OkHttp大体的执行过程，本篇将进一步介绍OkHttp请求的具体过程，这设计到部分拦截器的具体细节。 ####建立连接 关于内置的拦截器将会在其他篇章中分别做介绍，这里只介绍涉及到具体的Http请求过程的拦截器，它们是ConnectInterceptor和CallServerInterceptor分别负责连接的建立和Http请求的发起。我们先看ConnectInterceptor 1234567891011121314151617181920public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation();//得到一个StreamAllocation // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals("GET"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);//分配一个Stream RealConnection connection = streamAllocation.connection();//建立一个连接 return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; ConnectInterceptor的最终目的是和服务器建立连接，它首先从拦截器链中得到的StreamAllocation，但是拦截器链在初始时streamAllocation并未创建，那么它是何时创建，在哪里创建呢？可以确定的是它一定是在拦截器链ConnectInterceptor之前的拦截器中进行初始化的，通过寻找发现它是在RetryAndFollowUpInterceptor中创建的。 1234567@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); …… &#125; 这个StreamAllocation到底是做什么的呢？我们看看它的具体实现 123456789101112131415161718192021222324252627282930313233343536373839/** * This class coordinates the relationship between three entities: * * &lt;ul&gt; * &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are * potentially slow to establish so it is necessary to be able to cancel a connection * currently being connected. * &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on * connections. Each connection has its own allocation limit, which defines how many * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream * at a time, HTTP/2 typically carry multiple. * &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and * its follow up requests. We prefer to keep all streams of a single call on the same * connection for better behavior and locality. * &lt;/ul&gt; ... */public final class StreamAllocation &#123; public final Address address; private Route route; private final ConnectionPool connectionPool; private final Object callStackTrace; // State guarded by connectionPool. private final RouteSelector routeSelector; private int refusedStreamCount; private RealConnection connection; private boolean released; private boolean canceled; private HttpCodec codec; public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) &#123; this.connectionPool = connectionPool; this.address = address; this.routeSelector = new RouteSelector(address, routeDatabase()); this.callStackTrace = callStackTrace; &#125; ……&#125; 从注释中我们可以了解到StreamAllocation的作用，它负责协调Connections，Streams以及Calls三者的关系，Connnections是代表了连接远程服务的物理socket连接,Streams是依赖于Connnections逻辑上的Http Request/Response请求对。每个connections都有它的分配上限，这个决定了connections可以并发支持的streams数目，Calls是streams逻辑上的序列，它实际上是一组Request。清楚了这些，再看其构造方法，其中ConnectionPool想必就是负责物理连接的，Address描述了我们需要连接的远端服务，实际上它是通过url来得到的。 接下来要为一次请求创建一个Stream，这个Stream是逻辑上的Request/Response对，通过StreamAllocation的newStream方法创建。 12345678910111213141516171819public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123; int connectTimeout = client.connectTimeoutMillis();//超时连接时间 int readTimeout = client.readTimeoutMillis();//读超时时间 int writeTimeout = client.writeTimeoutMillis();//写超时时间 boolean connectionRetryEnabled = client.retryOnConnectionFailure();//是否支持重连 try &#123; RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);//为Stream找到一个可用的Connection HttpCodec resultCodec = resultConnection.newCodec(client, this);//取到HttpCodec synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; newStream方法为stream找到一个可用的连接，然后通过连接的newCodec得到一个HttpCodec，它负责对Http的Request进行编码以及对Response进行解码。接着再看findHealthyConnection 1234567891011121314151617181920 private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; noNewStreams(); continue; &#125; return candidate; &#125;&#125; 通过一个while循环直到找到一个health RealConnection. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123;//对连接池加锁 ... // Attempt to use an already-allocated connection. //重用已经分配的连接 RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; // Attempt to get a connection from the pool. //尝试从连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; return connection; &#125; selectedRoute = route; &#125; // If we need a route, make one. This is a blocking operation. //需要选择一个路由 if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); &#125; RealConnection result; synchronized (connectionPool) &#123; if (canceled) throw new IOException("Canceled"); // Now that we have an IP address, make another attempt at getting a connection from the pool. // This could match due to connection coalescing. Internal.instance.get(connectionPool, address, this, selectedRoute);//从连接池中取到一个匹配路由的连接 if (connection != null) return connection; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute);//创建一个连接 acquire(result);//保存在connection中 &#125; // Do TCP + TLS handshakes. This is a blocking operation. //建立TCP和TCL的连接，这是一个阻塞操作 result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; // Pool the connection. Internal.instance.put(connectionPool, result);//存放在连接池中 // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); return result;//返回连接&#125; findConnection负责从连接池中取出一个匹配的RealConnection,如果未找到就创建一个新的，并通过connect建立和远端服务的连接。这个是通过RealConnection的connect方法来实现的。 123456789101112131415161718192021222324public final class RealConnection extends Http2Connection.Listener implements Connection &#123; private static final String NPE_THROW_WITH_NULL = "throw with null exception"; private final ConnectionPool connectionPool; private final Route route; // The fields below are initialized by connect() and never reassigned. /** The low-level TCP socket. */ private Socket rawSocket;//底层 TCP的socket /** * The application layer socket. Either an &#123;@link SSLSocket&#125; layered over &#123;@link #rawSocket&#125;, or * &#123;@link #rawSocket&#125; itself if this connection does not use SSL. */ private Socket socket;//应用层的socket要么是基于rawSocket之上的SSLSocket，要么是rawSocket自己，表示没有用到SSL private Handshake handshake; private Protocol protocol; private Http2Connection http2Connection; private BufferedSource source; private BufferedSink sink;//sink和source是让这个Connection可以以流的形式和服务器进行交互 public boolean noNewStreams;//如果为true，则不能在该连接上创建新的Stream public int allocationLimit = 1;//分配流的数量上限，默认为1&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void connect( int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) &#123; if (protocol != null) throw new IllegalStateException("already connected"); RouteException routeException = null; List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs(); ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication not enabled for client")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication to " + host + " not permitted by network security policy")); &#125; &#125; while (true) &#123; try &#123; if (route.requiresTunnel()) &#123;//需要建立隧道连接 connectTunnel(connectTimeout, readTimeout, writeTimeout); &#125; else &#123;//创建Socket connectSocket(connectTimeout, readTimeout); &#125; establishProtocol(connectionSpecSelector);//建立协议 break; &#125; catch (IOException e) &#123; closeQuietly(socket); closeQuietly(rawSocket); socket = null; rawSocket = null; source = null; sink = null; handshake = null; protocol = null; http2Connection = null; if (routeException == null) &#123; routeException = new RouteException(e); &#125; else &#123; routeException.addConnectException(e); &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException; &#125; &#125; &#125; if (http2Connection != null) &#123; synchronized (connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams(); &#125; &#125;&#125; connect负责连接的建立过程，这里通过while循环来创建连接，保证连接能够创建成功，在循环中首先根据requiresTunnel判读是否创建隧道连接，它需要满足 123public boolean requiresTunnel() &#123; return address.sslSocketFactory != null &amp;&amp; proxy.type() == Proxy.Type.HTTP;&#125; 即对于设置了HTTP代理，且安全的连接。这时候需要请求HTTP代理建立一个到目标HTTP服务器的隧道连接，客户端和HTTP代理建立TCP连接。这里我们只关心不设置代理的情况，即创建连接通过connectSocket来完成。 123456789101112131415161718192021222324252627282930313233 /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */ private void connectSocket(int connectTimeout, int readTimeout) throws IOException &#123; Proxy proxy = route.proxy(); Address address = route.address(); rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);//创建socket rawSocket.setSoTimeout(readTimeout); try &#123; //建立连接，这里我们关注AndroidPlatform下的connectSocket Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; catch (ConnectException e) &#123; ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress()); ce.initCause(e); throw ce; &#125; // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try &#123; //得到输入输出流 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; catch (NullPointerException npe) &#123; if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123; throw new IOException(npe); &#125; &#125;&#125; 这里我们看AndroidPlatform的connectSocket 123456789101112131415@Override public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout) throws IOException &#123; try &#123; socket.connect(address, connectTimeout);//创建socket TCP连接 &#125; catch (AssertionError e) &#123; if (Util.isAndroidGetsocknameError(e)) throw new IOException(e); throw e; &#125; catch (SecurityException e) &#123; // Before android 4.3, socket.connect could throw a SecurityException // if opening a socket resulted in an EACCES error. IOException ioException = new IOException("Exception in connect"); ioException.initCause(e); throw ioException; &#125;&#125; connectSocket实际就是通过创建的rawSocket来建立TCP连接，连接建立成功后，需要进一步建立协议，它主要为数据的加密传输做一些初始化，比如TLS握手，HTTP/2的协议协商等。 123456789101112131415161718 private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; if (route.address().sslSocketFactory() == null) &#123;//http/1.1 protocol = Protocol.HTTP_1_1; socket = rawSocket; return; &#125; connectTls(connectionSpecSelector);//连接到TLS if (protocol == Protocol.HTTP_2) &#123; socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream. http2Connection = new Http2Connection.Builder(true) .socket(socket, route.address().url().host(), source, sink) .listener(this) .build(); http2Connection.start(); &#125;&#125; 未配置sslScoketFactor就默认是HTTP/1.1，这时候socket和rawSocket是同一个，否则需要为安全请求建立TLS连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; Address address = route.address(); SSLSocketFactory sslSocketFactory = address.sslSocketFactory(); boolean success = false; SSLSocket sslSocket = null; try &#123; // Create the wrapper over the connected socket. sslSocket = (SSLSocket) sslSocketFactory.createSocket( rawSocket, address.url().host(), address.url().port(), true /* autoClose */);//基于rawSocket创建SSLSocket // Configure the socket's ciphers, TLS versions, and extensions. //配置SSLSocket ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket); if (connectionSpec.supportsTlsExtensions()) &#123; //配置扩展参数 Platform.get().configureTlsExtensions( sslSocket, address.url().host(), address.protocols()); &#125; // Force handshake. This can throw! sslSocket.startHandshake();//开始握手 Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());//获取握手信息 // Verify that the socket's certificates are acceptable for the target host. //验证socket证书是否适用于目标主机 if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) &#123; X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0); throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:" + "\n certificate: " + CertificatePinner.pin(cert) + "\n DN: " + cert.getSubjectDN().getName() + "\n subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert)); &#125; // Check that the certificate pinner is satisfied by the certificates presented //验证证书pinner address.certificatePinner().check(address.url().host(), unverifiedHandshake.peerCertificates()); // Success! Save the handshake and the ALPN protocol. String maybeProtocol = connectionSpec.supportsTlsExtensions() ? Platform.get().getSelectedProtocol(sslSocket) : null; socket = sslSocket; //得到输入输出流 source = Okio.buffer(Okio.source(socket)); sink = Okio.buffer(Okio.sink(socket)); handshake = unverifiedHandshake; protocol = maybeProtocol != null ? Protocol.get(maybeProtocol) : Protocol.HTTP_1_1; success = true; &#125; catch (AssertionError e) &#123; if (Util.isAndroidGetsocknameError(e)) throw new IOException(e); throw e; &#125; finally &#123; if (sslSocket != null) &#123; Platform.get().afterHandshake(sslSocket); &#125; if (!success) &#123; closeQuietly(sslSocket); &#125; &#125;&#125; TLS连接是对原始的TCP连接的一个封装，以提供TLS握手，及数据收发过程中的加密解密等功能。它通过SSLSocket来描述，建立一个TLS连接的步骤为： 配置SSLSocket 配置扩展参数 开始握手 获取握手信息 验证证书信息 创建用于执行IO的BufferedSource和BufferedSink等，并保存握手信息及所选择的协议 建立好连接后，在StreamAllocation的newStream中接下来就是创建HttpCodec返回，HttpCodec负责Request和Response的编解码。这里我们看看它的创建过程 1234567891011public HttpCodec newCodec( OkHttpClient client, StreamAllocation streamAllocation) throws SocketException &#123; if (http2Connection != null) &#123;//对于HTTP/2.0 return new Http2Codec(client, streamAllocation, http2Connection); &#125; else &#123; socket.setSoTimeout(client.readTimeoutMillis()); source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS); sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS); return new Http1Codec(client, streamAllocation, source, sink); &#125;&#125; newCodec会根据HTTP的版本来创建Http2Codec或者Http1Codec对象。 ###发起请求 建立好连接后，就需要发起http请求了，这个是在CallServerInterceptor这个拦截器中进行的，我们看看它的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream();//获取HttpCodec，它用来描述一个http流 StreamAllocation streamAllocation = realChain.streamAllocation();//获取StreamAllocation RealConnection connection = (RealConnection) realChain.connection();//获取到RealConnection，它代表了到服务器的连接 Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request);//发起Http请求 Response.Builder responseBuilder = null; //检测是否有请求Body if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100 // Continue" response before transmitting the request body. If we don't get that, return what // we did get (such as a 4xx response) without ever transmitting the request body. if ("100-continue".equalsIgnoreCase(request.header("Expect"))) &#123; httpCodec.flushRequest(); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // Write the request body if the "Expect: 100-continue" expectation was met. Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; else if (!connection.isMultiplexed()) &#123; // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from // being reused. Otherwise we're still obligated to transmit the request body to leave the // connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); //创建负责请求的Builder if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false); &#125; //得到响应Response Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if ("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength()); &#125; return response;&#125; 可以看到整个Http请求和响应的过程是通过HttpCodec来进行操作的，首先通过writeRequestHeaders发起http请求，然后创建Response.Builder对象，负责接收响应。]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp源码分析(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-library-okhttp3-1-src%2F</url>
    <content type="text"><![CDATA[请求方式 OkHttp支持同步和异步的Http请求 同步和异步请求的代码如下： 123456789101112131415161718192021222324252627282930private final static OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(8, TimeUnit.SECONDS) .readTimeout(8,TimeUnit.SECONDS) .writeTimeout(8,TimeUnit.SECONDS) .build();//同步的请求Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute();if (response.isSuccessful()) &#123; return response.body().string();&#125; else &#123; throw new IOException("Unexpected code " + response);&#125;//异步的请求Request request = new Request.Builder().url(url).build();Call call = client.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; System.out.println(e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; return response.body().string(); &#125; &#125;&#125;); OkHttpClient使用Builder模式来为其配置众多的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static final class Builder &#123; Dispatcher dispatcher; @Nullable Proxy proxy; List&lt;Protocol&gt; protocols; List&lt;ConnectionSpec&gt; connectionSpecs; final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;(); EventListener.Factory eventListenerFactory; ProxySelector proxySelector; CookieJar cookieJar; @Nullable Cache cache; @Nullable InternalCache internalCache; SocketFactory socketFactory; @Nullable SSLSocketFactory sslSocketFactory; @Nullable CertificateChainCleaner certificateChainCleaner; HostnameVerifier hostnameVerifier; CertificatePinner certificatePinner; Authenticator proxyAuthenticator; Authenticator authenticator; ConnectionPool connectionPool; Dns dns; boolean followSslRedirects; boolean followRedirects; boolean retryOnConnectionFailure; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; …… //Builder的参数默认的给出一些参数的设置 public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; &#125; public OkHttpClient build() &#123; return new OkHttpClient(this); &#125;&#125; OkHttpClient通过build创建完实例后，就包含了众多的参数 创建请求 用户的请求是通过一个Request来描述的，它一般的构造形式如下： 1234567891011121314151617181920212223Request request = new Request.Builder().url(url).build();public final class Request &#123; …… public static class Builder &#123; private HttpUrl url;//请求的URL private String method;//请求的方法 如GET POST等 private Headers.Builder headers;//请求的HTTP头部 private RequestBody body;//请求的body private Object tag; public Builder() &#123; this.method = "GET"; this.headers = new Headers.Builder(); &#125; &#125; public Request build() &#123; if (url == null) throw new IllegalStateException("url == null"); return new Request(this); &#125;&#125; 同样的Request也是通过Builder来创建构造实例的，它只是封装了HTTP请求需要的一些信息。Okhttp通过newCall来为我们的请求创建一个Call对象，这个对象负责为Request服务来完成一次Http请求过程 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request);&#125; 发起请求 接着我们看看RealCall的实现 123456789101112131415161718192021222324//同步的请求@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(false);//执行请求过程 if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125;//异步的请求void enqueue(Callback responseCallback, boolean forWebSocket) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));&#125; 同步请求是通过RealCall的execute发起的，它的实现也很简单，首先置executed为true表示Call已经发起执行，若再次使用该Call发起请求会抛出Already Executed异常随后通过OkHttpClient配置的dispatcher执行executed，这个Dispatcher是请求的派发策略，说白了就是发起的请求，无论是异步的还是同步都要通过该Dispatcher进行一些设置。对于同步的请求，dispatcher会将该请求记录到一个同步请求队列中，请求完成后通过finished方法将其移除，而对于异步的请求Dispatcher会将该请求任务添加到异步请求队列中，并通过线程池来发起真正的请求。这里需要注意对于异步请求它的Call为AsyncCall。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; /** Executes calls. Created lazily. */ private ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();//等待队列 /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();//异步队列 /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();//同步队列 public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; /** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);//将请求添加到同步队列中 &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ //同步请求使用该方法 synchronized void finished(Call call) &#123; if (!runningSyncCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); &#125; synchronized void enqueue(AsyncCall call) &#123; //将异步请求添加到异步队列中，可以看到OKhttp同时支持64个异步请求的执行，对同一个Host的请求最大同时支持5个 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call);//否则添加到等待队列中 &#125; &#125; //异步请求调用 synchronized void finished(AsyncCall call) &#123; if (!runningAsyncCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!"); promoteCalls();//每次异步请求调用完成后会通过该方法将等待队列中的请求移到异步请求队列中发起请求 &#125; …… &#125; 那么对于同步请求来说，在RealCall的execute方法中真正执行请求过程的必然是通过getResponseWithInterceptorChain来实现的，通过方法名称我们也能知道。而异步请求是在AysnCall的回调中进行的，我们看看AsynCall的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class NamedRunnable implements Runnable &#123; protected final String name; …… @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute();//回调 &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125;final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; private final boolean forWebSocket; …… @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125;&#125; 对于异步请求来说，在ASyncCall的回调方法中同样是通过getResponseWithInterceptorChain(forWebSocket)来完成HTTP的请求过程，随后通过responseCallback将请求结果返回给上层应用 最后通过dispatcher的finished方法将Call从异步队列中移除。 请求过程 前面我们知道了无论是同步还是异步的请求最终都是通过getResponseWithInterceptorChain方法来完成请求过程的，接下来我们将分析请求过程的具体实现 12345678910111213141516171819202122final class RealCall implements Call &#123; ... Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; ...&#125; 从getResponseWithInterceptorChain中我们并没有看到实际的请求过程是如何进行的，它内部维护了一个拦截器列表，这个列表首先添加OkHttpClient配置的应用拦截器，然后添加内置的几个拦截器，最后添加网络拦截器和CallServerInterceptor拦截器，然后通过这个拦截器列表构造一个RealInterceptorChain并调用processd来执行请求过程。那么拦截器在这之间到底起到什么作用？事实上，一个拦截器可以看做是一个中间件，它负责拦截我们的请求和响应，并对请求和响应做一些额外的工作，比如为我们请求添加日志，寻找路由，制定连接失败的重试策略为，为响应执行缓存策略等等。总的来说是OkHttp加入拦截器的目的是为了丰富和拓展请求过程使其支持各式各样的需求。 拦截器 为了了解请求的整个过程，我们需要明白拦截器是如何工作的，首先所有的拦截器都是需要实现Interceptor接口的， 123456789101112131415public interface Interceptor &#123; Response intercept(Chain chain) throws IOException; interface Chain &#123;//拦截器链的接口 Request request(); Response proceed(Request request) throws IOException; /** * Returns the connection the request will be executed on. This is only available in the chains * of network interceptors; for application interceptors this is always null. */ @Nullable Connection connection(); &#125;&#125; 为了了解拦截器的执行过程，我们需要看看RealInterceptroChain的实现 12345678910111213141516171819202122232425262728293031323334353637public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors;//持有的拦截器链 private final int index;//当前链中工作的拦截器索引 @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; //拦截器链的处理方法 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; // Call the next interceptor in the chain. //在链中使用下个拦截器 RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index);//得到当前的拦截器 Response response = interceptor.intercept(next);//执行当前拦截器的方法，这里将下个拦截器传递给它 …… return response; &#125;&#125; 事实上拦截器链的请求过程类似于网络协议栈对于应用数据的处理过程，这里为了解析其工作原理，我们假设有拦截器链A-&gt;B-&gt;C-&gt;D这个链在OKHttp中的表示就是RealInterceptorChain 它实现了拦截器链的proceed方法，主要用来遍历执行拦截器链，开始我们拦截器链的索引为0，也就是从拦截器A开始调用其intercept方法执行拦截器，需要注意的是intercept方法的参数为拦截器链，在A的intercept方法中会通过传递的chain再调用proceed方法，这样每次进入proceed方法就可以inex+1指定链中的下一个拦截器。一直到拦截器D，D不需要再执行chain的proceed方法，因为它是最后一个拦截器，后面没有拦截器了。在OkHttp中拦截器链的最后一个拦截器是CallServerInterceptor，它是真正的执行http请求的地方。]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ActivityManagerService-ActivityRecord、TaskRecord、ActivityStack的作用及关系]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-ams-src%2F</url>
    <content type="text"><![CDATA[ActivityManagerService ActivityManagerService(简称AMS)是Android系统最核心的Binder服务之一，从名称上看好像它只是Activity的管理者，但实际上AMS管理和维护着系统四大组件(Activity,Service,Broadcast,ContentProvider)的相关工作，这个任务非常重要而且异常复杂，在KK中单是AMS一个类的源码行数就高达一万六千多行，可见其内部的任务有多庞大。在这之中，AMS对于Activity的管理任务最为复杂，这可能也是它为什么叫ActivityManagerService的原因吧。AMS对于activity的管理实际上通过三个类来体现，它们分别是ActivityRecord，TaskRecord以及ActivityStack，把握和理解它们之间的关系对于我们理解AMS的工作将会有很大的帮助。因此本篇将会介绍这三者在AMS中的联系和作用。 ActivityRecord ActivityRecord是应用层Activity组件在AMS中的代表，每一个在应用中启动的Activity，在AMS中都有一个ActivityRecord实例来与之对应，这个ActivityRecord伴随着Activity的启动而创建，也伴随着Activity的终止而销毁。 类结构说明 关于ActivityRecord类，它只是一个简单的类，并没有继承任何其他父类，在它内部存储的都是一些关于Activity组件的相关信息，所以类结构比较简单，下面我将列出它的一些成员进行介绍： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * An entry in the history stack, representing an activity. */final class ActivityRecord &#123; final ActivityManagerService service; // owner final IApplicationToken.Stub appToken; // window manager token final ActivityInfo info; // all about me final int launchedFromUid; // always the uid who started the activity. final String launchedFromPackage; // always the package who started the activity. final int userId; // Which user is this running for? final Intent intent; // the original intent that generated us final ComponentName realActivity; // the intent component, or target of an alias. final String shortComponentName; // the short component name of the intent final String resolvedType; // as per original caller; final String packageName; // the package implementing intent's component final String processName; // process where this component wants to run final String taskAffinity; // as per ActivityInfo.taskAffinity ... int labelRes; // the label information from the package mgr. int icon; // resource identifier of activity's icon. int logo; // resource identifier of activity's logo. int theme; // resource identifier of activity's theme. int realTheme; // actual theme resource we will use, never 0. int windowFlags; // custom window flags for preview window. TaskRecord task; // the task this is in. Configuration configuration; // configuration activity was last running in CompatibilityInfo compat;// last used compatibility mode ActivityRecord resultTo; // who started this entry, so will get our reply final String resultWho; // additional identifier for use by resultTo. final int requestCode; // code given by requester (resultTo) HashSet&lt;WeakReference&lt;PendingIntentRecord&gt;&gt; pendingResults; // all pending intents for this act ArrayList&lt;Intent&gt; newIntents; // any pending new intents for single-top mode ActivityOptions pendingOptions; // most recently given options HashSet&lt;ConnectionRecord&gt; connections; // All ConnectionRecord we hold UriPermissionOwner uriPermissions; // current special URI access perms. ProcessRecord app; // if non-null, hosting application ActivityState state; // current state we are in ... int launchMode; // the launch mode activity attribute.&#125; 可以看出ActivityRecord包含了很多信息，我们简单描述下： appToken ：这是一个Binder，而且是Server端的实体，Token即令牌，它一般作为一个标识使用，这个appToken用来在WindowManagerService端标识这个AcitvityRecord，token的实现如下 1234567891011121314151617181920212223242526272829static class Token extends IApplicationToken.Stub &#123; final WeakReference&lt;ActivityRecord&gt; weakActivity; Token(ActivityRecord activity) &#123; weakActivity = new WeakReference&lt;ActivityRecord&gt;(activity); &#125; @Override public void windowsDrawn() &#123; ActivityRecord activity = weakActivity.get(); if (activity != null) &#123; activity.windowsDrawn(); &#125; &#125; @Override public void windowsVisible() &#123; ActivityRecord activity = weakActivity.get(); if (activity != null) &#123; activity.windowsVisible(); &#125; &#125; @Override public void windowsGone() &#123; ActivityRecord activity = weakActivity.get(); if (activity != null) &#123; activity.windowsGone(); &#125; &#125; ... &#125; 可以看到它实际上是一个Token，实现了自IApplicationToken.Stub的方法，内部有个弱引用指向包含它的ActivityRecord实例，从实现来看，appkToken实际上有两个作用，在WMS端标记一个ActivityRecord，同时可以通过该token和AMS进行通信。 2. launchedFromUid和launchedFromPackage 启动该activity的应用uid和包名，比如我们从launcher启动的应用activity，这个对应的就是launcher的uid和包名 3. intent 和 ComponentName intent是启动时候传递的意图对象，ComponentName标记了启动的acitivity组件。 4. packageName和processName 分别代表了activity所属应用的包名和进程名 5. taskAffinity 标记了activity的亲属性，默认情况下为包名，这个成员和该activity所属TaskRecord有关，后面我们具体介绍。 6. logo 和 theme 这些是activity所使用的logo和theme资源标记。 7. task 应用所属TaskRecord,后面介绍。 8. resultTo和requestCode，resultTo也是一个ActivityRecord,它是当前ActivityRecord对应的activity要返回和回复的activity，我们通过startActivityForResult启动一个activity时，往往需要接受来自于启动的activity的返回值，这个resultTo就是负责处理返回值的activity对应的ActivityRecord 9. app 它是一个ProcessRecord,用于描述当前activity所在应用的进程 10. state 它是一个AcitivityState枚举,用于描述当前activity的状态，这些状态被AMS内部使用，ActivityState的定义如下： 1234567891011enum ActivityState &#123; INITIALIZING, RESUMED, PAUSING, PAUSED, STOPPING, STOPPED, FINISHING, DESTROYING, DESTROYED&#125; launchMode activity的启动模式 ActivityRecord的创建 123456789101112final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options, boolean componentSpecified, ActivityRecord[] outActivity) &#123; ... //为activity创建ActivityRecord ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, this); ... &#125; AcitivtyRecord是在启动activity时候创建的，这里具体是在ActivityStackSupervisor中，关于ActivityStackSupervisor后面再介绍。我们看看ActivityRecord的构造方法中 1234567891011121314151617181920212223242526272829303132333435363738ActivityRecord(ActivityManagerService _service, ProcessRecord _caller, int _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType, ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo, String _resultWho, int _reqCode, boolean _componentSpecified, ActivityStackSupervisor supervisor) &#123; service = _service; appToken = new Token(this);//创建了appToken 这个token用来标记activity，token内部持有该ActivityRecord的弱引用 info = aInfo; launchedFromUid = _launchedFromUid; launchedFromPackage = _launchedFromPackage; userId = UserHandle.getUserId(aInfo.applicationInfo.uid); intent = _intent; shortComponentName = _intent.getComponent().flattenToShortString(); resolvedType = _resolvedType; componentSpecified = _componentSpecified; configuration = _configuration; resultTo = _resultTo; resultWho = _resultWho; requestCode = _reqCode; state = ActivityState.INITIALIZING; frontOfTask = false; launchFailed = false; stopped = false; delayedResume = false; finishing = false; configDestroy = false; keysPaused = false; inHistory = false; visible = true; waitingVisible = false; nowVisible = false; thumbnailNeeded = false; idle = false; hasBeenLaunched = false; mStackSupervisor = supervisor; ...&#125; 在构造方法中创建了ActivityRecord的appToken，关于appToken我们前面已经做了介绍。初始的activity状态为ActivityState.INITIALIZING，这里的visible标记的是activity在WMS端对应的window是否需要显示，在构造ActivityRecord时表示我们要启动activity了，这时候也就需要WMS为我们显示窗口，置true。nowVisible表示的是activity当前的窗口显示状态，这时候activity还在创建过程中，还未显示出来，置false。 TaskRecord TaskRecord即任务栈，或者叫返回栈(back Stack)，Task实际上是指执行一个特定任务时和用户进行交互的一组activity，什么意思呢？比如我们为了完成用微信发送消息这个任务，而需要打开首页的联系人列表，然后选择一个联系人进入聊天界面发送消息，这两个activity就可以说是一个Task，但如果我们说要发送图片，那么还会去打开选择照片的activity，这时候Task就是三个activity，所以说Task是一个动态的概念，但不管怎么样，我们总成为它是一组activity的集合，这个集合在AMS中就是TaskRecord，它和数据结构中的Stack结构类似，也是先进后出，当我们打开App中的一个activity1时，它对应的ActivityRecord被添加到TaskRecord中，再在activit1中打开第二个页面activity2，在activity2中打开activity3，同样它们的ActivityRecord也会被添加到TaskRecord，当我们按下返回键，activity3先从TaskRecord中弹出来，依次类推，当task中所有的activity被弹出后，这个task也就销毁了。最终它的结构如下图所示： Task切换 一般情况下，我们可以将打开的一个app看做是一个TaskRecord，当我们先后打开app A的两个页面A和B，这时候在其对应的TaskRecord中就有两个ActivityRecord的记录，当我们按下home键后，然后打开另一个app B的C和D页面，这时候app A的TaskRecord就到了后台中，它内部的两个activity此时都处于停止状态，而app B的TaskRecord此时处于前台和用户交互的状态，它的TaskRecord中也有两个ActivityRecord的记录，如果我们再按下home键，点击app A,这时候我们发现app A停留在B页面，也就是说app A的TaskRecord又作为一个整体从后台切换到了前台，它的状态和之前是一样的。系统可以同时管理多个后台的TaskRecord，但是如果用户打开的太多app在后台中，系统可能会回收一部分。 打开多个app时，AMS中就存在了多个TaskRecord，我们可以在这些TaskRecord之间进行切换，当我打开Email应用后可以在编辑Email的过程中打开相册应用来选择图片，选择完成后可以继续回到Email中编辑邮件。这个是Task切换带来的便利。 启动模式launchMode Android管理activity的方式是在同一个Task中使用先进后出的栈管理方式，默认情况下，我们创建一个Activity就会在TaskRecord中有一个实例，但有些时候我们可能希望当启动一个activity的时候使用TaskRecord中已经存在的实例或者当我们启动一个activity时需要将它放置在单独的一个TaskRecord之中，这时候就需要我们为启动的activity设置启动模式(launchMode)了，所以说launchMode是和TaskRecord相关联的。 有四种不同的启动模式： standard，这个即是Android默认的启动模式，每打开一个Activity就创建一个实例到Task中，同一个Activity在Task中可以有多个实例。 singleTop，如果一个activity的实例已经在Task栈的顶部，那么当再次打开这个activity时会复用这个实例而不再创建一个新的实例，同时通过onNewIntent传递给这个实例Intent。比如Task已经有四个activityA-&gt;B-&gt;C-&gt;D,D在Task顶部，那么再次打开D页面时，Task依然是A-&gt;B-&gt;C-&gt;D，而在Standard模式下将会是A-&gt;B-&gt;C-D-&gt;D singleTask，这个是说一个activity的实例在Task只能有一个实例，如果一个activity实例已经在Task中存在，Android系统会直接把Intent路由到Task中存在的Activity实例对象上，会通过调用onNewIntent()方法处理，而非创建一个新的Activity实例对象。并且会把在它之上的其它Activity清理掉。但是如果实例不存在Task中，此时系统将会为比较调用方activity和被调用方activity的taskAffnity，如果一致就将该activity创建一个实例，并加入到已存在的Task中，如果不一致，就为该activity创建一个新的Task，此时activity是作为Task的root activity的。事实上，Task的taskAffinity正是由Task的root activity决定的。 singleInstance，如果设置了该模式，那么在Task中只能有一个该activity的实例。 启动模式不仅可以在AndroidManifest中进行设定，同样的我们可以使用Intent Flags进行设定,一些常见的Flags可以更方便和灵活的处理activity和Task的关系： FLAG_ACTIVITY_NEW_TASK ，这个标记同singleTask的处理方式 FLAG_ACTIVITY_SINGLE_TOP，这个标记同singleTop的处理方式 FLAG_ACTIVITY_CLEAR_TOP，如果activity的实例已经在当前Task中，那么再启动时，将会将其之上的activity实例都销毁掉。比如Task A-&gt;B-&gt;C-&gt;D,如果在D中启动B添加了该标记，那么会将C和C都从Task销毁掉，如果此时B是默认的启动模式，那么会将B的实例也销毁，并重新创建一个实例添加到Task顶部，如果我们不想它重新创建，可以配合FLAG_ACTIVITY_SINGLE_TOP使用，这样复用顶部的B实例并触发onNewIntent。 FLAG_ACTIVITY_REORDER_TO_FRONT，新启动的Activity将会被放到它所属task的顶部，例如，当Task A-&gt;B-&gt;C-&gt;D，如果D启动B使用了这个标记，B将会排在这个task的最上面，也即现在Task的顺序变成了A,C,D,B。 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 这个标记将会在TASK重置时清理对应的Activity，比如Task当前为A-&gt;B，A启动B添加了该标记，那么当切换到Home再打开该应用后Task变为A，B被清理。这个其实是在Task中设置了一个还原点，当Task重置时将Task恢复到指定的还原点。 另外在 AndroidManifest的中也可以设置和Task相关属性，下面我们看看几种： android:allowTaskReparenting 这个属性定义的是activity具有reparent Task的能力，即标记一个Activity实例在当前应用退居后台后，是否能从启动它的那个Task移动到有共同TaskAffinity的Task，“true”表示可以移动，“false”表示它必须呆在当前应用的task中，默认值为false。下面通过一个例子说明这种情况： 比如App A 有一个Activity:MainActivity，App B有两个Activity:BMainActivity和SecondActivity，其中SecondActivity定义了该属性为true，当我们在App A中的MainActivity中启动App B的SecondActivity后，此时A的Task为MainActivity-&gt;SecondActivity，注意此时MainActivity和SecondActivity的TaskAffinity并不是相同的，他们为各自的包名。如果此时按Home键回到Launcher，再启动App B后，会发现此时的页面是SecondActivity，也就是说SecondActivity从原来App A的Task移动到了和他TaskAffinity相同的Task中即App B的Task。 android:clearTaskOnLaunch 如果设置了这个属性为true，每次用户重新启动这个应用时，都只会看到Root Activity，task中的其他Activity都会被清除出栈。这个属性也只对Root Activity有效。 android:alwaysRetainTaskState 这个属性是让Task保持原来的状态，true表示保持，false不能够保持，此属性也只对Root Activity有效，一般情况下，如果Task切换到后台后太久系统会对Task进行清理，除了Root Activity其他Activity都会被清理。但如果设置了该属性为true，则可以保持上次操作的界面。 android:noHistory 这个属性设置为true后，则Activity将不会被记录到Task的history列表中，那么就是说，这个Activity不可见，那么它实际上就和销毁了一样，因为AMS没有它的相关信息。 TaskRecord的实现 了解了Task的相关知识，接下来我们看看它是如何在AMS中实现的。 12345678910111213141516171819202122232425262728293031323334353637final class TaskRecord extends ThumbnailHolder &#123; final int taskId; // Unique identifier for this task. //Task栈的比唯一标志 final String affinity; // The affinity name for this task, or null. Intent intent; // The original intent that started the task. Intent affinityIntent; // Intent of affinity-moved activity that started this task. ComponentName origActivity; // The non-alias activity component of the intent. ComponentName realActivity; // The actual activity component that started the task. int numActivities; // Current number of activities in this task. long lastActiveTime; // Last time this task was active, including sleep. boolean rootWasReset; // True if the intent at the root of the task had // the FLAG_ACTIVITY_RESET_TASK_IF_NEEDED flag. boolean askedCompatMode;// Have asked the user about compat mode for this task. String stringName; // caching of toString() result. int userId; // user for which this task was created int numFullscreen; // Number of fullscreen activities. /** List of all activities in the task arranged in history order */ final ArrayList&lt;ActivityRecord&gt; mActivities = new ArrayList&lt;ActivityRecord&gt;();//以历史序排列的所有activities /** Current stack */ ActivityStack stack; /** Takes on same set of values as ActivityRecord.mActivityType */ private int mTaskType; /** Launch the home activity when leaving this task. */ boolean mOnTopOfHome = false; TaskRecord(int _taskId, ActivityInfo info, Intent _intent) &#123; taskId = _taskId; affinity = info.taskAffinity; setIntent(_intent, info); &#125; ...&#125; 在AMS中，Task是通过TaskRecord类来描述的，它的成员相对ActivityRecord要少很多，这里我们介绍下： taskId，这个是TaskRecord的一个唯一标记 affnity，亲属性的名称，同一个Task的ativity有相同的taskAffinity,它是由Task的Root Activity的taskAffinity决定的。 Intent，启动这个Task的源activity对应的Intent，也即是启动root activity的Intent。 numActivities，这个是当前Task中的activity数目。 numFullscreen 全屏activity的个数 mActivities 维护的ActivityRecord实例，这个代表的就是Activity，可见TaskRecord栈结构是通过ArrayList来体现的。 stack ，所属的ActivityStack，关于ActivityStack我们后面介绍 TaskRecord的创建 一般情况下，在启动App的第一个activity时，AMS为其创建一个TaskRecord任务栈，当然启动后也可能创建新的TaskRecord,比如我们启动singleTask的Activity，而且为该Activity指定了和包名不同的taskAffinity，这时候也会为该activity创建一个新的TaskRecord，所有一个App是可能有多个TaskRecord存在的，这取决于应用的使用场景和需求。 我们按照分析的逻辑看看AMS中是如何实现为TaskRecord创建的。 12345678910111213141516171819202122232425262728final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; boolean addingToTask = false; TaskRecord reuseTask = null; ... ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); ... if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; ... if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, true), null, true);//创建新的taskRecord &#125; &#125; &#125;&#125; 当启动模式设定为singleTask后我们通过findTaskLocked来为启动的Activity寻找TaskRecord，如果找到则返回它顶部的Activity对应的ActivityRecord。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ActivityRecord findTaskLocked(ActivityRecord r) &#123; if (DEBUG_TASKS) Slog.d(TAG, "Looking for task of " + r); for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (!r.isApplicationActivity() &amp;&amp; !stack.isHomeStack()) &#123; if (DEBUG_TASKS) Slog.d(TAG, "Skipping stack: " + stack); continue; &#125; final ActivityRecord ar = stack.findTaskLocked(r); if (ar != null) &#123; return ar; &#125; &#125; if (DEBUG_TASKS) Slog.d(TAG, "No task found"); return null;&#125;/** * Returns the top activity in any existing task matching the given * Intent. Returns null if no such task is found. */ActivityRecord findTaskLocked(ActivityRecord target) &#123; Intent intent = target.intent;//要启动Activity的Intent ActivityInfo info = target.info; ComponentName cls = intent.getComponent(); if (info.targetActivity != null) &#123; cls = new ComponentName(info.packageName, info.targetActivity); &#125; final int userId = UserHandle.getUserId(info.applicationInfo.uid); if (DEBUG_TASKS) Slog.d(TAG, "Looking for task of " + target + " in " + this); for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;//遍历TaskRecord final TaskRecord task = mTaskHistory.get(taskNdx); if (task.userId != userId) &#123; // Looking for a different task. if (DEBUG_TASKS) Slog.d(TAG, "Skipping " + task + ": different user"); continue; &#125; final ActivityRecord r = task.getTopActivity();//获取taskRecord顶部的activity if (r == null || r.finishing || r.userId != userId || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; if (DEBUG_TASKS) Slog.d(TAG, "Skipping " + task + ": mismatch root " + r); continue; &#125; if (DEBUG_TASKS) Slog.d(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString() + "/aff=" + r.task.affinity + " to new cls=" + intent.getComponent().flattenToShortString() + "/aff=" + info.taskAffinity); if (task.affinity != null) &#123;//首先根据亲属性taskAffinity匹配，相等的就是匹配的 if (task.affinity.equals(info.taskAffinity)) &#123; if (DEBUG_TASKS) Slog.d(TAG, "Found matching affinity!"); return r; &#125; &#125; else if (task.intent != null &amp;&amp; task.intent.getComponent().equals(cls)) &#123;//否则启动的就是栈顶activity if (DEBUG_TASKS) Slog.d(TAG, "Found matching class!"); //dump(); if (DEBUG_TASKS) Slog.d(TAG, "For Intent " + intent + " bringing to top: " + r.intent); return r; &#125; else if (task.affinityIntent != null &amp;&amp; task.affinityIntent.getComponent().equals(cls)) &#123; if (DEBUG_TASKS) Slog.d(TAG, "Found matching class!"); //dump(); if (DEBUG_TASKS) Slog.d(TAG, "For Intent " + intent + " bringing to top: " + r.intent); return r; &#125; else if (DEBUG_TASKS) &#123; Slog.d(TAG, "Not a match: " + task); &#125; &#125; return null;//未找到就返回null&#125; 在findTaskLocked中，我们会比较要启动的Activity和Task的affinity，如果匹配就返回TaskRecord顶部的ActivityRecord，如果最终没找到则返回null。如果返回值intentActivity为null，那么 addingToTask和reuseTask都不会设置，这时候会通过createTaskRecord创建TaskRecord并设置到ActivityRecord之中。 TaskRecord的复用 事实上大多数情况，Activity都会复用TaskRecord,也就是说Activity会添加到相同的TaskRecord之中，除了应用第一次启动或者taskAffinity不同之外。如果上一步中通过findTaskLocked返回的intentActivity不为null，这表示我们为启动模式为singleTask的activity找到了一个可复用的TaskRecord。 123456789101112131415161718192021222324252627final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123;//找到对应TaskRecord栈顶的ActivityRecord if (r.task == null) &#123; r.task = intentActivity.task;//设置r的TaskRecord为该Task &#125; &#125; &#125; if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; ... &#125; else if (sourceRecord != null) &#123;//针对其他启动模式的复用TaskRecord TaskRecord sourceTask = sourceRecord.task; targetStack = sourceTask.stack; ... r.setTask(sourceTask, sourceRecord.thumbHolder, false); &#125;&#125; ActivityStack ActivityStack的说法听起来很容易和我们常说的任务栈混淆，很多人可能看到它的第一个反应是它就是我们的任务栈，然而并非如此，我们知道系统中可能同时有多个Task，一般前台就一个Task和用户进行交互，而后台中可能有多个Task存在，前后台的Task可以进行切换，AMS为了方便的管理这些Task而引入了ActivityStack，在ActivityStack内部通过ArrayList维护了一组TaskRecord。一般来说Launcher的Task属于单独的一个ActivityStack，称为Home Activity Stack，System UI如rencentActivity的Task属于一个单独ActivityStack，其他App的Task属于另一个ActivityStack。 结构 下面我们看看ActivityStack的结构 12345678910111213141516171819202122232425262728293031323334353637383940final class ActivityStack &#123; ... final ActivityManagerService mService;//AMS引用 final WindowManagerService mWindowManager;//WMS引用 /** * The back history of all previous (and possibly still * running) activities. It contains #TaskRecord objects. */ private ArrayList&lt;TaskRecord&gt; mTaskHistory = new ArrayList&lt;TaskRecord&gt;(); /** * List of running activities, sorted by recent usage. * The first entry in the list is the least recently used. * It contains HistoryRecord objects. */ final ArrayList&lt;ActivityRecord&gt; mLRUActivities = new ArrayList&lt;ActivityRecord&gt;(); ... /** * This is the last activity that we put into the paused state. This is * used to determine if we need to do an activity transition while sleeping, * when we normally hold the top activity paused. */ ActivityRecord mLastPausedActivity = null;//记录了上次切换ActivityStack后被暂停的Activity /** * Current activity that is resumed, or null if there is none. */ ActivityRecord mResumedActivity = null;//当前正在运行的activity，可以为null表示当前运行的activity不在该ActivityStack中 final int mStackId; /** Run all ActivityStacks through this */ final ActivityStackSupervisor mStackSupervisor;//ActivityStack的管家 ...&#125; 从其成员中我们可以看出ActivityStack维护了一组TaskRecord，以及一组最近使用的Activities，还有上次切换ActivityStack被暂停的Activity，和TaskRecord类似，多个ActivityStack同样是可以进行切换的，比如我们从桌面Launcher点击app后，会从Launcher所在的ActivityStack切换到app所在的ActivityStack，mResumedActivity表示正在运行的activity，它也可以是null，当为null时表示当前运行的Activity不在该ActivityStack。同样的，在ActivityStack中通过mStackId来唯一的标识一个ActivityStack。 明白了ActivityStack的概念和用途，我们看看ASM是如何管理它的。在AMS中通过ActivityStackSupervisor来管理这些ActivityStack，从而间接的管理着TaskRecord，在ActivityStackSupervisor内部通过mHomeStack和mStacks管理着所有ActivityStack，其中mHomeStack是Launcher的TaskRecord所在的ActivityStack，而mStacks是其他的ActivityStack,它是一个ArrayList。 1234567891011121314151617181920212223242526272829public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; ... /** Run all ActivityStacks through this */ ActivityStackSupervisor mStackSupervisor; ... //在SystemServer启动时候 调用该main方法 public static final Context main(int factoryTest) &#123; ... ActivityManagerService m = thr.mService; mSelf = m; ActivityThread at = ActivityThread.systemMain(); mSystemThread = at;//创建AMS的ActivityThread Context context = at.getSystemContext(); context.setTheme(android.R.style.Theme_Holo);//系统默认的context主题 m.mContext = context; m.mFactoryTest = factoryTest; m.mIntentFirewall = new IntentFirewall(m.new IntentFirewallInterface()); m.mStackSupervisor = new ActivityStackSupervisor(m, context, thr.mLooper);//创建ActivityStack管家 m.mBatteryStatsService.publish(context); m.mUsageStatsService.publish(context); m.mAppOpsService.publish(context); ... return context; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public final class ActivityStackSupervisor &#123; final ActivityManagerService mService; /** Identifier counter for all ActivityStacks */ private int mLastStackId = HOME_STACK_ID; /** Task identifier that activities are currently being started in. Incremented each time a * new task is created. */ private int mCurTaskId = 0; /** The current user */ private int mCurrentUser; /** The stack containing the launcher app */ private ActivityStack mHomeStack; /** The non-home stack currently receiving input or launching the next activity. If home is * in front then mHomeStack overrides mFocusedStack. * DO NOT ACCESS DIRECTLY - It may be null, use getFocusedStack() */ private ActivityStack mFocusedStack; /** All the non-launcher stacks */ private ArrayList&lt;ActivityStack&gt; mStacks = new ArrayList&lt;ActivityStack&gt;(); /** List of activities that are waiting for a new activity to become visible before completing * whatever operation they are supposed to do. */ final ArrayList&lt;ActivityRecord&gt; mWaitingVisibleActivities = new ArrayList&lt;ActivityRecord&gt;(); /** List of activities that are ready to be stopped, but waiting for the next activity to * settle down before doing so. */ final ArrayList&lt;ActivityRecord&gt; mStoppingActivities = new ArrayList&lt;ActivityRecord&gt;(); /** List of activities that are ready to be finished, but waiting for the previous activity to * settle down before doing so. It contains ActivityRecord objects. */ final ArrayList&lt;ActivityRecord&gt; mFinishingActivities = new ArrayList&lt;ActivityRecord&gt;(); /** List of activities that are in the process of going to sleep. */ final ArrayList&lt;ActivityRecord&gt; mGoingToSleepActivities = new ArrayList&lt;ActivityRecord&gt;(); ...&#125; mLastStackId是所有ActivityStack的计数，这个在创建ActivityStack使用来计算stackId mCurTaskId 指当前前台的ActivityStatck对应的stackId mHomeStack 这个是launcher的TaskRecord所在的ActivityStack。 mStacks 所有非Launcher的ActivityStack。这是一个ArrayList，因为非Launcher的ActivityStack可能有多个。 除了以上成员，ActivityStackSupervisor还维护着多组ActivityRecord的集合，这些分别用来记录那些等待显示，或者正在停止或销毁的Activity。 创建过程 同样的ActivityStack也是按需创建的 1234567891011final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; ... if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; targetStack = adjustStackFocus(r); &#125; ... &#125; 实际上ActivityStack的创建时在Launcher启动时候进行的，而且是在系统启动后启动的第一个app，这个app在启动第一个Activity的时候在AMS还未有非Launcher的ActivityStack，所以需要创建一个。后面的App启动时就会找到这个ActivityStack。创建时通过ActivityStackSupervisor的adjustStackFocus方法，这个方法为要启动的Acitivity寻找前台的ActivityStack,即mFocusedStack。 12345678910111213141516171819202122232425262728293031323334353637383940414243//frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javaActivityStack adjustStackFocus(ActivityRecord r) &#123; final TaskRecord task = r.task; if (r.isApplicationActivity() || (task != null &amp;&amp; task.isApplicationTask())) &#123; if (task != null) &#123; final ActivityStack taskStack = task.stack; if (mFocusedStack != taskStack) &#123; if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: Setting focused stack to r=" + r + " task=" + task); mFocusedStack = taskStack.isHomeStack() ? null : taskStack; &#125; else &#123; if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: Focused stack already=" + mFocusedStack); &#125; return taskStack; &#125; //如果已经有一个Focused stack直接返回即可 if (mFocusedStack != null) &#123; if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: Have a focused stack=" + mFocusedStack); return mFocusedStack; &#125; for (int stackNdx = mStacks.size() - 1; stackNdx &gt; 0; --stackNdx) &#123; ActivityStack stack = mStacks.get(stackNdx); if (!stack.isHomeStack()) &#123; if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: Setting focused stack=" + stack); mFocusedStack = stack; return mFocusedStack; &#125; &#125; //如果没有Focused Stack就创建一个 // Time to create the first app stack for this user. int stackId = mService.createStack(-1, HOME_STACK_ID, StackBox.TASK_STACK_GOES_OVER, 1.0f); if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: New stack r=" + r + " stackId=" + stackId); mFocusedStack = getStack(stackId); return mFocusedStack; &#125; return mHomeStack;&#125; 在adjustStackFocus方法中，对于应用Task，如果ActivityRecord对应的TaskRecord所属的ActivityStack不是当前的mFocusedStack，则将其所属的ActivityStack作为mFoucnedStack返回则直接返回，否则如果此时TaskRecord还未创建，如果mFocusedStack已经不为null，则直接返回，否则会从当前的mStacks找到一个非Home Stack作为mFocusedStack返回，如果以上都不满足，则为当前系统创建一个ActivityStack作为mFocusedStack返回。这是通过调用AMS的createStack方法来完成的结果返回stackId。 1234567891011121314151617181920 @Overridepublic int createStack(int taskId, int relativeStackBoxId, int position, float weight) &#123; enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "createStack()"); if (DEBUG_STACK) Slog.d(TAG, "createStack: taskId=" + taskId + " relStackBoxId=" + relativeStackBoxId + " position=" + position + " weight=" + weight); synchronized (this) &#123; long ident = Binder.clearCallingIdentity(); try &#123; int stackId = mStackSupervisor.createStack(); mWindowManager.createStack(stackId, relativeStackBoxId, position, weight); if (taskId &gt; 0) &#123; moveTaskToStack(taskId, stackId, true); &#125; return stackId; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125;&#125; createStack是作为AMS的Binder接口提供给使用者的，这里会进一步通过ActivityStackSupervisor的createStack方法创建。 123456789101112int createStack() &#123; while (true) &#123; if (++mLastStackId &lt;= HOME_STACK_ID) &#123; mLastStackId = HOME_STACK_ID + 1; &#125; if (getStack(mLastStackId) == null) &#123; break; &#125; &#125; mStacks.add(new ActivityStack(mService, mContext, mLooper, mLastStackId)); return mLastStackId;&#125; 通过mLaskStackId来计算要创建的ActivityStack对应的id，然后将新创建的实例添加到mStacks中。 Task切换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; ... if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; // If bring to front is requested, and no result is requested, and // we can find a task that was started with this same // component, then instead of launching bring that one to the front. if (r.resultTo == null) &#123; // See if there is a task to bring to the front. If this is // a SINGLE_INSTANCE activity, there can be one and only one // instance of it in the history, and it is always in its own // unique task, so we do a special search. ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123;//找到对应TaskRecord栈顶的ActivityRecord if (r.task == null) &#123; r.task = intentActivity.task;//设置r的TaskRecord为该Task &#125; targetStack = intentActivity.task.stack;//设置ActivityStack为该Stack ... // If the target task is not in the front, then we need // to bring it to the front... except... well, with // SINGLE_TASK_LAUNCH it's not entirely clear. We'd like // to have the same behavior as if a new instance was // being started, which means not bringing it to the front // if the caller is not itself in the front. final ActivityStack lastStack = getLastStack(); ActivityRecord curTop = lastStack == null? null : lastStack.topRunningNonDelayedActivityLocked(notTop);//取到它顶部的ActivityRecord if (curTop != null &amp;&amp; (curTop.task != intentActivity.task || curTop.task != lastStack.topTask())) &#123;//比较当前的task和复用的task 如果不是同一个就需要将复用的task移动到前端 r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; // We really do want to push this one into the // user's face, right now. movedHome = true; targetStack.moveTaskToFrontLocked(intentActivity.task, r, options); ... &#125; &#125; &#125; &#125; &#125; ...&#125; Task的切换同样是在startActivityUncheckedLocked中进行的，首先我们通过findTaskLocked为要启动的activity寻找一个合适的TaskRecord，通过initActivity标识，找到后这个TaskRecord就是要切换到前台的Task，通过getLastStack取到上次切换的ActivityStack，然后取到它顶部的ActivityRecord，对于Launcher启动来说，这个就是非Launcher Stack，它顶部的Task可能不是initAcitivty标识的那个，因为可能之前我们启动的app的TaskRecord和它是不同的，即curTop.task != intentActivity.task，那么这时候我们需要为r设置Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT，同时通过moveTaskToFrontLocked将Task移动到ActivityStack的顶部。 123456789101112131415161718final void moveTaskToFrontLocked(TaskRecord tr, ActivityRecord reason, Bundle options) &#123; final int numTasks = mTaskHistory.size();//task的数目 final int index = mTaskHistory.indexOf(tr);//当前tr在Stack中的位置 ... mStackSupervisor.moveHomeStack(isHomeStack()); // Shift all activities with this task up to the top // of the stack, keeping them in the same internal order. insertTaskAtTop(tr);//移动Task到Stack顶部 ... mWindowManager.moveTaskToTop(tr.taskId); mStackSupervisor.resumeTopActivitiesLocked(); ...&#125; moveTaskToFrontLocked通过insertTaskAtTop将TaskRecord移动到顶部 1234567891011121314151617181920212223private void insertTaskAtTop(TaskRecord task) &#123; // If this is being moved to the top by another activity or being launched from the home // activity, set mOnTopOfHome accordingly. ActivityStack lastStack = mStackSupervisor.getLastStack(); final boolean fromHome = lastStack == null ? true : lastStack.isHomeStack(); if (!isHomeStack() &amp;&amp; (fromHome || topTask() != task)) &#123; task.mOnTopOfHome = fromHome; &#125; mTaskHistory.remove(task);//先删除 // Now put task at top. int stackNdx = mTaskHistory.size(); if (task.userId != mCurrentUser) &#123;//push非当前用户task到当前task的后面 // Put non-current user tasks below current user tasks. while (--stackNdx &gt;= 0) &#123; if (mTaskHistory.get(stackNdx).userId != mCurrentUser) &#123; break; &#125; &#125; ++stackNdx; &#125; mTaskHistory.add(stackNdx, task);&#125; insertTaskAtTop先从mTaskHistory中删除该TaskRecord,然后计算添加的位置stackNdx，最后添加到mTaskHistory中，这里最顶部的Task一般存放在最末尾。 总结 从以上的分析中，我们知道了ActivityRecord、TaskRecord以及ActivityStack之间的关系及作用，它们之间的组织关系实际上是包含的关系，即AcitivtyStack包含了TaskRecord的集合，TaskRecord包含着ActivityRecord的集合，同时反向的，ActivityRecord中记录了它所属的TaskRecord，TaskRecord记录着它所属的ActivityStack。他们三者贯穿AMS管理Activity的整个逻辑处理，其中ActivityRecord是Activity组件在AMS中的存在的形式，它和Activity实例是一一对应的关系(注意这里描述的是实例)，TaskRecord用于描述Task,即一组Activity，这组Activity以栈的形式组织起来，每个启动的Activity即ActivityRecord都应该要有所属的TaskRecord。ActivityStack是系统中用于管理TaskRecord的，系统中可能有多组ActivityStack，大体可以分为Launcher ActivityStack和非Launcher ActivityStack，我们启动的App对应的TaskRecord由非Launcher ActivityStack管理，它是在系统启动第一个app时创建的。 以上都是个人的理解,有描述不当的地方，烦请不吝赐教~ 参考 Understand Tasks and Back Stack https://developer.android.com/guide/components/activities/tasks-and-back-stack AOSP]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 的内存管理]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-memory-mgr%2F</url>
    <content type="text"><![CDATA[前述 在移动设备中，内存(RAM)显 Android 内存管理 查看应用的内存情况 通过下面的adb命令可以查看应用的内存使用状况 adb shell dumpsys meminfo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647** MEMINFO in pid 26929 [com.yujian.testsharedb] ** Pss Private Private SwapPss Heap Heap Heap Total Dirty Clean Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ ------ Native Heap 13307 13200 0 0 28672 20904 7767 Dalvik Heap 822 808 0 0 5069 973 4096 Dalvik Other 1204 1204 0 0 Stack 56 56 0 0 Ashmem 2 0 0 0 Gfx dev 3198 1672 500 0 Other dev 8 0 8 0 .so mmap 9086 308 7664 0 .jar mmap 60 60 0 0 .apk mmap 2367 2304 8 0 .ttf mmap 30 0 4 0 .dex mmap 7878 8 6264 0 .oat mmap 173 0 88 0 .art mmap 4664 3872 476 0 Other mmap 9 4 0 0 Unknown 808 804 0 0 TOTAL 43672 24300 15012 0 33741 21877 11863 App Summary Pss(KB) ------ Java Heap: 5156 Native Heap: 13200 Code: 16708 Stack: 56 Graphics: 2172 Private Other: 2020 System: 4360 TOTAL: 43672 TOTAL SWAP PSS: 0 Objects Views: 16 ViewRootImpl: 1 AppContexts: 4 Activities: 1 Assets: 14 AssetManagers: 3 Local Binders: 10 Proxy Binders: 18 Parcel memory: 3 Parcel count: 14 Death Recipients: 0 OpenSSL Sockets: 0 WebViews: 0 SQL MEMORY_USED: 0 PAGECACHE_OVERFLOW: 0 MALLOC_SIZE: 0 Private（Clean和Dirty的）：应用进程单独使用的内存，代表着系统杀死你的进程后可以实际回收的内存总量。通常需要特别关注其中更为昂贵的dirty部分，它不仅只被你的进程使用而且会持续占用内存而不能被从内存中置换出存储。申请的全部Dalvik和本地heap内存都是Dirty的，和Zygote共享的Dalvik和本地heap内存也都是Dirty的。 Dalvik Heap：Dalvik虚拟机使用的内存，包含dalvik-heap和dalvik-zygote，堆内存，所有的Java对象实例都放在这里。 Heap Alloc：累加了Dalvik和Native的heap。 PSS：这是加入与其他进程共享的分页内存后你的应用占用的内存量，你的进程单独使用的全部内存也会加入这个值里，多进程共享的内存按照共享比例添加到PSS值中。如一个内存分页被两个进程共享，每个进程的PSS值会包括此内存分页大小的一半在内。 Dalvik Pss内存 = 私有内存Private Dirty + （共享内存Shared Dirty / 共享进程数） TOTAL：上面全部条目的累加值，全局的展示了你的进程占用的内存情况。 ViewRootImpl：应用进程里的活动窗口视图个数，可以用来监测对话框或者其他窗口的内存泄露。 AppContexts及Activities：应用进程里Context和Activity的对象个数，可以用来监测Activity的内存泄露。 参考 Overview of memory management [Monitor available memory and memory usage] (!https://developer.android.com/topic/performance/memory) Android内存管理机制]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用杀死和恢复的流程]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-app-restore-src%2F</url>
    <content type="text"><![CDATA[LowMemoryKiller机制 Android的LowMemoryKiller(lmk)机制是一种内存回收机制，它根据当前系统的内存阈值以及进程的优先级来决定杀掉哪些进程。LowMemoryKiller会周期性的检查当前系统的可用内存，当系统剩余的可用内存较低时，便会触发进程杀掉进程的策略。它根据不同的内存阈值来决定杀掉相应优先级的进程。 Android的LowMemoryKiller机制是基于Linux的OOM Killer机制修改而来，在KK版本中，LMK机制和策略都是在内核空间驱动中实现的，在L版本中LowMemeoryKiller做了一些调整改动，但总体的思想还是一样的。 Kernel层的实现 123456789101112131415161718192021// kernel/drivers/staging/android/lowmemorykiller.cstatic uint32_t lowmem_debug_level = 2;//低内存阈值对应的优先级，这个值越低就优先级越高static int lowmem_adj[6] = &#123; 0, 1, 6, 12,&#125;;static int lowmem_adj_size = 4;//低内存的阈值static size_t lowmem_minfree[6] = &#123; 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */&#125;;//当系统可用的内存小于某一低内存阈值时，lowmemoryKiller会去比对应优先级低的进程，//比如：当系统可用内存低于64MB时会去杀掉优先级低于12的进程static int lowmem_minfree_size = 4;…… 在lowmemorykiller中定义了两个数组分别是lowmem_infree和lowmem_adj，它们分别是用来描述当前系统的低内存阈值以及低内存阈值对应的进程优先级，lmk正是基于这个优先级来决定是否杀掉当前进程。 123456789101112131415static int __init lowmem_init(void)&#123; task_free_register(&amp;task_nb); register_shrinker(&amp;lowmem_shrinker); return 0;&#125;static void __exit lowmem_exit(void)&#123; unregister_shrinker(&amp;lowmem_shrinker); task_free_unregister(&amp;task_nb);&#125;module_init(lowmem_init);module_exit(lowmem_exit); lmk将自己的lowmem_shrink方法诸恶到系统的内存检测模块中，作用就是在内存不足的时候可以被回调，register_shrinker函数是一属于另一个内存管理模块的函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//内存检测模块检测到内存不足时调用，在这个方法里面会去查找低优先级的进程static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)&#123; struct task_struct *p; struct task_struct *selected = NULL; int rem = 0; int tasksize; int i; int min_adj = OOM_ADJUST_MAX + 1;//初始化为最低优先级 int selected_tasksize = 0; int selected_oom_adj; int array_size = ARRAY_SIZE(lowmem_adj); //1. 获取剩余内存大小 int other_free = global_page_state(NR_FREE_PAGES); int other_file = global_page_state(NR_FILE_PAGES) - global_page_state(NR_SHMEM); if (lowmem_deathpending &amp;&amp; time_before_eq(jiffies, lowmem_deathpending_timeout)) return 0; //调整两个数组的大小描述 if (lowmem_adj_size &lt; array_size) array_size = lowmem_adj_size;//4 if (lowmem_minfree_size &lt; array_size) array_size = lowmem_minfree_size;//4 //2. 找到当前的内存对应的阈值 for (i = 0; i &lt; array_size; i++) &#123; if (other_free &lt; lowmem_minfree[i] &amp;&amp; other_file &lt; lowmem_minfree[i]) &#123; min_adj = lowmem_adj[i];//尽量找到最小内存阈值对应的优先级 break; &#125; &#125; if (sc-&gt;nr_to_scan &gt; 0) lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %d\n", sc-&gt;nr_to_scan, sc-&gt;gfp_mask, other_free, other_file, min_adj); rem = global_page_state(NR_ACTIVE_ANON) + global_page_state(NR_ACTIVE_FILE) + global_page_state(NR_INACTIVE_ANON) + global_page_state(NR_INACTIVE_FILE); if (sc-&gt;nr_to_scan &lt;= 0 || min_adj == OOM_ADJUST_MAX + 1) &#123; lowmem_print(5, "lowmem_shrink %lu, %x, return %d\n", sc-&gt;nr_to_scan, sc-&gt;gfp_mask, rem); return rem; &#125; //这里的min_adj即我们计算得到优先级，低于该优先级的进程都有可能被杀掉 selected_oom_adj = min_adj; //3. 找到优先级低于这个阈值的进程，并杀死 read_lock(&amp;tasklist_lock); for_each_process(p) &#123; struct mm_struct *mm; struct signal_struct *sig; int oom_adj; task_lock(p); mm = p-&gt;mm; sig = p-&gt;signal; if (!mm || !sig) &#123; task_unlock(p); continue; &#125; oom_adj = sig-&gt;oom_adj; if (oom_adj &lt; min_adj) &#123; task_unlock(p); continue; &#125; tasksize = get_mm_rss(mm); task_unlock(p); if (tasksize &lt;= 0) continue; if (selected) &#123; if (oom_adj &lt; selected_oom_adj)//优先级大于selected_oom_adj的进程 就不做处理 continue; if (oom_adj == selected_oom_adj &amp;&amp; tasksize &lt;= selected_tasksize) continue; &#125; selected = p; selected_tasksize = tasksize; selected_oom_adj = oom_adj; lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n", p-&gt;pid, p-&gt;comm, oom_adj, tasksize); &#125; if (selected) &#123; lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n", selected-&gt;pid, selected-&gt;comm, selected_oom_adj, selected_tasksize); lowmem_deathpending = selected; lowmem_deathpending_timeout = jiffies + HZ; force_sig(SIGKILL, selected);//杀死这个进程 rem -= selected_tasksize; &#125; lowmem_print(4, "lowmem_shrink %lu, %x, return %d\n", sc-&gt;nr_to_scan, sc-&gt;gfp_mask, rem); read_unlock(&amp;tasklist_lock); return rem;&#125; lowmem_shrink是lmk的核心处理方法，它的逻辑比较简单，首先通过global_page_state得到当前系统可用的空闲内存大小，随后根据该空闲内存的大小找到相应的内存阈值对应的进程优先级并将其赋值给selected_oom_adj，低于该优先级的进程都有可能被lmk杀掉。for_each_process遍历进程列表，然后找出进程优先级最低的进程通过fore_sig选择杀死进程。 应用恢复机制 Android应用的恢复是通过AMS来进行的。那么AMS恢复的过程是如何的呢？AMS是怎么知道应用被杀掉的？ LowMemoryKiller杀死应用后并不会通知应用层，也不通知AMS，但是我们知道AMS和应用端的通信是基于Binder机制的，别忘了Binder是由卟告功能的，Binder Client通过linkToDeath注册接收该卟告。当Binder Server端死亡后会通过它来告知客户端。这里的Binder Server就是IApplicationThread，这个对象是在ActivityThread中创建的，用于AMS和客户端进行通信的，AMS就是通过它来告诉Activity执行一系列的回调方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//应用创建完application后attach IApplicationThread 到AMS@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125;private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... try &#123; AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0);//应用端binder的卟告 这样当应用被异常杀死后AMS可以得知 app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; app.resetPackageList(mProcessStats); startProcessLocked(app, "link fail", processName); return false; &#125; ...&#125;//应用端死亡卟告接收者 它是通过binder来实现的，binder服务端在异常终止时客户端会收到一份卟告private final class AppDeathRecipient implements IBinder.DeathRecipient &#123; final ProcessRecord mApp; final int mPid; final IApplicationThread mAppThread;//这即是客户端的Binder实体，应用端被杀死后，binder驱动会发送该binder实体的卟告 AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) &#123; if (localLOGV) Slog.v( TAG, "New death recipient " + this + " for thread " + thread.asBinder()); mApp = app; mPid = pid; mAppThread = thread; &#125; //卟告的回调 @Override public void binderDied() &#123; if (localLOGV) Slog.v( TAG, "Death received in " + this + " for thread " + mAppThread.asBinder()); synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread);//通知AMS应用端进程死亡 &#125; &#125;&#125; 在应用创建后就AMS通过attachApplication调用attachApplicationLocked来注册Binder服务的卟告回调。它是一个AppDeathRecipient继承自IBinder.DeathRecipient，当服务端也就是应用端被杀掉后，会通过binderDied来通知AMS，这时候AMS通过appDiedLocked方法来处理应用被杀的逻辑。我们看看AMS这时候是如何处理的。 12345678910111213141516171819202122232425262728293031//app被后台杀死后会通过此方法通知AMS ，这是由binder机制保证的final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread) &#123; ... // Clean up already done if the process has been re-started. if (app.pid == pid &amp;&amp; app.thread != null &amp;&amp; app.thread.asBinder() == thread.asBinder()) &#123; boolean doLowMem = app.instrumentationClass == null; boolean doOomAdj = doLowMem; if (!app.killedByAm) &#123; mAllowLowerMemLevel = true; if("android.process.media".equals(app.processName)) &#123; SystemProperties.set("service.media_oncekilled", "true"); &#125; &#125; else &#123; mAllowLowerMemLevel = false; doLowMem = false; &#125; handleAppDiedLocked(app, false, true);//处理app died的情况 if (doOomAdj) &#123; updateOomAdjLocked(); &#125; if (doLowMem) &#123;//内存较低引起的要通知其他app low memory doLowMemReportIfNeededLocked(app); &#125; &#125; ...&#125; 在appDiedLocked中进一步通过handleAppDiedLocked来处理。 123456789101112131415161718192021222324252627282930313233private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) &#123; //清理一些关于该应用的信息 cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1); if (!restarting) &#123; removeLruProcessLocked(app); &#125; if (mProfileProc == app) &#123; clearProfilerLocked(); &#125; // Remove this application's activities from active lists. boolean hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app); app.activities.clear(); if (app.instrumentationClass != null) &#123; Slog.w(TAG, "Crash of app " + app.processName + " running instrumentation " + app.instrumentationClass); Bundle info = new Bundle(); info.putString("shortMsg", "Process crashed."); finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info); &#125; if (!restarting) &#123; if (!mStackSupervisor.resumeTopActivitiesLocked()) &#123; if (hasVisibleActivities) &#123; mStackSupervisor.ensureActivitiesVisibleLocked(null, 0); &#125; &#125; &#125;&#125; handleAppDiedLocked主要负责以下事情： 负责清理一些Providers，receivers，service之类的信息 从活动的Activity列表移除该应用的Activities 通过resumeTopActivitiesLocked重建进程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private final void cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index) &#123; ... mServices.killServicesLocked(app, allowRestart); boolean restart = false; //清理已经发布的provoider // Remove published content providers. for (int i=app.pubProviders.size()-1; i&gt;=0; i--) &#123; ContentProviderRecord cpr = app.pubProviders.valueAt(i); final boolean always = app.bad || !allowRestart; if (removeDyingProviderLocked(app, cpr, always) || always) &#123; // We left the provider in the launching list, need to // restart it. restart = true; &#125; cpr.provider = null; cpr.proc = null; &#125; app.pubProviders.clear(); // Take care of any launching providers waiting for this process. if (checkAppInLaunchingProvidersLocked(app, false)) &#123; restart = true; &#125; // Unregister from connected content providers. if (!app.conProviders.isEmpty()) &#123; for (int i=0; i&lt;app.conProviders.size(); i++) &#123; ContentProviderConnection conn = app.conProviders.get(i); conn.provider.connections.remove(conn); &#125; app.conProviders.clear(); &#125; ... skipCurrentReceiverLocked(app); //解注册所有的receiver // Unregister any receivers. for (int i=app.receivers.size()-1; i&gt;=0; i--) &#123; removeReceiverLocked(app.receivers.valueAt(i)); &#125; app.receivers.clear(); ... if (restart &amp;&amp; !app.isolated) &#123; // We have components that still need to be running in the // process, so re-launch it. mProcessNames.put(app.processName, app.uid, app); startProcessLocked(app, "restart", app.processName); &#125; ...&#125; cleanUpApplicationRecordLocked负责清理应用的service，provider以及receiver的信息，并根据需要重启该进程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273boolean handleAppDiedLocked(ProcessRecord app) &#123; boolean hasVisibleActivities = false; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; hasVisibleActivities |= mStacks.get(stackNdx).handleAppDiedLocked(app); &#125; return hasVisibleActivities;&#125;boolean handleAppDiedLocked(ProcessRecord app) &#123; if (mPausingActivity != null &amp;&amp; mPausingActivity.app == app) &#123; mPausingActivity = null; &#125; if (mLastPausedActivity != null &amp;&amp; mLastPausedActivity.app == app) &#123; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; return removeHistoryRecordsForAppLocked(app);&#125;boolean removeHistoryRecordsForAppLocked(ProcessRecord app) &#123; removeHistoryRecordsForAppLocked(mLRUActivities, app, "mLRUActivities"); removeHistoryRecordsForAppLocked(mStackSupervisor.mStoppingActivities, app, "mStoppingActivities"); removeHistoryRecordsForAppLocked(mStackSupervisor.mGoingToSleepActivities, app, "mGoingToSleepActivities"); removeHistoryRecordsForAppLocked(mStackSupervisor.mWaitingVisibleActivities, app, "mWaitingVisibleActivities"); removeHistoryRecordsForAppLocked(mStackSupervisor.mFinishingActivities, app, "mFinishingActivities"); // Clean out the history list. int i = numActivities(); for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final ArrayList&lt;ActivityRecord&gt; activities = mTaskHistory.get(taskNdx).mActivities; for (int activityNdx = activities.size() - 1; activityNdx &gt;= 0; --activityNdx) &#123; final ActivityRecord r = activities.get(activityNdx); --i; if (r.app == app) &#123; boolean remove; if ((!r.haveState &amp;&amp; !r.stateNotNeeded) || r.finishing) &#123; // Don't currently have state for the activity, or // it is finishing -- always remove it. remove = true; &#125; else if (r.launchCount &gt; 2 &amp;&amp; r.lastLaunchTime &gt; (SystemClock.uptimeMillis()-60000)) &#123; // We have launched this activity too many times since it was // able to run, so give up and remove it. remove = true; &#125; else &#123; // The process may be gone, but the activity lives on! remove = false; &#125; if (remove) &#123; if (!r.finishing) &#123; if (r.state == ActivityState.RESUMED) &#123; mService.updateUsageStats(r, false); &#125; &#125; removeActivityFromHistoryLocked(r); &#125;else&#123; if (r.visible) &#123; hasVisibleActivities = true; &#125; r.app = null;//将app 置null r.nowVisible = false; if (!r.haveState) &#123; r.icicle = null; &#125; &#125; cleanUpActivityLocked(r, true, true); &#125; &#125; &#125;&#125; removeHistoryRecordsForAppLocked首先从mLRUActivities，mStoppingActivities，mGoingToSleepActivities等多个列表中移除app相关的activity，随后遍历ActivityStack找到和app相关的activity，根据不同的情况标记activity是否应该从历史列表中移除该activity，如果需要的话就调用removeActivityFromHistoryLocked，如果不需要就将r.app置为null。这样在AMS启动activity时就知道该应用的进程需要重建了。 123456789101112131415161718192021222324final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; ... if (next.app != null &amp;&amp; next.app.thread != null) &#123; &#125;else &#123; //1.要启动的activity还未创建过进程 //2.app或者activity被异常杀死过，需要重新启动 // Whoops, need to restart this activity! if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125;void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; if (app != null &amp;&amp; app.thread != null) &#123; ... &#125; ... mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; r.app被置位null后,AMS会去重建该activity对应的进程。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的Finish过程分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-activity-finish-src%2F</url>
    <content type="text"><![CDATA[Activity的finish过程分析 废话不多说了，直接上代码。==。 1234567891011121314151617181920// Activity.javapublic void finish() &#123; if (mParent == null) &#123; int resultCode; Intent resultData; synchronized (this) &#123; resultCode = mResultCode; resultData = mResultData; &#125; …… //调用到AMS中的finishActivity if (ActivityManagerNative.getDefault() .finishActivity(mToken, resultCode, resultData)) &#123; mFinished = true; &#125; …… &#125; else &#123; mParent.finishFromChild(this); &#125;&#125; Activity的finish过程会通过Binder调用到AMS的finishActivity。 12345678910111213141516171819202122@Overridepublic final boolean finishActivity(IBinder token, int resultCode, Intent resultData) &#123; …… synchronized(this) &#123; ActivityRecord r = ActivityRecord.isInStackLocked(token); …… final long origId = Binder.clearCallingIdentity(); boolean res = r.task.stack.requestFinishActivityLocked(token, resultCode, resultData, "app-request", true);//终止当前activity Binder.restoreCallingIdentity(origId); return res; &#125;&#125;final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) &#123; ActivityRecord r = isInStackLocked(token); ... //终止当前activity finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true;&#125; finishActivity调用到ActivityRecord对应的ActivityStack中的requestFinishActivityLocked。紧接着再调用finishActivityLocked。 1234567891011121314151617//frameworks/base/services/java/com/android/server/am/ActivityStack.javafinal boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) &#123; ... if (mResumedActivity == r) &#123; …… // Tell window manager to prepare for this one to be removed. mWindowManager.setAppVisibility(r.appToken, false); if (mPausingActivity == null) &#123; startPausingLocked(false, false);//开始pause流程，这是finish周期的第一步 &#125; &#125; …… return false;&#125; finishActivityLocked通过startPauseingLocked方法来暂停当前的activity。 1234567891011121314151617181920212223242526272829303132final void startPausingLocked(boolean userLeaving, boolean uiSleeping) &#123; ActivityRecord prev = mResumedActivity;//将要被暂停的activity mResumedActivity = null; //pause流程会将mResumeActivity置null mPausingActivity = prev;//正在被暂停的activity mLastPausedActivity = prev;//上一个被暂停的activity mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null; prev.state = ActivityState.PAUSING;//切换状态为PAUSING prev.task.touchActiveTime(); clearLaunchTime(prev); final ActivityRecord next = mStackSupervisor.topRunningActivityLocked();//代表即将要启动的activity if (next == null || next.task != prev.task) &#123; prev.updateThumbnail(screenshotActivities(prev), null); &#125; stopFullyDrawnTraceIfNeeded(); mService.updateCpuStats(); if (prev.app != null &amp;&amp; prev.app.thread != null) &#123;//Launcher启动 走这里 ... prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);//取出ApplicationThread对象通知其进入Paused状态 ... &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; ...&#125; startPausingLocked方法负责暂停当前activity，它通过IApplicationThread这个Binder代理调用schedulePauseActivity通知应用端暂停当前activity。 123456789101112131415161718192021222324private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; //Slog.v(TAG, "userLeaving=" + userLeaving + " handling pause of " + r); if (userLeaving) &#123; performUserLeavingActivity(r); &#125; r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb());//调用performPauseActivity函数来调用Activity.onPause回调 // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; //通知ActivityManagerService，这个Activity已经进入Paused状态了，ActivityManagerService现在可以完成未竟的事情 // Tell the activity manager we have paused. try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; schedulePauseActivity调用handlePauseActivity方法来执行暂停过程，这里会回调Activity生命周期的onPause方法，完成暂停后通过activityPaused方法通知AMS。 123456789101112131415161718192021222324252627//activity被暂停后 通知AMS已经执行完毕@Overridepublic final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized(this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token);//获取当前的activityStack if (stack != null) &#123; stack.activityPausedLocked(token, false); &#125; &#125; Binder.restoreCallingIdentity(origId);&#125;//ActivityStack.java 通知activity被pausedfinal void activityPausedLocked(IBinder token, boolean timeout) &#123; //这里的token是被暂停的activity的token final ActivityRecord r = isInStackLocked(token);//得到暂停的activity Launcher启动即为Launcher对应的Activity if (r != null) &#123; mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r); if (mPausingActivity == r) &#123;//true 这个在startPausingLocked中被设置的 r.state = ActivityState.PAUSED;//改变状态为PAUSING-&gt;PAUSEd completePauseLocked();//完成暂停acitivty的操作 &#125; ... &#125;&#125; AMS的activityPaused通过ActivityStack的activityPausedLocked方法来完成进一步完成暂停Activity的工作。随后进一步调用completePauseLocked。 1234567891011121314151617//完成暂停动作后的逻辑private void completePauseLocked() &#123; ActivityRecord prev = mPausingActivity; if (prev != null) &#123; if (prev.finishing) &#123;//主动finish时候是走这个分支，如果finishing标记为true表示这个activity是要finish prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false); &#125; ... mPausingActivity = null;//完成了pause过程 这里需要将mPausingActivity置为null &#125; final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) &#123;//未休眠 mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); &#125; ...&#125; 123456789101112131415161718192021222324252627282930313233//finish当前activityfinal ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) &#123; …… // make sure the record is cleaned out of other places. mStackSupervisor.mStoppingActivities.remove(r);//从mStackSupervisor中移除activity的信息 mStackSupervisor.mGoingToSleepActivities.remove(r); mStackSupervisor.mWaitingVisibleActivities.remove(r); if (mResumedActivity == r) &#123; mResumedActivity = null; &#125; final ActivityState prevState = r.state; if (DEBUG_STATES) Slog.v(TAG, "Moving to FINISHING: " + r); r.state = ActivityState.FINISHING; if (mode == FINISH_IMMEDIATELY || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) &#123; // If this activity is already stopped, we can just finish // it right now. boolean activityRemoved = destroyActivityLocked(r, true, oomAdj, "finish-imm"); if (activityRemoved) &#123; mStackSupervisor.resumeTopActivitiesLocked(); &#125; return activityRemoved ? null : r; &#125; // Need to go through the full pause cycle to get this // activity into the stopped state and then finish it. mStackSupervisor.mFinishingActivities.add(r); mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null); return r;&#125; completePauseLocked完成activity暂停的工作，这里的mPausingActivity就是当前finish的activity，由于是主动finish的，这里的prev.finishing为true，通过finishCurentActivityLocked完成暂停的工作，随后resumeTopActivitiesLocked启动当前栈顶的activity。这一部分工作在activity的启动过程有所介绍，这里不展开说明。这一流程会导致栈顶activity调用onRestart,onStart,onResume过程。我们看下acitivty执行onResume完成后会做什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ... ActivityClientRecord r = performResumeActivity(token, clearHide);//回调OnResume ... if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler()); &#125;&#125;private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) &#123; stopProfiling = true; &#125; if (a != null) &#123; mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do &#123; if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; if (stopProfiling) &#123; mProfiler.stopProfiling(); &#125; ensureJitEnabled(); return false; &#125;&#125; activity处理resume过程中会在当前主线程的MessageQueue中添加一个addIdleHandler，这个handler的回调在MessageQueue中没有可以处理的消息后进行调用，而在回调中调用了AMS的activityIdle，这个方法开始处理前一个activity的finish的收尾工作。 12345678910111213@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); ... &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 1234567891011121314151617181920212223final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; ... ActivityRecord r = ActivityRecord.forToken(token); ... // Atomically retrieve all of the other things to do. stops = processStoppingActivitiesLocked(true); NS = stops != null ? stops.size() : 0; if ((NF=mFinishingActivities.size()) &gt; 0) &#123;//拷贝当前需要finish的activity finishes = new ArrayList&lt;ActivityRecord&gt;(mFinishingActivities); mFinishingActivities.clear(); &#125; ... //处理等待finish的activities for (int i = 0; i &lt; NF; i++) &#123; r = finishes.get(i); activityRemoved |= r.task.stack.destroyActivityLocked(r, true, false, "finish-idle");//终止activity &#125; ... return r;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, boolean oomAdj, String reason) &#123; ... boolean removedFromHistory = false; cleanUpActivityLocked(r, false, false); final boolean hadApp = r.app != null; if (hadApp) &#123; if (removeFromApp) &#123; r.app.activities.remove(r); if (mService.mHeavyWeightProcess == r.app &amp;&amp; r.app.activities.size() &lt;= 0) &#123; mService.mHeavyWeightProcess = null; mService.mHandler.sendEmptyMessage( ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG); &#125; //如果当前APP的Activity堆栈为空了，就说明当前Activity没有可见界面了，这个时候就需要动态更新这个APP的优先级 if (r.app.activities.isEmpty()) &#123; // No longer have activities, so update LRU list and oom adj. mService.updateLruProcessLocked(r.app, false, null); mService.updateOomAdjLocked(); &#125; &#125; boolean skipDestroy = false; try &#123; r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags);//通知应用端处理activity的destroy &#125; r.nowVisible = false; if (r.finishing &amp;&amp; !skipDestroy) &#123; r.state = ActivityState.DESTROYING; Message msg = mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r); mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT); &#125; ... &#125; ... return removedFromHistory;&#125; destroyActivityLocked中主要就是通知应用端进行onStop，onDestroy生命周期的回调。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动分析(二)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-activity-show-src%2F</url>
    <content type="text"><![CDATA[在Activity启动流程分析一篇中，我们介绍了从Launcher启动桌面应用的大体流程，本篇将是这一篇的补充，主要分析在Activity准备启动到显示过程中的详细内容，探讨关于WindowManager，Activity以及Window之间的联系。从而更进一步了解Android GUI 子系统。 应用进程创建 Activity启动是在ActivityThread中进行的，通过Zygote创建完应用进程后，首先会通过ActivityThread的main方法初始化UI线程，然后会通知ActivityManager进行attachApplication,这里AMS(ActivityManagerService)会看栈顶是否有等待启动的Activity，如果有的话就通过IApplicationThread通知应用Launch这个Activity。关于这个IApplication它实际是一个Binder，它负责AMS和应用进程之间的通信，在ActivityThread中的一系列schedulexxx方法都是通过这个Binder对象通知的。它的服务端是在应用进程一端，客户端是在AMS所在进程即SystemServer进程中。这个Binder是随着ActivityThread的创建而生成的，并在AMS进行attachApplication时将其传递给AMS。 123456789101112frameworks/base/core/java/android/app/ActivityThread.javaprivate void attach(boolean system) &#123; …… IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; //将该ApplicationThread attach到AMS上 因为AMS正是通过这个对象来和应用程序进行binder调用的 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; ……&#125; 123456789101112131415161718frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward, String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123;//启动activity updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.activityInfo = info; …… sendMessage(H.LAUNCH_ACTIVITY, r);&#125; AMS通过IApplicationThread的scheduleLaunchActivityl来启动一个Activity,启动过程会对应的创建一个ActivityClientRecord实例，这个和AMS中的ActivityRecord是对应的。这里最为重要的是token参数，它也是一个Binder对象，这个token实际上就是ActivityRecord中的appToken，在ActivityRecord构造时创建，它被AMS用来标记ActivityRecord对应的Activity。在AMS启动过程中会通过WMS调用addAppToken为该Activity添加一个AppWindowToken，appToken作为一个标识被传递给WMS。这样无论是应用进程还是WMS都可以通过这个Token来识别是否为同一个对象。 注：在Android Framework中一个Binder Token通常被用于进行binder通信或者唯一标记一个对象。 1234567891011121314151617181920frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; …… Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; …… handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed);activity显示出来 并回调OnResume &#125; else &#123; // If there was an error, for any reason, tell the activity // manager to stop us. try &#123; ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;&#125; scheduleLaunchActivity 通过H，实际上是个Handler通知调用handleLaunchActivity启动Activity,这个方法首先调用performLaunchActivity创建Activity，然后通过handleResumeActivity显示activity。这两个方法做了Activity启动过程中的绝大部分事情。后面的内容主要据此展开。 Activity的创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960frameworks/base/core/java/android/app/ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; …… Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader();//加载ClassLoader activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);//创建activity StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123;&#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation);//创建Application if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity);//为activity 创建ContextImpl对象 CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //调用activity的attach 将context设置到activity中 保存token activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource();//获取activity主题 if (theme != 0) &#123; activity.setTheme(theme);//将主题将应用到activity &#125; activity.mCalled = false; mInstrumentation.callActivityOnCreate(activity, r.state);//调用activity的onCreate if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart();//调用activity的onstart r.stopped = false; &#125; …… &#125; r.paused = true; mActivities.put(r.token, r);//保存这个ActivityClientRecord 这在应用端代表了activity &#125; …… return activity;&#125; 在performLaunchActivity中主要做以下事情： 根据r中的Activity信息创建Activity实例，这个是Instrumention通过反射来完成的。 为应用创建Application，当然这个Application只会创建一次，如果已经创建了就直接返回 为Activity创建Context，这里具体为ContextImpl 将activity attach到上下文Context 调用onCreate onStart等生命周期回调 接下来我们分步介绍以上几个步骤： 创建Activity实例 创建Activity实例的过程比较简单，因为Activity没有提供任何构造方法，这里通过反射默认构造一个实例。 创建Application 1234567891011121314151617181920212223242526272829//为应用创建applicationpublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123;//Application已经创建就就直接返回 return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className;//应用设置的application if (forceDefaultAppClass || (appClass == null)) &#123;//如果应用未设置application或者未强制使用默认的application appClass = "android.app.Application";//使用默认的application对象 &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);//创建application context app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext);//创建application appContext.setOuterContext(app); &#125; catch (Exception e) &#123;&#125; mActivityThread.mAllApplications.add(app); mApplication = app; …… instrumentation.callApplicationOnCreate(app); …… return app;&#125; makeApplication主要为应用创建Application实例，在创建之前会先通过createAppContext创建AppcliationContext，然后调用onCreate回调。 创建contextImpl 123456789 private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; //每个Activity启动时都需要创建一个ContextImpl ContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.token);//创建ContextImpl实例 appContext.setOuterContext(activity);//outerContext实际上为activity Context baseContext = appContext; …… return baseContext;&#125; 每个Acitivty启动都需要为其创建一个Context,这里通过ContextImpl.createActivityContext创建 Activity的attach过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445frameworks/base/core/java/android/app/Activity.javafinal void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; attachBaseContext(context);//context为ContextImpl mFragments.attachActivity(this, mContainer, null); mWindow = PolicyManager.makeNewWindow(this);//为其创建窗口 Window为抽象类，这里实际上是创建了PhoneWindow mWindow.setCallback(this);//设置事件回调 mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token;//token赋值 这个token实际上就是在ActivityRecord创建的appToken 它是一个 IApplicationToken.Stub mIdent = ident; mApplication = application; mIntent = intent; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; //这里传给window 使用同样的token，这里为window设置一个管理对象，实际是为其创建一个新的WindowManagerImpl mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//设置WindowManager if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager();//取到WindowManager mCurrentConfig = config;&#125; 为Activity创建好context后接下来需要调用Activity的attach方法做以下事情： 设置context，将其保存在ContextWrapper中 保存token，这个token为ActivityRecord中的appToken 为Activity创建Window，即PhoneWindow 为Window设置WindowManager,这个WindowManager实际为WindowManagerImpl。 123456789101112131415161718192021222324252627frameworks/base/core/java/android/app/ContextImpl.javaclass ContextImpl extends Context &#123; static &#123; …… registerService(WINDOW_SERVICE, new ServiceFetcher() &#123; Display mDefaultDisplay; public Object getService(ContextImpl ctx) &#123; …… return new WindowManagerImpl(display); &#125;&#125;); …… &#125; private static void registerService(String serviceName, ServiceFetcher fetcher) &#123; …… SYSTEM_SERVICE_MAP.put(serviceName, fetcher); &#125; private static final HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP = new HashMap&lt;String, ServiceFetcher&gt;(); @Override public Object getSystemService(String name) &#123; ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this); &#125;&#125; 这里需要注意的是contextImpl在getSystemServer(Context.WINDOW_SERVICE)时会创建一个新的实例WindowManagerImpl，所以对于每个Window，都会有一个新的这样的实例。这个WindowManagerImpl并不是WMS的本地代理，这里不要混淆。接下来我们看看在setWindowManager中会做些什么事情 12345678910111213public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken;//保存appToken mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; //这里的wm实际上是WMS的本地代理，它是在ComtextImpl的getSystemService的ServiceFetcher中注册的 //这里会创建一个新的WindowManagerImpl返回 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class WindowManagerImpl implements WindowManager &#123; //单例 事实上所有的接口都是通过WindowManagerGlobal对象完成的 //真正的代理任务是交给WindowManagerGlobal，这个对象是个单例，在一个进程中只有一个 private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Display mDisplay; private final Window mParentWindow; public WindowManagerImpl(Display display) &#123; this(display, null); &#125; private WindowManagerImpl(Display display, Window parentWindow) &#123; mDisplay = display; mParentWindow = parentWindow; &#125; //这个在Window的setWindowManager中调用 parentWindow为activity对应的window对象 public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mDisplay, parentWindow); &#125; public WindowManagerImpl createPresentationWindowManager(Display display) &#123; return new WindowManagerImpl(display, mParentWindow); &#125; @Override public void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow); &#125; @Override public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; mGlobal.updateViewLayout(view, params); &#125; @Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125; @Override public Display getDefaultDisplay() &#123; return mDisplay; &#125;&#125; setWindowManager为该window保存了Activity的appToken，同时通过createLocalWindowManager又创建了一个WindowManagerImpl。这次创建的实例中mParentWindow不为null,而是当前window，需要注意的是它内部持有一个 WindowManagerGlobal单例，这个WindowManagerGlobal是用来和WMS通信的，它内部就持有WMS的Binder本地代理接口对象。 生命周期的回调 Activity完成attach后就已经有对应的PhoneWindow对象了，同时将context保存在activity中了，这时候先回调onCreate，在onCreate中我们通过setContentView设置内容视图，其实是通过PhoneWindow对象的setContentView来完成的。 1234567891011121314frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java @Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor();//创建decorview &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; setContentView为当前window生成一个DecorView,它是整个view树的根view节点。 Activity的显示 通过上面的一系列工作，Activity已经准备好显示前的工作了，接下来就是开始handleResumeActivity了。 123456789101112131415161718192021222324252627final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; …… ActivityClientRecord r = performResumeActivity(token, clearHide);//回调OnResume if (r != null) &#123; final Activity a = r.activity; …… if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;//还未被添加到WMS且也没有finish r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;//调整Z主序为TYPE_BASE_APPLICATION 因为默认为TYPE_APPLICATION l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l);//添加view decorView是在onCreate中调用setContentView设置的 &#125; &#125; …… r.activity.makeVisible(); &#125; ……&#125; 在这个方法中我们主要看activity是如何被显示出来的。首先获取已经inflate好的DecorView，将其设置为不可见，随后从Activity取到WindowManager(WindowManager是ViewManager的父类，它们都是接口),它实际就是之前通过createLocalWindowManager创建的WindowManagerImpl.随后通过wm.addView添加decorView到window中，这里最终会将window添加到WMS中去。前面我们知道和WMS的通信是由WindowManagerImpl内部的WindowManagerGlobal完成的，它是一个单例。 1234@Overridepublic void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; 这里的mParentWindow就是activity对应的window，mDisplay代表显示终端对象。params为view的布局参数。 1234567891011121314151617181920212223242526272829//具体完成addView接口方法的事务 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; …… ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; …… final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams);//设置LayoutParams的token &#125; …… root = new ViewRootImpl(view.getContext(), display);//创建ViewRootImpl对象 view.setLayoutParams(wparams); mViews.add(view);//添加到view列表 mRoots.add(root);//添加到root列表 mParams.add(wparams);//添加到参数列表 &#125; try &#123; root.setView(view, wparams, panelParentView);//将view树和viewRoot关联 &#125; catch (RuntimeException e) &#123;&#125;&#125; 在addView中为当前decorview创建ViewRootImpl，这个是用来管理view树的，对应的将view,root，params分别添加到三个对应的数组中，最后通过ViewRootImpl的setView将当前view和ViewRootImpl关联起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;//关联子视图 synchronized (this) &#123; if (mView == null) &#123;//未设置view mView = view; mViewLayoutDirectionInitial = mView.getRawLayoutDirection(); mFallbackEventHandler.setView(view); mWindowAttributes.copyFrom(attrs); …… if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;//没有设置InputChannel mInputChannel = new InputChannel();//输入通道 这个是用来接收事件的 会通过native层设置 &#125; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //将窗口添加到到显示队列中 这个mInputChannel是socketpair的客户端的channel, res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel); &#125; …… if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());//创建窗口事件输入接收者 mInputChannel用来接收事件的接口 &#125; …… // Set up the input pipeline. //建立输入事件的处理职责链 CharSequence counterSuffix = attrs.getTitle(); InputStage syntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix; &#125; &#125;&#125; ViewRootImpl作为view树的管理者负责view树的绘制和输入事件的管理。其中最重要的工作是通过mWindowSession将当前window添加到WMS中去。这里需要注意mWindow是一个W对象，它是一个Binder对象，WMS使用它和应用进程通信，当窗口状态发生变化需要通过这个Binder通知应用端。 123456789101112131415161718 //获取windowsession进行会话 也是一个单例 可见一个应用也只会有一个sessionpublic static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); IWindowManager windowManager = getWindowManagerService(); sWindowSession = windowManager.openSession( imm.getClient(), imm.getInputContext());//打开会话 float animatorScale = windowManager.getAnimationScale(2); ValueAnimator.setDurationScale(animatorScale); &#125; catch (RemoteException e) &#123; Log.e(TAG, "Failed to open window session", e); &#125; &#125; return sWindowSession; &#125;&#125; mWindowSession是在创建ViewRootImpl通过WindowManagerGlobal的getWindowSession得到的。它返回一个IWindowSession是一个匿名binder，用来和WMS进行会话，在WindowManagerGlobal中它是这样打开一个会话的,它同样是一个单例，即一个应用进程只需要一个会话就可以了。 123456789frameworks/base/services/java/com/android/server/wm/Session.java //添加window到WMS 应用端通过session来和WMS交互@Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outInputChannel);&#125; 得到该会话就可以通过addToDisplay将window添加到WMS了，它实际是和Session交互的，Session是IWindowSession匿名binder的服务端，mService是WMS服务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//添加window到WMS public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; boolean reportNewConfig = false; WindowState attachedWindow = null;//Window在WMS是通过WindowState体现的 WindowState win = null; synchronized(mWindowMap) &#123; if (mWindowMap.containsKey(client.asBinder())) &#123; Slog.w(TAG, "Window " + client + " is already added"); return WindowManagerGlobal.ADD_DUPLICATE_ADD; &#125; boolean addToken = false; WindowToken token = mTokenMap.get(attrs.token);//获取到对应的appWindowToken if (token == null) &#123; token = new WindowToken(this, attrs.token, -1, false); addToken = true; &#125; win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); mPolicy.adjustWindowParamsLw(win.mAttrs); win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs)); res = mPolicy.prepareAddWindowLw(win, attrs); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; if (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; String name = win.makeInputChannelName(); //创建一对输入通道，其中第一个为服务端的channel位于WindowManagerService中，另外一个通过outInputChannel参数返回到应用程序中 InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); win.setInputChannel(inputChannels[0]); inputChannels[1].transferTo(outInputChannel);//第二个channel是作为outInputChannel返回给客户端的 //向InputDispatcher注册服务端的channel，这样当Disaptcher收到事件后可以通过该channel分发事件给客户端 mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); &#125; …… if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; mInputMethodWindow = win; addInputMethodWindowToListLocked(win); imMayMove = false; &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; mInputMethodDialogs.add(win); addWindowToListInOrderLocked(win, true); moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true)); imMayMove = false; &#125; else &#123; addWindowToListInOrderLocked(win, true); if (type == TYPE_WALLPAPER) &#123; mLastWallpaperTimeoutTime = 0; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if (mWallpaperTarget != null &amp;&amp; mWallpaperTarget.mLayer &gt;= win.mBaseLayer) &#123; // If there is currently a wallpaper being shown, and // the base layer of the new window is below the current // layer of the target window, then adjust the wallpaper. // This is to avoid a new window being placed between the // wallpaper and its target. displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; &#125; assignLayersLocked(displayContent.getWindowList()); &#125; return res;&#125; 首先我们注意到两个map 12final HashMap&lt;IBinder, WindowState&gt; mWindowMap = new HashMap&lt;IBinder, WindowState&gt;();final HashMap&lt;IBinder, WindowToken&gt; mTokenMap = new HashMap&lt;IBinder, WindowToken&gt;(); mWindowMap是IWindow和服务端Window的映射，这里WindowState即代表了服务端的Window，而IWindow是ViewRootImpl中的W对象。 mTokenMap是token和WindowToken的映射，这里的token为appToken,windowToken为我们在启动activity之前通过addApptoken添加的。 在addWindow中主要完成以下事情： 通过token取到WindowToken，这个token来自 WindowManager.LayoutParams,它是在WindowManagerGlobal的addView中通过adjustLayoutParamsForSubWindows设置的，它会根据不同的窗口类型和属性设置该token. 如果未取到WindowToken需要为其创建一个。 随后为该窗口创建WindowState，它代表了应用端的Window。同时将其添加到mWindowMap中 根据不同的窗口类型设置窗口的Z序。 关于添加窗口的具体细节，这里就不详述，我会在后面的文章后介绍。 显示的时机 在handleResumeActivity通过addView添加view，将window加入到WMS后，会通过updateViewLayout更新视图 12345678910111213141516171819202122frameworks/base/core/java/android/view/WindowManagerGlobal.java //更新视图public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams);//设置view布局参数 synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index);//找到对应的viewroot mParams.remove(index);//移除之前的params mParams.add(index, wparams);//添加新的params root.setLayoutParams(wparams, false);//通过root设置参数 false代表view已经添加过 这里会对view树重新绘制 &#125;&#125; 在root.setLayoutParams中会通过scheduleTraversals()绘制view。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动流程(Launcher篇)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-startactivity-1%2F</url>
    <content type="text"><![CDATA[综述 ActivityManagerService 即活动管理服务，它负责管理我们应用的activity，service等与系统交互的组件，为了方便起见，我们简称为AMS。我们知道Activity在启动过程中会经历一系列的生命周期，这些生命周期反应了AMS创建和管理Activity的整个过程，并且在这之间又同时需要和WindowManagerService进行交互操作，这就导致activity的启动是个异常复杂的工作。本篇不打算对整个流程的细节做过多的分析，只涉及activity启动过程的关键部分。 Activity启动方式-Launcher 首先activity的启动方式有多种可能的情况，比如最典型的就是点击Launcher上的图标启动，或者在应用内部打开activity进行跳转，还有通过adb 来启动activity，但无论是哪种启动方式，最基本的流程都是类似的。这里我们以Launcher启动作为描述的标准场景来简单了解下在activity启动过程中都会发生什么事情以使activity能够展现在我们眼前。 Launcher是一个标准的系统桌面应用，它用来管理系统中的所有已安装的app，这些app都是以网格化的形式在Launcher中显示的。我们点击一个app图标就会开始启动整个app并启动它的主activity。 Launcher启动是会给Intent添加flag Intent.FLAG_ACTIVITY_NEW_TASK,这表示我们会为这个应用创建一个新的任务栈。紧接就是启动指定的activity，正式开始startActivity的启动。 1234567891011121314151617181920packages/apps/Launcher2/src/com/android/launcher2/Launcher.javaboolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); if (useLaunchAnimation) &#123; ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); startActivity(intent, opts.toBundle()); &#125; else &#123; startActivity(intent);//调用activity的startActivity启动 &#125; return true; &#125; catch (SecurityException e) &#123;&#125; return false;&#125; 从Launcher启动的activity默认添加了FLAG_ACTIVITY_NEW_TASK，表示为应用创建新的任务栈。 这里我们从Launcher启动传递给startActivityForResult的requestCode为-1，说明我们不接受activity的返回值。 1234567891011Activity: startActivity-&gt;startActivityForResult1. [Activity.startActivityForResult]===&gt;[Instrumention.execStartActivity]public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123; …… Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this,intent, requestCode, options); ……&#125; execStartActivity 参数说明,对于Launcher启动： who: 为Launcher应用 mMainThread.getApplicationThread(): 为Launcher的ApplicationThread它是一个Binder target: 为this 代表Launcher这个Activity requestCode: -1 intent: 为要启动应用的Activity的意图 options: null 这里通过Instrumention来调用execStartActivity 1234567891011121314151617181920212.[Instrumention.execStartActivity]===&gt;[AMS.startActivity]public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; …… try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //通过AMS启动Activity 这个是通过binder调用完成 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); //检查启动的结果 这里如果Activity在manifest中未注册就会报错 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123;&#125; …… return null;&#125; 在Instrumention中会通过ActivityManagerNative获取到AMS的代理，到这里就开始通过Binder进行IPC调用了。我们这里继续看AMS中startActivity的实现，AMS时SystemServer进程中的众多服务之一，关于它启动的细节请参见SystemServer.java. 1234567891011[AMS.startActivity]===&gt;[AMS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivity(IApplicationThread caller, StringcallingPackage,Intent intent, String resolvedType, IBinder resultTo,String resultWho, int requestCode, int startFlags,String profileFile, ParcelFileDescriptor profileFd, Bundle options)&#123;//启动流程在AMS的入口 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());&#125; 这里我们对传递的参数做个说明： caller：代表Launcher的ApplicationThread 它是个Binder对象 callingPackage: 调用者即Launcher的包名 Intent: 要启动的activity的意图 resolvedType: Intent中指定的MIME类型 一般不指定的为null resultTo : token 代表着Launcher的activityRecord的- appToken，实际上就是代表着Launcher. resultWho : null requestCode:-1 startFlags : 0 profileFile:-1 profileFd:null Options:null 123456789101112131415161718[AMS.startActivityAsUser]===&gt;[ASS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,false, true, "startActivity", null); // TODO: Switch to user app stacks here. //mStackSupervisor是一个ActivityStackSupervisor ，从名字上看是对ActivityStack进行操作的 //这里callingUid为-1 profileFile为null profileFd为null return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, null, null, options, userId);&#125; AMS作为activity的管理者，它很懒，不做什么事情，几乎大部分Service都类似，他们不会真正的做事情，而是交给其他的&quot;代理&quot;对象去做事情。这里的&quot;代理&quot;对象就是ActivityStackSupervisor从名称上来看它负责监控和管理ActivityStack。 12345678910111213141516171819202122232425262728293031frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config, Bundle options, int userId) &#123; …… // Collect information about the target of the Intent. ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profileFile, profileFd, userId);//收集参数Intent的相关信息到aInfo中 synchronized (mService) &#123; int callingPid;//Launcher:默认传递进来的为-1 if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = Binder.getCallingPid(); callingUid = Binder.getCallingUid(); &#125; else &#123; callingPid = callingUid = -1;//Launcher:D &#125; ……… //继续调用startActivityLocked进行启动流程 int res = startActivityLocked(caller, intent, resolvedType, aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, startFlags, options, componentSpecified, null); ……&#125; startActivityMayWait方法中会从待启动的activity的intent中获取ActivityInfo，随后再去设置callingPid 和 callingUid为-1.在进一步调用startActivityLocked。 1234567891011121314151617181920212223242526272829303132333435frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options, boolean componentSpecified, ActivityRecord[] outActivity) &#123; ProcessRecord callerApp = null; if (caller != null) &#123;//校验调用者进程对于Launcher来说 即Launcher所在的应用进程 callerApp = mService.getRecordForAppLocked(caller);//查找调用者在AMS中的ProcessRecord信息 if (callerApp != null) &#123; callingPid = callerApp.pid;//调用者的进程id callingUid = callerApp.info.uid;//调用者的用户id &#125;…… &#125; /做一些权限检测工作 final int startAnyPerm = mService.checkPermission( START_ANY_ACTIVITY, callingPid, callingUid); final int componentPerm = mService.checkComponentPermission(aInfo.permission, callingPid, callingUid, aInfo.applicationInfo.uid, aInfo.exported); //为新的Activity创建ActivityRecord AMS中AcitivtyRecord用来描述Activity ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, this); //继续调用启动流程 //Launcher:sourceRecord保存着Launcher Activity的实体信息 需要注意的是这里doResume参数默认位true err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options); &#125; 这个方法主要做的事情包括： 1.初始化调用者的进程id和用户id,这是通过查找它的ProcessRecord来进行的。 2.做一些权限检查，比如调用者的权限和启动组件的权限等 3.为待启动的activity创建AtivityRecord，同时会创建appToken，用来代表这个ActivityRecord，间接代表要启动的activity. 4.进一步调用startActivityUncheckedLocked来进一步启动，这里的sourceRecord为Launcher的ActivityRecord。r就是我们要启动的activity的activityRecord 123456789101112131415161718192021222324252627282930313233343536373839404142final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; …… if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; if (r.resultTo == null) &#123; //Launcher:这里调用findTaskLocked找到是否存在r的实例，这里查找的结果应该是null，因为是从Launcher加载 ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); &#125; &#125; …… if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;//Launcher：true 需要一个新的task targetStack = adjustStackFocus(r); moveHomeStack(targetStack.isHomeStack()); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, true), null, true);//创建TaskRecord 并保存在r的task成员中 &#125; else &#123; r.setTask(reuseTask, reuseTask, true); &#125; newTask = true; …… &#125; …… mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,intent, r.getUriPermissionsLocked()); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); mService.setFocusedActivityLocked(r); &#125; 这一步会首先为要启动的activity找到一个task,然而由Launcher启动的时候activity的task还并未创建，这时候需要为其创建一个task并通过setTask设置到r中去。紧接着这里调用startActivityLocked进一步处理，同时将mLastPausedActivity置null,表示当前没有被暂停的activity。将mFocusedActivity设置为当前的activity，表示为焦点activity.对于Launcher启动这里newTask为true。 12345678910111213141516171819202122232425final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task;//ActivityRecord中存储的TaskRecord final int taskId = rTask.taskId; if (taskForIdLocked(taskId) == null || newTask) &#123; insertTaskAtTop(rTask); mWindowManager.moveTaskToTop(taskId); &#125; …… task.addActivityToTop(r);//将ActivityRecord放到task栈的顶部 task.setFrontOfTask();//将task栈设置为前台栈 r.putInHistory(); if (!isHomeStack() || numActivities() &gt; 0) &#123; …… &#125;else&#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0, r.userId,r.info.configChanges); &#125; if (doResume) &#123; mStackSupervisor.resumeTopActivitiesLocked();//又回到ActivityStackSupervisor &#125;&#125; 这一步首先将要启动的activity对应的ActivityRecord 即r放到其对应TaskRecord的顶部，然后将其Task设置为前台栈.随后为该Activity添加AppWindowToken，这个token时WMS用来标记AMS端的Activity对应的window的。最后调用resumeTopActivitiesLocked进一步处理栈顶activity. 12345678910111213141516171819202122boolean resumeTopActivitiesLocked() &#123; return resumeTopActivitiesLocked(null, null, null); &#125; boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = getFocusedStack(); &#125; boolean result = false; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (isFrontStack(stack)) &#123; if (stack == targetStack) &#123; result = stack.resumeTopActivityLocked(target, targetOptions); &#125; else &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result; &#125; 1234567891011121314151617181920212223242526272829303132333435final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; ActivityRecord next = topRunningActivityLocked(null); …… mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); …… //暂停当前执行的activity 为栈顶activity启动坐准备 boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving); if (mResumedActivity != null) &#123;//当前正在执行的activity pausing = true; startPausingLocked(userLeaving, false);//暂定activity &#125; …… if (prev != null) &#123; &#125;else&#123; if (mNoAnimActivities.contains(next)) &#123;//如果next不包含入场动画 anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); if (next.app != null &amp;&amp; next.app.thread != null) &#123; …… &#125;else&#123; …… mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125; 这组方法用来恢复启动task栈顶的activity，其中next即我们要执行的activity，它已经被放在了task栈顶，这里如果next已经在相关的休眠或者停止队列中需要将其从中移除，并重置sleeping状态，这些都是为next的启动做准备。这里最重要的一步就是需要将当前正在执行的mResumedActivity 暂停，这样才能执行task栈顶的activity .这是通过startSpercificActivityLocked来执行的。 12345678910111213 void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; …… &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true); &#125; 这个方法用来启动我们具体的activity，首先获取activity对应的进程信息ProcessRecord，由于Launcher启动，activity的进程还未创建，所以这里需要为activity创建进程。 123456789private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… //为服务或者activity创建新的进程 通过zygote进程执行 创建完成后回调ActivityThread并执行其main方法 Process.ProcessStartResult startResult = Process.start("android.app.ActivityThread", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); ……&#125; 到这里会通过zygote为activity创建进程，这是通过和zygote进程通过socket通信来完成的，zygote为Activity创建进程后，会调用ActivityThread的main方法。 我们看看ActivityThread的main方法 12345678910111213141516public static void main(String[] args) &#123; …… Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 进程启动后需要创建要给ActivityThread对象，并调用其attach方法。在attach方法中会做许多初始工作。从main方法可以看到进程的主线程是作为ui线程的。 12345678910111213private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; …… IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;else&#123;……&#125;&#125; 在attach方法中会调用AMS的attachApplicaton，这里的mAppThread是我们的ApplicationThread对象，它是一个binder服务,在ActivityThread对象创建的时候生成，它在这里传递给AMS，这样AMS就可以使用其代理binder来和应用程序进行通信。比如activity众多的生命周期事件是通过这个binder对象通知应用端的。 123456789 @Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//进一步调用 Binder.restoreCallingIdentity(origId); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; app.makeActive(thread, mProcessStats); …… thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); …… if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app, mHeadless)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ……&#125; 这里AMS做一些初始化工作后 又会调用到应用端的bindApplication。应用端会在这个时机为应用创建Application对象，随后AMS分别调用mStackSupervisor和mServices的attachApplicationLocked，这里会将等待启动的acitivty或者service启动起来。后面我们继续分析 12345678910111213public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; …… sendMessage(H.BIND_APPLICATION, data); &#125; 这里会通过H对象 其实是个handler 来发送BIND_APPLICATION消息，这会调用handleBindApplication方法来处理该消息。 12345678private void handleBindApplication(AppBindData data) &#123; …… Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; …… mInstrumentation.callApplicationOnCreate(app); ……&#125; 在应用端的handleBindApplication时会为应用创建application对象，同时调用onCreate回调。 12345678910111213141516171819202122232425262728293031boolean attachApplicationLocked(ProcessRecord app, boolean headless) throws Exception &#123; boolean didSomething = false; final String processName = app.processName; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (headless) &#123; &#125; else if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, "Exception in new application when starting activity " + hr.intent.getComponent().flattenToShortString(), e); throw e; &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething; &#125; AMS回调完成应用端的application初始化后，会进一步调用attachApplicationLocked来继续执行activity的任务。在这个方法中首先取到前台的ActivityStack，然后找到task栈顶的activity，最后通过realStartActivityLocked来真正的启动hr所代表的activity. 1234567891011121314151617181920frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; …… mWindowManager.setAppVisibility(r.appToken, true); …… r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); …… app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, app.repProcState, r.icicle, results, newIntents, !andResume, mService.isNextTransitionForward(), profileFile, profileFd, profileAutoStop); ……&#125; 到这一步，WMS会将app的设置为可见，这里是将r.appToken作为key的，这个appToken是我们在为activity创建ActivityRecord时创建的，它作为一个Binder用来在WMS端标记我们的activity,同时也可以和WMS通信。随后通知应用端开始加载Activity,App.thread就是我们的ApplicationThread，它是在进程创建后，应用端的binder server，主要被AMS使用和应用端的通信。 12345678910111213141516171819202122232425262728293031public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token;//token? 这个token实际上就是ActivityRecord的appToken 代表了待启动的Activity r.ident = ident; r.intent = intent; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profileFile = profileName; r.profileFd = profileFd; r.autoStopProfiler = autoStopProfiler; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在scheduleLaunchActivity中构造了一个 ActivityClientRecord对象，随后发送H_LAUNCH_ACTIVITY，然后调用handleLaunchActivity。 123456789101112private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //紧接着执行resume activity的流程 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); …… &#125; ……&#125; 到这里就开始加载activity，首先是调用performLaunchActivity，这里面会去调用onCreate和onStart等回调，而handleResumeActivity中会将activity显示出来，并调用onResume回调。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; …… java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建activi的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); …… if (activity != null) &#123; //为activity创建context 实际上为contextImpl Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //调用activity的attach进行初始化 activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //回调onCreate mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart();//onStart回调 r.stopped = false; &#125; …… &#125; r.paused = true; mActivities.put(r.token, r);&#125; 这个方法主要创建activity对象，并为其创建context，实际上为contextImpl，通过attach方法将context设置到activity中。同时为activity设置window，即PhoneWindow. 随后回调onCreate，onStart等方法。 123456789101112131415161718192021final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ActivityClientRecord r = performResumeActivity(token, clearHide); …… if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView();//取到decorView decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager();//取到WindowManager实际为WindowManagerImpl WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;//window类型 测量Z序会用到 l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l);//这里会添加window到WMS中 &#125; &#125; ……&#125; 到这里就真正的将activity相应的window添加到了WMS中，activity被显示在桌面上。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zygote进程启动过程分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-system-zygote-startup%2F</url>
    <content type="text"><![CDATA[zygote进程定义 Init进程是Android系统中用户空间的第一个进程， 它最重要的工作就是创建zygote进程。而在Android系统中，所有应用程序的进程以及系统服务进程SystemServer都是由Zygote进程孕育出来的。所有Zygote的地位非同小可，本文就分析它的启动过程。 Android系统启动后运行的第一个进程是init进程，它的目录在system/core/init/init.cpp 在这里会进行启动属性服务以及解析init.rc文件，init.rc文件是android系统的配置文件，它如下格式所示： 12345678system/core/rootdir/init.rcservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 每一个service命令都会促使init进程调用fork函数来创建一个新的进程，这里service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process，后面的则是要传给app_process的参数。class main指的是zygote的class name为main。 zygote要执行的程序是system/bin/app_process这样会进入main函数。在main中会执行AppRuntime的start来进一步启动zygote。 frameworks/base/cmds/app_process/app_main.cpp 1234567int main(int argc, char* const argv[])&#123;……runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);……&#125; 这里的runtime是AppRuntime的实例，AppRuntime是继承自AndroidRuntime，这里的start方法就是在AndroidRuntime里定义的。 //启动android运行时 这包括了启动虚拟机和调用callName所定义的静态main方法 这里时指com.android.internal.os.ZygoteInit frameworks/base/core/jni/AndroidRuntime.cpp 123456789101112131415161718192021222324252627282930void AndroidRuntime::start(const char* className, const char* options)&#123; …… JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env) != 0) &#123;//启动虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123;//在虚拟机中注册function ALOGE("Unable to register all android natives\n"); return; &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName);//找到ZygoteInit类 if (startClass == NULL) &#123; ALOGE("JavaVM unable to locate class '%s'\n", slashClassName); /* keep going */ &#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, "main", "([Ljava/lang/String;)V");//调用静态main方法 &#125;&#125; Zygote进程在启动时会创建JavaVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个JavaVM的实例拷贝.在启动zygote时传递进来的类为com.android.internal.os.ZygoteInit，这里通过反射的方式来调用其main方法进一步完成启动初始化的过程。 123456789101112131415161718192021222324252627282930//在AndroidRuntime的start方法通过反射调用的public static void main(String argv[]) &#123; try &#123; // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); registerZygoteSocket();//注册zygote本地Socket服务 监听来自AMS的创建应用进程请求 EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload();//预加载 一些资源，类等 …… if (argv[1].equals("start-system-server")) &#123; startSystemServer();//启动SystemServer进程 &#125; else if (!argv[1].equals("")) &#123; throw new RuntimeException(argv[0] + USAGE_STRING); &#125; Log.i(TAG, "Accepting command socket connections"); runSelectLoop();//等待客户端请求 closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run();// &#125; catch (RuntimeException ex) &#123; Log.e(TAG, "Zygote died with exception", ex); closeServerSocket(); throw ex; &#125;&#125; 在zygote的初始化中，做了以下几件事件： 通过registerServerSocket创建zygote的socket服务，它是一个LocalSocketServer用来等待AMS请求zygote创建应用进程的请求。 监听socket服务，等待AMS创建应用程序的请求 创建SystemServer进程 值得注意的是，无论是创建systemServer进程还是创建应用进程，最终都会通过捕获MethodAndArgsCaller异常来执行参数指定的class的main方法，后面我们分析SystemServer启动及应用进程的启动时就会看到。 这里我们接着看看注册socket服务的代码，它仅仅是创建了LocalServerSocket的本地socket对象 1234567891011121314151617181920private static void registerZygoteSocket() &#123; if (sServerSocket == null) &#123; int fileDesc; try &#123; String env = System.getenv(ANDROID_SOCKET_ENV); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException( ANDROID_SOCKET_ENV + " unset or invalid", ex); &#125; try &#123; sServerSocket = new LocalServerSocket( createFileDescriptor(fileDesc)); &#125; catch (IOException ex) &#123; throw new RuntimeException( "Error binding to local socket '" + fileDesc + "'", ex); &#125; &#125;&#125; SystemServer进程的创建流程 这里我们重点关注SystemServer的创建流程，继续关注startSystemServer 1234567891011121314151617181920212223242526272829303132333435363738394041private static boolean startSystemServer() throws MethodAndArgsCaller, RuntimeException &#123; …… /* Hardcoded command line to start the system server */ String args[] = &#123; "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007", "--capabilities=" + capabilities + "," + capabilities, "--runtime-init", "--nice-name=system_server", "com.android.server.SystemServer", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);//fork 出systemServer进程 &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; handleSystemServerProcess(parsedArgs);//在子进程中调用 &#125; return true;&#125; 在startSystemServer中仅仅fork出进程后随后进一步在handleSystemServerProcess中进一步对SystemServer进行初始化 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112131415161718192021222324252627private static void handleSystemServerProcess(//进一步处理SystemServer进程的相关工作 ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket();//关闭从父进程继承来的socket // set umask to 0077 so new files and directories will default to owner-only permissions. Libcore.os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, parsedArgs.remainingArgs); &#125; else &#123; /* * Pass the remaining arguments to SystemServer. */ //此时的remainingArgs就是”com.android.server.SystemServer” RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs); &#125; /* should never reach here */&#125; 这里进一步调用zygoteInit进行初始化工作 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678910public static final void zygoteInit(int targetSdkVersion, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote"); redirectLogStreams(); commonInit(); nativeZygoteInit();//zygote本地初始化 applicationInit(targetSdkVersion, argv);////应用层的初始化 &#125; 首先我们来看第一个方法nativeZygoteInit的调用，这个方法时在AndroidRuntime中定义的，具体是 /frameworks/base/core/jni/AndroidRuntime.cpp 12345static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; 这里的onZygoteInit是调用其子类AppRuntime的方法,zygote的启动就是通过这个类调用start方法来执行的。 frameworks/base/cmds/app_process/app_main.cpp 123456789virtual void onZygoteInit()&#123; // Re-enable tracing now that we're no longer in Zygote. atrace_set_tracing_enabled(true); sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV("App process: starting thread pool.\n"); proc-&gt;startThreadPool();&#125; ProcessState对于binder机制非常重要，这里主要是初始化SystemServer进程的的binder环境，这样在其进程中就可以通过binder同其他进程进行通信了。 下面我们来看看第二个方法applicationInit，这个方法第二个参数包含了调用了类的信息及相关方法的参数，这里就是“com.android.server.SystemServer”和main方法 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 123456private static void applicationInit(int targetSdkVersion, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; …… // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs); &#125; 这个方法内部会调用invokeStaticMain方法。 123456789101112131415161718192021222324//这个方法最终会抛出异常MethodAndArgsCaller触发其run方法的调用，具体见ZygoteInit的main方法private static void invokeStaticMain(String className, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className);//获取类信息 可能是SystemServer或者ActivityThread &#125; catch (ClassNotFoundException ex) &#123; &#125; Method m; try &#123; m = cl.getMethod("main", new Class[] &#123; String[].class &#125;);//获取对应类的main方法 &#125; catch ()&#123;&#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ //抛出异常，通过MethodAndArgsCaller的run方法会去调用main方法 throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; MethodAndArgsCaller的定义如下,这里我们重点看看run方法,run方法的实现很简单只是对main方法进行调用。即调用SystemServer的main方法完成SystemServer进程的创建和启动。 1234567891011121314public static class MethodAndArgsCaller extends Exception implements Runnable &#123; /** method to call */ private final Method mMethod;//调用的方法，这里就是main方法了 /** argument array */ private final String[] mArgs;//参数…… public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125;catch()&#123;…&#125; &#125;&#125; 应用进程的创建启动过程 接下来我们分析应用进程创建和启动的过程，这个过程中需要AMS的介入，不过这里我们重点关注应用进程的创建和启动过程，而不需要关注整个流程的太多细节。熟悉AMS的应该知道，当我们点击Launcher启动应用程序后 最终会通过AMS的startProcessLocked方法来为我们的应用程序创建进程，而其内部会进一步调用startProcessLocked来完成，所以我们重点看那startProcessLocked方法。 frameworks/base/services/java/com/android/server/am/ActivityManagerService.java 12345678910private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. Process.ProcessStartResult startResult = Process.start("android.app.ActivityThread", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); ……&#125; 这个方法会通过Process的start方法类完成进程的创建，这里我们传递ActivityThread的类名，再我们创建完应用进程后需要就是调用其内部的main方法完成启动过程。下面我们继续去看下进程是如何创建的。 frameworks/base/core/java/android/os/Process.java 1234567891011public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids,debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; &#125;&#125; Process的start方法很简单，调用startViaZygote，从其名称来看就是通过zygote来创建我们应用进程了。 这里的processClass就是我们的ActivityThread类，niceName是进程名称。startViaZygote通过将这一些参数打包到一个ArrayList变量中然后调用zygoteSendArgsAndGetResult，并将打包的参数传递给它。这个方法负责将这些参数通过socket传递给zygote. 123456789101112131415161718192021222324252627private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; openZygoteSocketIfNeeded(); try &#123; sZygoteWriter.write(Integer.toString(args.size())); sZygoteWriter.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); if (arg.indexOf('\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx( "embedded newlines not allowed"); &#125; sZygoteWriter.write(arg); sZygoteWriter.newLine(); &#125; sZygoteWriter.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = sZygoteInputStream.readInt(); …… &#125; catch (IOException ex) &#123; &#125;&#125; 这个方法首先通过openZygoteSocketIfNeeded方法来打开同zygote通信的socket,并用该socket创建一个 BufferedWriter对象sZygoteWrite，随后通过sZygoteWrite将参数发送给zygote,同时创建一个ProcessStartResult对象，用来保存创建的进程信息。 对于zygote端我们知道，当zygote启动后会先注册一个LocalSocketServer服务，然后通过runSelectLoop等待来自AMS创建进程的请求。这里我们就需要看看runSelectLoop方法。 12345678910111213141516171819202122232425private static void runSelectLoop() throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); FileDescriptor[] fdArray = new FileDescriptor[4]; …… while (true) &#123; int index; …… if (index &lt; 0) &#123; throw new RuntimeException("Error in select()"); &#125; else if (index == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done; done = peers.get(index).runOnce(); if (done) &#123; peers.remove(index); fds.remove(index); &#125; &#125; &#125;&#125; runSelectLoop方法主要负责处理客户端的连接请求和客户端的消息处理，当index==0是说明有新的客户端连接，index&gt;0则说明有消息到来，index指定了客户端的连接索引。同时会调用runOnce对消息机型处理。 1234567891011121314151617181920212223242526272829//zygote收到客户端AMS的信息进行处理boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; …… try &#123; args = readArgumentList();//读取客户端发送的消息 得到参数列表 descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; &#125; …… try &#123; parsedArgs = new Arguments(args); …… pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);//创建应用进程 &#125; catch () &#123;&#125; …… try &#123; if (pid == 0) &#123; …… //继续处理子进程 这里面最终会抛出ZygoteInit.MethodAndArgsCaller来触发其run方法的调用 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123;………&#125; &#125; finally &#123; &#125;&#125; 在这个方法中首先通过readArgumentList方法读取客户端发送的消息，得到参数列表，随后根据参数创建应用进程，随后进一步调用handleChildProc进一步完成子进程的创建。在这个方法中最终会抛出MethodAndArgsCaller异常来触发run方法的调用，就如SystemServer进程那样。 1234567891011121314151617private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; …… if (parsedArgs.invokeWith != null) &#123; WrapperInit.execStandalone(parsedArgs.invokeWith, parsedArgs.classpath, className, mainArgs); &#125; else &#123; …… try &#123; ZygoteInit.invokeStaticMain(cloader, className, mainArgs);//最终会调用invokeStaticMain方法抛出异常 &#125; catch (RuntimeException ex) &#123; logAndPrintError(newStderr, "Error starting.", ex); &#125; &#125;&#125; 这个方法会调用invokeStaticMain，这个方法我们在SystemServer启动时候分析过，这里就不再分析了。最终会调用ActivityThread的main方法完成应用进程的启动。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView的源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-listview-src%2F</url>
    <content type="text"><![CDATA[ListView是Android最重要的控件之一，它用来展示一组数据，通过一个适配器和数据源关联，实现了数据和视图的分离， 它的特点就是能够加载大量数据视图而不会导致OOM，本篇将会对其内部实现进行分析。 ###ListView的继承关系 public class ListView extends AbsListView{} public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback {} public abstract class AdapterView&lt;T extends Adapter&gt; extends ViewGroup {} ListView继承自AbsListView(GridView也是继承于此)，AbsListView它是一种抽象的ListView，它内部维护了和这个抽象List相关联的数据适配器ListAdapter，同时了它内部有一个RecycleBin类，它是负责View回收和重用的，这也是它能够加载大量数据视图不会崩溃的原因。至于详细的回收和重用过程，我们下面进行分析。AbsListView继承自AdapterView，AdapterView是一个ViewGroup，它的子View是通过Adapter来决定的。 了解了ListView的继承结构，接下来，我们将对ListView的回收和重用机制进行分析。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-surfaceview-src%2F</url>
    <content type="text"><![CDATA[SurfaceView介绍 SurfaceView是Andoird GUI系统中一种特殊的控件，它可以在非UI线程进行绘图。UI线程的绘制在view绘制流程一篇中介绍过了，本篇将对SurfaceView的绘制进行介绍。在此之前，我们看看SurfaceView的一般用法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SurfaceViewDemo extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mHolder; private Canvas mCanvas; private boolean bDrawing; public SurfaceViewDemo(Context context) &#123; super(context); initView(); &#125; public SurfaceViewDemo(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public SurfaceViewDemo(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mHolder = getHolder(); mHolder.addCallback(this); setFocusable(true); setFocusableInTouchMode(true); this.setKeepScreenOn(true); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; while (bDrawing) &#123; draw(); &#125; &#125; private void draw() &#123; try &#123; mCanvas = mHolder.lockCanvas(); // draw something &#125; catch (Exception e) &#123; &#125; finally &#123; if (mCanvas != null) mHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;&#125; SurfaceView的生命周期回调surfaceCreated-&gt;SurfaceChanged-&gt;surfaceDestroyed。这里在surfaceCreated中进行绘制，这个绘制可以在单独的线程中进行，并不依赖于ui线程。至于为何这样，后面我们再解释。 首先看看surfaceview的源码，先看其成员都有哪些 123456789101112131415161718192021222324252627282930313233public class SurfaceView extends View &#123; static private final String TAG = "SurfaceView"; static private final boolean DEBUG = false; final ArrayList&lt;SurfaceHolder.Callback&gt; mCallbacks = new ArrayList&lt;SurfaceHolder.Callback&gt;(); final int[] mLocation = new int[2]; final ReentrantLock mSurfaceLock = new ReentrantLock(); final Surface mSurface = new Surface(); // Current surface in use surfaceView使用的绘图表面 final Surface mNewSurface = new Surface(); // New surface we are switching to boolean mDrawingStopped = true; final WindowManager.LayoutParams mLayout = new WindowManager.LayoutParams(); IWindowSession mSession; MyWindow mWindow; final Rect mVisibleInsets = new Rect(); final Rect mWinFrame = new Rect(); final Rect mOverscanInsets = new Rect(); final Rect mContentInsets = new Rect(); final Configuration mConfiguration = new Configuration(); static final int KEEP_SCREEN_ON_MSG = 1; static final int GET_NEW_SURFACE_MSG = 2; static final int UPDATE_WINDOW_MSG = 3; int mWindowType = WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA; boolean mIsCreating = false; ……&#125; 在SurfaceView中有两个Surface绘图表面，所有绘制操作都是在这个绘图表面上进行的，这里有两个Surface是为了进行绘图时的前后台切换，这样当后台进行绘制时，前台可以显示之前绘制好的Surface表面。IWindowSession是用来和WMS进行会话的session，因为SurfaceView它本质上也是一个Window，它还有一个MyWindow成员，它类似于ViewRootImpl中的W对象，是用来和WMS进行通信交互的。因此它也是一个Binder对象，在WMS一端，它唯一标志了一个窗口对象Window。 SurfaceView的绘制流程 SurfaceView的绘制依然属于view树绘制的一部分，它依赖于宿主窗口，在View树的绘制流程中，我们看看SurfaceView是如何进行自身的绘制的，在performTraversals中绘制view树之前，会通知view树Attach到宿主窗口上，这是通过host.dispatchAttachedToWindow(attachInfo, 0)来实现的，这里的host即DecorView，它是个ViewGroup。在ViewGroup中又会调用子view的dispatchAttachedToWindow方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//ViewGroup@Overridevoid dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility); mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount;//子视图的数目 final View[] children = mChildren;//子视图数组 for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags &amp; VISIBILITY_MASK));//通知每个子视图他们被添加到宿主窗口上去了 &#125;&#125;//viewvoid dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mAttachInfo = info;//保存所附加窗口的信息 if (mOverlay != null) &#123; mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility); &#125; mWindowAttachCount++; // We will need to evaluate the drawable state at least once. mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY; if (mFloatingTreeObserver != null) &#123; info.mTreeObserver.merge(mFloatingTreeObserver); mFloatingTreeObserver = null; &#125; if ((mPrivateFlags&amp;PFLAG_SCROLL_CONTAINER) != 0) &#123; mAttachInfo.mScrollContainers.add(this); mPrivateFlags |= PFLAG_SCROLL_CONTAINER_ADDED; &#125; performCollectViewAttributes(mAttachInfo, visibility); onAttachedToWindow();//onAttachedToWindow 让子类处理它被附加到宿主窗口时的事件 ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) &#123; for (OnAttachStateChangeListener listener : listeners) &#123; listener.onViewAttachedToWindow(this); &#125; &#125; int vis = info.mWindowVisibility; if (vis != GONE) &#123; onWindowVisibilityChanged(vis);//通知宿主窗口的可见性发生了变化 &#125; if ((mPrivateFlags&amp;PFLAG_DRAWABLE_STATE_DIRTY) != 0) &#123; // If nobody has evaluated the drawable state yet, then do it now. refreshDrawableState(); &#125; needGlobalAttributesUpdate(false);&#125; 对于子View，它的dispatchAttachedToWindow会回调onAttachedToWindow通知view被添加到宿主window上，随后宿主窗口可见，还会通过onWindowVisibilityChanged通知可见性发生了变化。这里我们看看SurfaceView它是如何做处理的。 1234567891011121314151617//surfaceView被添加到宿主窗口时回调@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mParent.requestTransparentRegion(this);//请求父窗口设置一块透明区域 即 在父窗口视图上挖一个洞 mParent为其父类View mSession = getWindowSession();//获取IWindowSession 这是一个binder负责和WMS通信 后续通过这个session来向WMS请求绘图表面 mLayout.token = getWindowToken();//这个token也是ViewRootImpl中的W mLayout.setTitle("SurfaceView"); mViewVisibility = getVisibility() == VISIBLE; if (!mGlobalListenersAdded) &#123; ViewTreeObserver observer = getViewTreeObserver(); observer.addOnScrollChangedListener(mScrollChangedListener); observer.addOnPreDrawListener(mDrawListener); mGlobalListenersAdded = true; &#125;&#125; 在SurfaceView的onAttachedToWindow中，SurfaceView会向父窗口请求设置一块透明区域，这个透明区域是为了使SurfaceView在宿主窗口中可见，因为SurfaceView被添加时它的Z序是小于宿主窗口的，即它是显示在宿主窗口下面的，要显示SurfaceView就需要在宿主窗口设置对应大小的透明区域。同时还会取到IWindowSession 用来和WMS进行通信。 123456789 @Overrideprotected void onWindowVisibilityChanged(int visibility) &#123;//宿主窗口的可见性发生了变化 super.onWindowVisibilityChanged(visibility); //mWindowVisibility表示SurfaceView的宿主窗口的可见性，mViewVisibility表示SurfaceView自身的可见性。 //只有当mWindowVisibility和mViewVisibility的值均等于true的时候，mRequestedVisible的值才为true，表示SurfaceView是可见的 mWindowVisibility = visibility == VISIBLE; mRequestedVisible = mWindowVisibility &amp;&amp; mViewVisibility; updateWindow(false, false);&#125; 关于可见性的变化，SurfaceView计算当前宿主窗口的可见性，并通过updateWindow来更新自身的窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136private void updateWindow(boolean force, boolean redrawNeeded) &#123; …… getLocationInWindow(mLocation); final boolean creating = mWindow == null; final boolean formatChanged = mFormat != mRequestedFormat; final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight; final boolean visibleChanged = mVisible != mRequestedVisible; if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) &#123; try &#123; final boolean visible = mVisible = mRequestedVisible; mLeft = mLocation[0]; mTop = mLocation[1]; mWidth = myWidth; mHeight = myHeight; mFormat = mRequestedFormat; // Places the window relative mLayout.x = mLeft; mLayout.y = mTop; mLayout.width = getWidth(); mLayout.height = getHeight(); if (mTranslator != null) &#123; mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout); &#125; mLayout.format = mRequestedFormat; mLayout.flags |=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) &#123; mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; &#125; mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION; if (mWindow == null) &#123; Display display = getDisplay(); mWindow = new MyWindow(this); mLayout.type = mWindowType; mLayout.gravity = Gravity.START|Gravity.TOP; mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets); //为surfaceview添加窗口，对应于WMS一端 &#125; boolean realSizeChanged; boolean reportDrawNeeded; int relayoutResult; mSurfaceLock.lock(); try &#123; mUpdateWindowNeeded = false; reportDrawNeeded = mReportDrawNeeded; mReportDrawNeeded = false; mDrawingStopped = !visible; relayoutResult = mSession.relayout( mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mConfiguration, mNewSurface);//计算窗口大小，分配绘图表面 if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mReportDrawNeeded = true; &#125; mSurfaceFrame.left = 0; mSurfaceFrame.top = 0; if (mTranslator == null) &#123; mSurfaceFrame.right = mWinFrame.width(); mSurfaceFrame.bottom = mWinFrame.height(); &#125; else &#123; float appInvertedScale = mTranslator.applicationInvertedScale; mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f); mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f); &#125; final int surfaceWidth = mSurfaceFrame.right; final int surfaceHeight = mSurfaceFrame.bottom; realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight; mLastSurfaceWidth = surfaceWidth; mLastSurfaceHeight = surfaceHeight; &#125; finally &#123; mSurfaceLock.unlock(); &#125; …… if (visible &amp;&amp; mSurface.isValid()) &#123; if (!mSurfaceCreated &amp;&amp; (surfaceChanged || visibleChanged)) &#123; mSurfaceCreated = true; mIsCreating = true; if (DEBUG) Log.i(TAG, "visibleChanged -- surfaceCreated"); if (callbacks == null) &#123; callbacks = getSurfaceCallbacks(); &#125; for (SurfaceHolder.Callback c : callbacks) &#123; c.surfaceCreated(mSurfaceHolder); &#125; &#125; if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) &#123; if (DEBUG) Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight); if (callbacks == null) &#123; callbacks = getSurfaceCallbacks(); &#125; for (SurfaceHolder.Callback c : callbacks) &#123; c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight); &#125; &#125; if (redrawNeeded) &#123; if (DEBUG) Log.i(TAG, "surfaceRedrawNeeded"); if (callbacks == null) &#123; callbacks = getSurfaceCallbacks(); &#125; for (SurfaceHolder.Callback c : callbacks) &#123; if (c instanceof SurfaceHolder.Callback2) &#123; ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded( mSurfaceHolder); &#125; &#125; &#125; &#125; …… &#125; catch (RemoteException ex) &#123;&#125; &#125;&#125; 对于SurfaceView来说，它拥有独立的Window，这个Window同样受WMS的管理，因此在绘制时需要将该Window添加到WMS中去，同时，它也有它自己的绘图表面，因此在绘制之前需要计算它自身的窗口大小并向WMS请求绘图表面。关于分配绘图缓冲在其它章节已做了描述，本篇不再多做介绍。 SurfaceView的挖洞过程 SurfaceView的窗口类型一般都是TYPE_APPLICATION_MEDIA或者TYPE_APPLICATION_MEDIA_OVERLAY,它在添加到宿主窗口上时，会在父窗口的表面设置一个透明区域以显示SurfaceView自身的内容，这是通过requestTransparentRegion来进行的，下面我们就看看这个过程是如何完成的。 123456789101112131415161718192021222324//ViewGrouppublic void requestTransparentRegion(View child) &#123; if (child != null) &#123; child.mPrivateFlags |= View.PFLAG_REQUEST_TRANSPARENT_REGIONS; if (mParent != null) &#123; mParent.requestTransparentRegion(this); &#125; &#125;&#125;//ViewRootImpl @Overridepublic void requestTransparentRegion(View child) &#123; // the test below should not fail unless someone is messing with us checkThread(); if (mView == child) &#123; mView.mPrivateFlags |= View.PFLAG_REQUEST_TRANSPARENT_REGIONS; // Need to make sure we re-evaluate the window attributes next // time around, to ensure the window has the correct format. mWindowAttributesChanged = true; mWindowAttributesChangesFlag = 0; requestLayout(); &#125;&#125; SurfaceView请求透明区域的过程实际上为父View打上PFLAG_REQUEST_TRANSPARENT_REGIONS标记，这表示它要在宿主窗口上设置透明区域，这个过程直到ViewRootImpl，ViewRootImpl它也是ViewParent，它将调用requestLayout触发performTraversals来请求窗口重新布局和绘制，从而收集透明区域，最后通过WMS为该宿主窗口设置一个总的透明区域。 12345678910111213141516171819202122232425private void performTraversals() &#123; …… if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123; host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) &#123; mTranslator.translateRegionInWindowToScreen(mTransparentRegion); &#125; if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123; mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try &#123; mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; ……&#125; 收集透明区域也是从DecorView开始的，它调用gatherTransparentRegion来完成,这个区域是由mTransparentRegion来存储维护的。如果透明区域发生了变化这时候就需要重新设置该透明区域到WMS中去。 1234567891011121314151617181920212223//ViewGroup.java@Overridepublic boolean gatherTransparentRegion(Region region) &#123; // If no transparent regions requested, we are always opaque. final boolean meOpaque = (mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0; if (meOpaque &amp;&amp; region == null) &#123; // The caller doesn't care about the region, so stop now. return true; &#125; super.gatherTransparentRegion(region); final View[] children = mChildren; final int count = mChildrenCount; boolean noneOfTheChildrenAreTransparent = true; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; if (!child.gatherTransparentRegion(region)) &#123; noneOfTheChildrenAreTransparent = false; &#125; &#125; &#125; return meOpaque || noneOfTheChildrenAreTransparent;&#125; 收集透明区域会遍历父view下的所有子view的透明区域。在开始收集之前，首先将透明区域设置为DecorView视图的大小，然后遍历子view，如果view是不透明的区域则将其从初始的透明区域中移除，这样最后保留下来的就是需要设置的透明区域。 下面我们看看SurfaceView它是如何进行计算它的透明区域的。 1234567891011121314151617181920212223242526@Overridepublic boolean gatherTransparentRegion(Region region) &#123; if (mWindowType == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123; return super.gatherTransparentRegion(region); &#125; boolean opaque = true; if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == 0) &#123; // this view draws, remove it from the transparent region opaque = super.gatherTransparentRegion(region); &#125; else if (region != null) &#123; int w = getWidth(); int h = getHeight(); if (w&gt;0 &amp;&amp; h&gt;0) &#123; getLocationInWindow(mLocation); // otherwise, punch a hole in the whole hierarchy int l = mLocation[0]; int t = mLocation[1]; region.op(l, t, l+w, t+h, Region.Op.UNION); &#125; &#125; if (PixelFormat.formatHasAlpha(mRequestedFormat)) &#123; opaque = false; &#125; return opaque;&#125; SurfaceView首先判断窗口类型是否作为WindowManager.LayoutParams.TYPE_APPLICATION_PANEL，如果是则表示SurfaceView是用来作为应用面板的，这时候调用父类view的gatherTransparentRegion来处理，如果需要绘制，则将view的绘制区域从从参数region所描述的透明区域中移除。 SurfaceView的绘制 SurfaceView具有独立的绘图Surface,但它仍然属于View树中的子节点，它依附在宿主窗口上，所以它自身的view也是需要绘制到宿主窗口的Surface上的。在介绍view绘制流程一节中我们知道了view的绘制会触发draw和dispatchDraw方法，前者绘制它自身，后者负责绘制子view。 123456789101112131415161718192021222324//SurfaceView.java@Overridepublic void draw(Canvas canvas) &#123; if (mWindowType != WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123; // draw() is not called when SKIP_DRAW is set if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == 0) &#123; // punch a whole in the view-hierarchy below us canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; &#125; super.draw(canvas);&#125;@Overrideprotected void dispatchDraw(Canvas canvas) &#123; if (mWindowType != WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123; // if SKIP_DRAW is cleared, draw() has already punched a hole if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; // punch a whole in the view-hierarchy below us canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; &#125; super.dispatchDraw(canvas);&#125; draw和dispatchDraw方法的参数canvas代表的是宿主窗口的绘图表面的画布，这表示surfaceview自身的ui是绘制在 宿主绘图表面上的，如果mWindowType不为WindowManager.LayoutParams.TYPE_APPLICATION_PANEL表示SurfaceView不作为应用面板，那么将其view所占区域设置为黑色。 除了在宿主窗口上绘制ui，SurfaceView可以在自身的绘图表面上绘制内容，一般的绘制流程如下： 12345678SurfaceView sv = (SurfaceView )findViewById(R.id.surface_view); SurfaceHolder sh = sv.getHolder(); Cavas canvas = sh.lockCanvas() //Draw something on canvas ...... sh.unlockCanvasAndPost(canvas); 需要注意的是，当绘图表面的类型设置为SURFACE_TYPE_PUSH_BUFFERS时，表示绘图表面的缓冲区不受我们控制，它是由摄像头或者视频播放服务来提供的。因此不能在随意在上面进行内容绘制。 1234567891011121314151617181920212223242526272829303132333435363738 @Overridepublic Canvas lockCanvas() &#123; return internalLockCanvas(null);&#125;private final Canvas internalLockCanvas(Rect dirty) &#123; mSurfaceLock.lock(); Canvas c = null; if (!mDrawingStopped &amp;&amp; mWindow != null) &#123; try &#123; c = mSurface.lockCanvas(dirty); &#125; catch (Exception e) &#123; Log.e(LOG_TAG, "Exception locking surface", e); &#125; &#125; if (c != null) &#123; mLastLockTime = SystemClock.uptimeMillis(); return c; &#125; // If the Surface is not ready to be drawn, then return null, // but throttle calls to this function so it isn't called more // than every 100ms. long now = SystemClock.uptimeMillis(); long nextTime = mLastLockTime + 100; if (nextTime &gt; now) &#123; try &#123; Thread.sleep(nextTime-now); &#125; catch (InterruptedException e) &#123; &#125; now = SystemClock.uptimeMillis(); &#125; mLastLockTime = now; mSurfaceLock.unlock(); return null;&#125; SurfaceView的lockCanvas是从其绘图表面申请缓冲区，也就是Canvas，应用上层可以使用这个Canvas来进行内容的绘制，需要注意的是这个画布并不是线程安全的，需要通过mSurfaceLock的锁保护。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-camera-1-src%2F</url>
    <content type="text"><![CDATA[本篇我们主要针对HAL1.0介绍Camera提供的服务，分析Camera打开过程。 打开过程 这里我们看下CameraService的connect。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//最终打开摄像头会调用Service的connectstatus_t CameraService::connect( const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId, const String16&amp; clientPackageName, int clientUid, /*out*/ sp&lt;ICamera&gt;&amp; device) &#123; String8 clientName8(clientPackageName); int callingPid = getCallingPid();//获取调用者的进程id LOG1("CameraService::connect E (pid %d \"%s\", id %d)", callingPid, clientName8.string(), cameraId); status_t status = validateConnect(cameraId, /*inout*/clientUid);//连接之前的校验 if (status != OK) &#123; return status; &#125; sp&lt;Client&gt; client; &#123; Mutex::Autolock lock(mServiceLock);//连接过程要加锁 sp&lt;BasicClient&gt; clientTmp; if (!canConnectUnsafe(cameraId, clientPackageName, cameraClient-&gt;asBinder(), /*out*/clientTmp)) &#123;//确保本次连接是安全的 return -EBUSY; &#125; else if (client.get() != NULL) &#123; device = static_cast&lt;Client*&gt;(clientTmp.get()); return OK; &#125; int facing = -1; int deviceVersion = getDeviceVersion(cameraId, &amp;facing);//获取设备版本 // If there are other non-exclusive users of the camera, // this will tear them down before we can reuse the camera if (isValidCameraId(cameraId)) &#123;//有效的摄像头id // transition from PRESENT -&gt; NOT_AVAILABLE updateStatus(ICameraServiceListener::STATUS_NOT_AVAILABLE, cameraId);//更新状态 &#125; switch(deviceVersion) &#123;//根据设备版本 创建Client对象 case CAMERA_DEVICE_API_VERSION_1_0: client = new CameraClient(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid()); break; case CAMERA_DEVICE_API_VERSION_2_0: case CAMERA_DEVICE_API_VERSION_2_1: case CAMERA_DEVICE_API_VERSION_3_0: client = new Camera2Client(this, cameraClient, clientPackageName, cameraId, facing, callingPid, clientUid, getpid(), deviceVersion); break; case -1: ALOGE("Invalid camera id %d", cameraId); return BAD_VALUE; default: ALOGE("Unknown camera device HAL version: %d", deviceVersion); return INVALID_OPERATION; &#125; status_t status = connectFinishUnsafe(client, client-&gt;getRemote());//会调用client的initialize方法进行初始化 if (status != OK) &#123; // this is probably not recoverable.. maybe the client can try again // OK: we can only get here if we were originally in PRESENT state updateStatus(ICameraServiceListener::STATUS_PRESENT, cameraId); return status; &#125; mClient[cameraId] = client;//保存client LOG1("CameraService::connect X (id %d, this pid is %d)", cameraId, getpid()); &#125; // important: release the mutex here so the client can call back // into the service from its destructor (can be at the end of the call) device = client;//Client作为ICamera接口返回给客户端 客户端可以使用该接口跟Camera进行交互 return OK;&#125; 客户端在打开摄像头时最终会调用到这个方法，并未其创建了CameraClient对象，这里针对API为1.0时介绍，所以重点关注CameraClient的创建过程及初始化流程，看看它是如何提供摄像头的服务的。在创建完client对象后，在connectFinishUnsafe会对其进行初始化，即调用client-&gt;initialize(mModule)方法这个mModule即是底层的Camera模块，其初始化是在CameraService的onFirstRef中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void CameraService::onFirstRef()&#123; LOG1("CameraService::onFirstRef"); BnCameraService::onFirstRef(); if (hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;mModule) &lt; 0) &#123;//获取Camera HAL层的Module ALOGE("Could not load camera HAL module"); mNumberOfCameras = 0; &#125; else &#123; ALOGI("Loaded \"%s\" camera module", mModule-&gt;common.name); mNumberOfCameras = mModule-&gt;get_number_of_cameras();//通过module的接口获取摄像头数目 if (mNumberOfCameras &gt; MAX_CAMERAS) &#123; ALOGE("Number of cameras(%d) &gt; MAX_CAMERAS(%d).", mNumberOfCameras, MAX_CAMERAS); mNumberOfCameras = MAX_CAMERAS; &#125; for (int i = 0; i &lt; mNumberOfCameras; i++) &#123; setCameraFree(i); &#125; if (mModule-&gt;common.module_api_version &gt;= CAMERA_MODULE_API_VERSION_2_1) &#123; mModule-&gt;set_callbacks(this);//设置摄像头状态回调 onDeviceStatusChanged &#125; CameraDeviceFactory::registerService(this); &#125;&#125;status_t CameraClient::initialize(camera_module_t *module) &#123; int callingPid = getCallingPid(); status_t res; LOG1("CameraClient::initialize E (pid %d, id %d)", callingPid, mCameraId); // Verify ops permissions res = startCameraOps();//校验权限 if (res != OK) &#123; return res; &#125; char camera_device_name[10]; snprintf(camera_device_name, sizeof(camera_device_name), "%d", mCameraId); mHardware = new CameraHardwareInterface(camera_device_name);//创建Camera的硬件接口对象 res = mHardware-&gt;initialize(&amp;module-&gt;common);//初始化该对象 包括打开摄像头模块 初始化预览窗口回调等 if (res != OK) &#123; ALOGE("%s: Camera %d: unable to initialize device: %s (%d)", __FUNCTION__, mCameraId, strerror(-res), res); mHardware.clear(); return NO_INIT; &#125; mHardware-&gt;setCallbacks(notifyCallback, dataCallback, dataCallbackTimestamp, (void *)mCameraId);//设置时间回调和数据回调 // Enable zoom, error, focus, and metadata messages by default enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS | CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE); LOG1("CameraClient::initialize X (pid %d, id %d)", callingPid, mCameraId); return OK;&#125; initialize这个方法比较重要，它主要做了下面几件事： 创建CameraHardwareInterface对象，CameraHardwareInterface是HAL层的接口对象，CameraClient的所提供的服务最终会转向这个接口对象。在HAL1.0中，这个对象是同HAL层进行交互的桥梁。 初始化该接口对象，包括打开摄像头模块 初始化预览窗口回调等 调用setCallbacks来设置回调，比如数据的回调，通知消息的回调，这些回调方法都是在CameraClient中实现，即底层会将相关的消息或者数据通过这些方法回调给上层。 我们看看CameraHardwareInterface初始化过程 123456789101112status_t initialize(hw_module_t *module)&#123; ALOGI("Opening camera %s", mName.string()); int rc = module-&gt;methods-&gt;open(module, mName.string(), (hw_device_t **)&amp;mDevice);//通过HAL的接口打开摄像头 同时构造mDevice if (rc != OK) &#123; ALOGE("Could not open camera %s: %d", mName.string(), rc); return rc; &#125; initHalPreviewWindow();//初始化预览窗口 return rc;&#125; 这个方法纯粹只是打开了HAL module的open方法，会调用底层驱动的打开方法，这个方法会返回一个mDevice，这个mDevice是HAL层定义的camera_device_t结构 12345678910typedef struct camera_device &#123; /** * camera_device.common.version must be in the range * HARDWARE_DEVICE_API_VERSION(0,0)-(1,FF). CAMERA_DEVICE_API_VERSION_1_0 is * recommended. */ hw_device_t common; camera_device_ops_t *ops; void *priv; &#125; camera_device_t; //对应的是1.0的DEVICE_API camera_device_ops_t是摄像头定义的一系列服务接口，如int (*take_picture)(struct camera_device *); CameraHardwareInterface层向上提供的服务都是通过HAL层的这些接口完成。 接着初始化HAL的预览窗口 12345678910111213141516void initHalPreviewWindow()&#123; mHalPreviewWindow.nw.cancel_buffer = __cancel_buffer; mHalPreviewWindow.nw.lock_buffer = __lock_buffer; mHalPreviewWindow.nw.dequeue_buffer = __dequeue_buffer; mHalPreviewWindow.nw.enqueue_buffer = __enqueue_buffer; mHalPreviewWindow.nw.set_buffer_count = __set_buffer_count; mHalPreviewWindow.nw.set_buffers_geometry = __set_buffers_geometry; mHalPreviewWindow.nw.set_crop = __set_crop; mHalPreviewWindow.nw.set_timestamp = __set_timestamp; mHalPreviewWindow.nw.set_usage = __set_usage; mHalPreviewWindow.nw.set_swap_interval = __set_swap_interval; mHalPreviewWindow.nw.get_min_undequeued_buffer_count = __get_min_undequeued_buffer_count;&#125; 这个mHalPreviewWindow是个camera_preview_window，它的定义如下 1234struct camera_preview_window &#123; struct preview_stream_ops nw; void *user;&#125;; 这里的preview_stream_ops它是一系列关于本地窗口ANativeWindow的操作方法的接口。 回调的设置是通过setCallbacks完成 12345678910111213141516171819202122/** Set the notification and data callbacks */void setCallbacks(notify_callback notify_cb, data_callback data_cb, data_callback_timestamp data_cb_timestamp, void* user)//设置回调消息和数据回调&#123; mNotifyCb = notify_cb; mDataCb = data_cb; mDataCbTimestamp = data_cb_timestamp; mCbUser = user; ALOGV("%s(%s)", __FUNCTION__, mName.string()); if (mDevice-&gt;ops-&gt;set_callbacks) &#123; mDevice-&gt;ops-&gt;set_callbacks(mDevice, __notify_cb, __data_cb, __data_cb_timestamp, __get_memory, this); &#125;&#125; 参数notify_cb，data_cb是CameraClient的方法，这里首先对其进行了保存，并将CameraHardwareInterface自身的的__notify_cb,__data_cb等通过HAL层设置给底层驱动，这么说当数据或者消息需要通知到上层时在CameraHardwareInterface的__notify_cb，__data_cb方法是需要再转发给CameraClient的notify_cb和data_cb的。 HAL层的实现，我们这里看的是rk29的相关实现 /android4.4/hardware/rk29/camera/CameraHal_Module.cpp 这个文件中定义了HAL层的module，即HAL_MODULE_INFO_SYM，这是所有HAL层必须定义的。所有的硬件对应的module结构必须以 hw_module_t作为其第一个成员，一般就是common成员。 12345678910111213141516171819static struct hw_module_methods_t camera_module_methods = &#123; open: camera_device_open&#125;;camera_module_t HAL_MODULE_INFO_SYM = &#123; common: &#123; tag: HARDWARE_MODULE_TAG, version_major: ((CONFIG_CAMERAHAL_VERSION&amp;0xff00)&gt;&gt;8), version_minor: CONFIG_CAMERAHAL_VERSION&amp;0xff, id: CAMERA_HARDWARE_MODULE_ID, name: CAMERA_MODULE_NAME, author: "RockChip", methods: &amp;camera_module_methods, dso: NULL, /* remove compilation warnings */ reserved: &#123;0&#125;, /* remove compilation warnings */ &#125;, get_number_of_cameras: camera_get_number_of_cameras, get_camera_info: camera_get_camera_info,&#125;; 我们看到open方法调用的是camera_device_open，我们看看这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113int camera_device_open(const hw_module_t* module, const char* name, hw_device_t** device)&#123; int rv = 0; int cameraid; rk_camera_device_t* camera_device = NULL; camera_device_ops_t* camera_ops = NULL; android::CameraHal* camera = NULL; android::Mutex::Autolock lock(gCameraHalDeviceLock); LOGI("camera_device open"); if (name != NULL) &#123; cameraid = atoi(name);//将name变为id if(cameraid &gt; gCamerasNumber) &#123;//摄像头的id不能大于摄像头的数目 id可能只是个索引 LOGE("camera service provided cameraid out of bounds, " "cameraid = %d, num supported = %d", cameraid, gCamerasNumber); rv = -EINVAL; goto fail; &#125; if(gCamerasOpen &gt;= CAMERAS_SUPPORTED_SIMUL_MAX) &#123; LOGE("maximum number(%d) of cameras already open",gCamerasOpen); rv = -ENOMEM; goto fail; &#125; camera_device = (rk_camera_device_t*)malloc(sizeof(*camera_device));//分配一个rk_camera_device_t结构 if(!camera_device) &#123; LOGE("camera_device allocation fail"); rv = -ENOMEM; goto fail; &#125; camera_ops = (camera_device_ops_t*)malloc(sizeof(*camera_ops));//分配camera_device_ops_t 结构 if(!camera_ops) &#123; LOGE("camera_ops allocation fail"); rv = -ENOMEM; goto fail; &#125; memset(camera_device, 0, sizeof(*camera_device)); memset(camera_ops, 0, sizeof(*camera_ops)); camera_device-&gt;base.common.tag = HARDWARE_DEVICE_TAG; camera_device-&gt;base.common.version = 0; camera_device-&gt;base.common.module = (hw_module_t *)(module); camera_device-&gt;base.common.close = camera_device_close; camera_device-&gt;base.ops = camera_ops; camera_ops-&gt;set_preview_window = camera_set_preview_window; camera_ops-&gt;set_callbacks = camera_set_callbacks; camera_ops-&gt;enable_msg_type = camera_enable_msg_type; camera_ops-&gt;disable_msg_type = camera_disable_msg_type; camera_ops-&gt;msg_type_enabled = camera_msg_type_enabled; camera_ops-&gt;start_preview = camera_start_preview; camera_ops-&gt;stop_preview = camera_stop_preview; camera_ops-&gt;preview_enabled = camera_preview_enabled; camera_ops-&gt;store_meta_data_in_buffers = camera_store_meta_data_in_buffers; camera_ops-&gt;start_recording = camera_start_recording; camera_ops-&gt;stop_recording = camera_stop_recording; camera_ops-&gt;recording_enabled = camera_recording_enabled; camera_ops-&gt;release_recording_frame = camera_release_recording_frame; camera_ops-&gt;auto_focus = camera_auto_focus; camera_ops-&gt;cancel_auto_focus = camera_cancel_auto_focus; camera_ops-&gt;take_picture = camera_take_picture; camera_ops-&gt;cancel_picture = camera_cancel_picture; camera_ops-&gt;set_parameters = camera_set_parameters; camera_ops-&gt;get_parameters = camera_get_parameters; camera_ops-&gt;put_parameters = camera_put_parameters; camera_ops-&gt;send_command = camera_send_command; camera_ops-&gt;release = camera_release; camera_ops-&gt;dump = camera_dump; *device = &amp;camera_device-&gt;base.common; // -------- RockChip specific stuff -------- camera_device-&gt;cameraid = cameraid; camera = new android::CameraHal(cameraid); if(!camera) &#123; LOGE("Couldn't create instance of CameraHal class"); rv = -ENOMEM; goto fail; &#125; gCameraHals[cameraid] = camera; gCamerasOpen++; &#125; return rv;fail: if(camera_device) &#123; free(camera_device); camera_device = NULL; &#125; if(camera_ops) &#123; free(camera_ops); camera_ops = NULL; &#125; if(camera) &#123; delete camera; camera = NULL; &#125; *device = NULL; return rv;&#125; 这个方法主要做下面几件事： 创建一个rk_camera_device_t 用来描述Camera设备，它的定义是只是比camera_device_t多了一个cameraid，是对camera_device_t的拓展。 1234typedef struct rk_camera_device &#123; camera_device_t base; //定义在camera.h中 int cameraid;&#125; rk_camera_device_t; 创建camera_device_ops_t 用来描述Camera驱动提供的服务方法，在这里对其进行初始化，即指定了HAL层提供服务的具体方法。我们知道camera_device_ops_t是保存在camera_device_t结构中的。 创建android::CameraHal对象，这个对象通过和摄像头驱动的交互来提供具体的服务，比如预览，拍照。 预览数据的传递 下面为了进一步熟悉这个流程，我们看看摄像头的预览数据是如何在整个系统中进行传递的。 java层调用setPreviewCallback设置预览回调PreviewCallback，将其保存在mPreviewCallback中，接着调用jni层的 setHasPreviewCallback，即android_hardware_Camera_setHasPreviewCallback 123456789101112131415//设置预览回调static void android_hardware_Camera_setHasPreviewCallback(JNIEnv *env, jobject thiz, jboolean installed, jboolean manualBuffer)&#123; ALOGV("setHasPreviewCallback: installed:%d, manualBuffer:%d", (int)installed, (int)manualBuffer); // Important: Only install preview_callback if the Java code has called // setPreviewCallback() with a non-null value, otherwise we'd pay to memcpy // each preview frame for nothing. JNICameraContext* context; sp&lt;Camera&gt; camera = get_native_camera(env, thiz, &amp;context); if (camera == 0) return; // setCallbackMode will take care of setting the context flags and calling // camera-&gt;setPreviewCallbackFlags within a mutex for us. context-&gt;setCallbackMode(env, installed, manualBuffer);&#125; 可以看到这个方法并没有做什么处理，只是通过JNICameraContext 的setCallbackMode给Camera设置了一个回调标记mCamera-&gt;setPreviewCallbackFlags(CAMERA_FRAME_CALLBACK_FLAG_BARCODE_SCANNER);那么我们无法继续自顶向下进行分析，只能从底层进行分析。我们直接看底层CameraHal层预览相关的，在CameraHal::displayThread的实现中，当取到消息CMD_DISPLAY_FRAME会进行数据帧的绘制显示，这里面会调用 由CameraHal::setCallbacks设置的回调mDataCb，它是这样调用的 mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, queue_display_index,NULL,mCallbackCookie);//预览回调 回调给上层 显示了一帧数据这里的mCallbackCookie为上层CameraHardwareInterface对象，这里的消息类型为CAMERA_MSG_PREVIEW_FRAME。 还记得这个回调是在哪里进行设置的？ 没错，是在CameraHardwareInterface中，即它的__data_cb方法我们看看这个方法 12345678910111213141516static void __data_cb(int32_t msg_type, const camera_memory_t *data, unsigned int index, camera_frame_metadata_t *metadata, void *user)&#123; ALOGV("%s", __FUNCTION__); CameraHardwareInterface *__this = static_cast&lt;CameraHardwareInterface *&gt;(user); //user就是CameraHardwareInterface，它是在setCallBacks时传过去的 sp&lt;CameraHeapMemory&gt; mem(static_cast&lt;CameraHeapMemory *&gt;(data-&gt;handle));//取到CameraHeapMemory，它内部有一组缓冲区 if (index &gt;= mem-&gt;mNumBufs) &#123; ALOGE("%s: invalid buffer index %d, max allowed is %d", __FUNCTION__, index, mem-&gt;mNumBufs); return; &#125; __this-&gt;mDataCb(msg_type, mem-&gt;mBuffers[index], metadata, __this-&gt;mCbUser);//index指定了当前显示的buffer的索引&#125; 这个方法最后通过mDataCb调用给CameraClient::dataCallback 12345678910111213141516171819202122232425262728293031323334353637void CameraClient::dataCallback(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata, void* user) &#123; LOG2("dataCallback(%d)", msgType);//数据回调 Mutex* lock = getClientLockFromCookie(user); if (lock == NULL) return; Mutex::Autolock alock(*lock); CameraClient* client = static_cast&lt;CameraClient*&gt;(getClientFromCookie(user));//这个user是CameraClient对象 是在setCallBacks时设置的 if (client == NULL) return; if (!client-&gt;lockIfMessageWanted(msgType)) return; if (dataPtr == 0 &amp;&amp; metadata == NULL) &#123; ALOGE("Null data returned in data callback"); client-&gt;handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0); return; &#125; switch (msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA) &#123; case CAMERA_MSG_PREVIEW_FRAME: client-&gt;handlePreviewData(msgType, dataPtr, metadata);//回调预览数据 break; case CAMERA_MSG_POSTVIEW_FRAME: client-&gt;handlePostview(dataPtr); break; case CAMERA_MSG_RAW_IMAGE: client-&gt;handleRawPicture(dataPtr); break; case CAMERA_MSG_COMPRESSED_IMAGE: client-&gt;handleCompressedPicture(dataPtr); break; default: client-&gt;handleGenericData(msgType, dataPtr, metadata); break; &#125;&#125; 当消息类型为CAMERA_MSG_PREVIEW_FRAME时调用clinet的handlePreviewData方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// preview callback - frame buffer updatevoid CameraClient::handlePreviewData(int32_t msgType, const sp&lt;IMemory&gt;&amp; mem, camera_frame_metadata_t *metadata) &#123;//处理预览数据 ssize_t offset; size_t size; sp&lt;IMemoryHeap&gt; heap = mem-&gt;getMemory(&amp;offset, &amp;size); // local copy of the callback flags int flags = mPreviewCallbackFlag;//预览的回调的flag 之前设置的为CAMERA_FRAME_CALLBACK_FLAG_BARCODE_SCANNER // is callback enabled? if (!(flags &amp; CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK)) &#123; // If the enable bit is off, the copy-out and one-shot bits are ignored LOG2("frame callback is disabled"); mLock.unlock(); return; &#125; // hold a strong pointer to the client sp&lt;ICameraClient&gt; c = mRemoteCallback;//也就是BpCameraClient // clear callback flags if no client or one-shot mode if (c == 0 || (mPreviewCallbackFlag &amp; CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK)) &#123; LOG2("Disable preview callback"); mPreviewCallbackFlag &amp;= ~(CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK | CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK | CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK); disableMsgType(CAMERA_MSG_PREVIEW_FRAME); &#125; if (c != 0) &#123; // Is the received frame copied out or not? if (flags &amp; CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK) &#123; LOG2("frame is copied"); copyFrameAndPostCopiedFrame(msgType, c, heap, offset, size, metadata); &#125; else &#123; LOG2("frame is forwarded"); mLock.unlock(); c-&gt;dataCallback(msgType, mem, metadata); &#125; &#125; else &#123; mLock.unlock(); &#125;&#125; 这里的mRemoteCallback是什么呢？是在哪里进行初始化的呢？它是在CameraService::connect时 创建CameraClient对象时传递过来的，CameraClient在继承自CameraService::Client，创建该对象会同时构造CameraService::Client， 123456789101112131415161718192021222324252627282930313233CameraClient::CameraClient(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;ICameraClient&gt;&amp; cameraClient, const String16&amp; clientPackageName, int cameraId, int cameraFacing, int clientPid, int clientUid, int servicePid): Client(cameraService, cameraClient, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid)&#123; ..... &#125;CameraService::Client::Client(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;ICameraClient&gt;&amp; cameraClient, const String16&amp; clientPackageName, int cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid) : CameraService::BasicClient(cameraService, cameraClient-&gt;asBinder(), clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid)&#123; int callingPid = getCallingPid(); LOG1("Client::Client E (pid %d, id %d)", callingPid, cameraId); mRemoteCallback = cameraClient;//将客户端的BpCameraClinet 即Camera保存下来 cameraService-&gt;setCameraBusy(cameraId); cameraService-&gt;loadSound(); LOG1("Client::Client X (pid %d, id %d)", callingPid, cameraId);&#125; 这里的sp&amp; cameraClient 实际上就是我们本地Camera对象，它是作为我们的客户端的， 所以继承了BnCameraClient，后者又继承了ICameraClient，它也是一个binder对象。CameraService::Client对将连接的对象保存在其mRemoteCallback中作为回调。 知道了mRemoteCallback怎么来的，那么我们继续看handlePreviewData，在设置预览时我们设置了flag为 预览的回调的flag 之前设置的为CAMERA_FRAME_CALLBACK_FLAG_BARCODE_SCANNER，它默认是CAMERA_FRAME_CALLBACK_FLAG_NOOP即禁止回调的。所以最终是通过 c-&gt;dataCallback(msgType, mem, metadata)回调给Bp端的，即Camera::dataCallback 12345678910111213// callback from camera service when frame or image is readyvoid Camera::dataCallback(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata)&#123; sp&lt;CameraListener&gt; listener; &#123; Mutex::Autolock _l(mLock); listener = mListener; &#125; if (listener != NULL) &#123; listener-&gt;postData(msgType, dataPtr, metadata); &#125;&#125; 这里的mListener是谁？调用到哪里去了？它是一个CameraListener类型的接口，原来在JNI层建立摄像头连接的时候会调用camera-&gt;setListener(context);这个listener即JNICameraContext，它是继承自CameraListener的。这么说postData应该是JNI层的，我们看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void JNICameraContext::postData(int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr, camera_frame_metadata_t *metadata)//post 预览数据&#123; // VM pointer will be NULL if object is released Mutex::Autolock _l(mLock); JNIEnv *env = AndroidRuntime::getJNIEnv(); if (mCameraJObjectWeak == NULL) &#123; ALOGW("callback on dead camera object"); return; &#125; int32_t dataMsgType = msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA; // return data based on callback type switch (dataMsgType) &#123; case CAMERA_MSG_VIDEO_FRAME: // should never happen break; // For backward-compatibility purpose, if there is no callback // buffer for raw image, the callback returns null. case CAMERA_MSG_RAW_IMAGE: ALOGV("rawCallback"); if (mRawImageCallbackBuffers.isEmpty()) &#123; env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event, mCameraJObjectWeak, dataMsgType, 0, 0, NULL); &#125; else &#123; copyAndPost(env, dataPtr, dataMsgType); &#125; break; // There is no data. case 0: break; default: ALOGV("dataCallback(%d, %p)", dataMsgType, dataPtr.get()); copyAndPost(env, dataPtr, dataMsgType); break; &#125; // post frame metadata to Java if (metadata &amp;&amp; (msgType &amp; CAMERA_MSG_PREVIEW_METADATA)) &#123; postMetadata(env, CAMERA_MSG_PREVIEW_METADATA, metadata); &#125;&#125; msgType 是CAMERA_MSG_PREVIEW_FRAME，所以最终调用copyAndPost(env, dataPtr, dataMsgType); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void JNICameraContext::copyAndPost(JNIEnv* env, const sp&lt;IMemory&gt;&amp; dataPtr, int msgType)&#123; jbyteArray obj = NULL; // allocate Java byte array and copy data if (dataPtr != NULL) &#123; ssize_t offset; size_t size; sp&lt;IMemoryHeap&gt; heap = dataPtr-&gt;getMemory(&amp;offset, &amp;size); ALOGV("copyAndPost: off=%ld, size=%d", offset, size); uint8_t *heapBase = (uint8_t*)heap-&gt;base(); if (heapBase != NULL) &#123; const jbyte* data = reinterpret_cast&lt;const jbyte*&gt;(heapBase + offset);//从heap从取数据 if (msgType == CAMERA_MSG_RAW_IMAGE) &#123; obj = getCallbackBuffer(env, &amp;mRawImageCallbackBuffers, size); &#125; else if (msgType == CAMERA_MSG_PREVIEW_FRAME &amp;&amp; mManualBufferMode) &#123;//走了这里 obj = getCallbackBuffer(env, &amp;mCallbackBuffers, size); if (mCallbackBuffers.isEmpty()) &#123; ALOGV("Out of buffers, clearing callback!"); mCamera-&gt;setPreviewCallbackFlags(CAMERA_FRAME_CALLBACK_FLAG_NOOP); mManualCameraCallbackSet = false; if (obj == NULL) &#123; return; &#125; &#125; &#125; else &#123; ALOGV("Allocating callback buffer"); obj = env-&gt;NewByteArray(size); &#125; if (obj == NULL) &#123; ALOGE("Couldn't allocate byte array for JPEG data"); env-&gt;ExceptionClear(); &#125; else &#123; env-&gt;SetByteArrayRegion(obj, 0, size, data);//设置预览数据 &#125; &#125; else &#123; ALOGE("image heap is NULL"); &#125; &#125; // post image data to Java env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event, mCameraJObjectWeak, msgType, 0, 0, obj);//post 图像数据给java层 if (obj) &#123; env-&gt;DeleteLocalRef(obj); &#125;&#125; 最终是调用CallStaticVoidMethod将数据送到java层的 fields.post_event注册为 12345678910111213141516171819fields.post_event = env-&gt;GetStaticMethodID(clazz, "postEventFromNative", "(Ljava/lang/Object;IIILjava/lang/Object;)V");``` 那么应该是调用了java层的postEventFromNative的方法，这里obj保存了图像数据。```c++private static void postEventFromNative(Object camera_ref, int what, int arg1, int arg2, Object obj)&#123; Camera c = (Camera)((WeakReference)camera_ref).get(); if (c == null) return; if (c.mEventHandler != null) &#123; Message m = c.mEventHandler.obtainMessage(what, arg1, arg2, obj);//通过mEventHandler发送消息 c.mEventHandler.sendMessage(m); &#125;&#125; 最终是通过EventHandler来进行的，这里的mEventHandler是在构造Java层的Camera时创建的，我们直接看其对消息的处理 private class EventHandler extends Handler { private Camera mCamera; public EventHandler(Camera c, Looper looper) { super(looper); mCamera = c; } @Override public void handleMessage(Message msg) { switch(msg.what) { .... case CAMERA_MSG_PREVIEW_FRAME: PreviewCallback pCb = mPreviewCallback; if (pCb != null) { if (mOneShot) { // Clear the callback variable before the callback // in case the app calls setPreviewCallback from // the callback function mPreviewCallback = null; } else if (!mWithBuffer) { // We're faking the camera preview mode to prevent // the app from being flooded with preview frames. // Set to oneshot mode again. setHasPreviewCallback(true, false); } pCb.onPreviewFrame((byte[])msg.obj, mCamera);//会通过这里回调给上层应用 } return; case CAMERA_MSG_POSTVIEW_FRAME: if (mPostviewCallback != null) { mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; ...... } } } 看到对CAMERA_MSG_PREVIEW_FRAME消息的处理，这个mPreviewCallback是我们设置的预览回调，最终调用onPreviewFrame回调给应用。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SparseArray源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-libray-sparsearray-src%2F</url>
    <content type="text"><![CDATA[SparseArray，SparseIntArray,SparseBooleanArray等是Android官方提倡使用的高效数据结构。它同java中的HashMap类似属于存储键值对的集合，准确的来说是HashMap&lt;Integer,V&gt;。但同HashMap相比它更加轻量，执行效率更高。下面我们就对SparseArray的源码进行解读，了解它内部的执行原理。 构造方法 源码位置： frameworks/base/core/java/android/util/SparseArray.java 首先我们从其构造函数入手 1234567891011121314151617181920212223242526public class SparseArray&lt;E&gt; implements Cloneable &#123; private static final Object DELETED = new Object(); private boolean mGarbage = false; private int[] mKeys; private Object[] mValues; private int mSize; public SparseArray() &#123; this(10); &#125; public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = ContainerHelpers.EMPTY_INTS; mValues = ContainerHelpers.EMPTY_OBJECTS; &#125; else &#123; initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity); mKeys = new int[initialCapacity]; mValues = new Object[initialCapacity]; &#125; mSize = 0; &#125; ……&#125; 初始化时传递的initialCapacity大小为10，但这个只是一个参考值，随后又通过ArrayUtils.idealIntArraySize对初始值进行了调整，从函数名字上看这个方法会根据参考值返回一个比较理想容量大小。我们看看它是如何计算的 1234567891011public static int idealIntArraySize(int need) &#123; return idealByteArraySize(need * 4) / 4;&#125;public static int idealByteArraySize(int need) &#123; for (int i = 4; i &lt; 32; i++) if (need &lt;= (1 &lt;&lt; i) - 12) return (1 &lt;&lt; i) - 12; return need;&#125; 计算的结果是一个2的幂次方的数减去12，对于SparseArray还需要再除以4作为结果返回，这里返回的值为(1&lt;&lt;6-12)/4 = 13 。 这里有个疑惑就是为什么需要对初始值进行重新计算得到SparseArray的容量大小？ 获取元素 可以看出SparseArray内部是通过数组来实现的，相比hashMap的hash表和链表要轻量一些。我们先看看它的get方法如何实现 12345678910111213public E get(int key) &#123; return get(key, null);&#125;public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125;&#125; 内部逻辑非常简单，通过key来进行二分查找，这么说键值在mKeys中的存储是有序的。这就要求在添加元素中做保证。这里二分搜索的结果是key值所在的索引值i，这个索引在mValues中对应的数据就是key对应的值，可见mKeys和mValues是一一对应的，只是分别存储在两个数组中罢了。这里如果查找到会返回索引值i，如果i小于0说明没有找到，同时如果i所在的value已经失效即为DELETE，则也算没有找到value值，返回默认的valueIfKeyNotFound，否则返回mValues[i]作为结果。 frameworks/base/core/java/android/util/ContainerHelpers.java 123456789101112131415161718static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; final int mid = (lo + hi) &gt;&gt;&gt; 1; final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present&#125; 二分搜索，这里就不需要做解释了，需要注意的是如果找到了key值，则返回其在array中的索引mid，否则返回~lo，lo代表了所查找key值所应该存在的位置，这里取反是为了说明key值不存在该位置，但如果需要添加key值对应的value就可以将其放在lo处。 添加元素 我们知道二分搜索是基于有序序列进行的操作，那么在我们添加元素也就是put时需要保证数组的有序性，我们接下来看看put的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; if (mSize &gt;= mKeys.length) &#123; int n = ArrayUtils.idealIntArraySize(mSize + 1); int[] nkeys = new int[n]; Object[] nvalues = new Object[n]; // Log.e("SparseArray", "grow " + mKeys.length + " to " + n); System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length); System.arraycopy(mValues, 0, nvalues, 0, mValues.length); mKeys = nkeys; mValues = nvalues; &#125; if (mSize - i != 0) &#123; // Log.e("SparseArray", "move " + (mSize - i)); System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i); System.arraycopy(mValues, i, mValues, i + 1, mSize - i); &#125; mKeys[i] = key; mValues[i] = value; mSize++; &#125;&#125; put同样一开始先binarySearch查找key值是否已经存在，如果存在，只需更新索引i处的value。 否则我们对i进行取反，这里取反后的i值我们知道就是key值应该存放的位置。 随后判断i是否小于mSize 且 mValues对应i处的值已经失效，如果失效了就直接替换该处的值即可。否则看是否需要进行gc(看mGarbage是否置为true且当前的数组已经满了)，这里的gc是指对失效元素进行回收，并重新计算大小。gc完后会再次计算key值索引，因为数组大小可能发生了变化。 如果gc后数组依旧时满的，这就需要我们再开辟空间了，同样调用ArrayUtils.idealIntArraySize重新计算容量，然后创建数组，并将mKeys和mValues拷贝到新的数组中。 如果mSize-i！=0 说明要在数组间插入key值，这个需要将索引i后的元素统一向后挪动一个位置为key值腾出一个位置。 将key值对应的value分别放在mKeys和mValues中并递增mSize。 gc的回收策略 1234567891011121314151617181920212223private void gc() &#123; int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o;&#125; gc负责将已经清理失效的value(即等于DELETED)，并重新计算mSize。 在SparseArray的众多方法中都有可能调用gc方法比如size,keyAt,valueAt等等，以此来分摊可能进行的gc的执行时间。 在SparseArray中还有一个比put更加高效的方法append,它首先判断key值是否比数组末尾的key值还要大，如果是的话就只需将其添加到末尾就行了，因为它保证了有序性。否则就调用put来添加该key-value。 1234567891011121314151617181920212223242526272829public void append(int key, E value) &#123; if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) &#123; put(key, value); return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); &#125; int pos = mSize; if (pos &gt;= mKeys.length) &#123; int n = ArrayUtils.idealIntArraySize(pos + 1); int[] nkeys = new int[n]; Object[] nvalues = new Object[n]; // Log.e("SparseArray", "grow " + mKeys.length + " to " + n); System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length); System.arraycopy(mValues, 0, nvalues, 0, mValues.length); mKeys = nkeys; mValues = nvalues; &#125; mKeys[pos] = key; mValues[pos] = value; mSize = pos + 1;&#125; SparseArray的delete方法同样是它高效的体现，它并不真正的将key-value从数组中移除，而仅仅是将value标记为失效，同时把mGarbage置为true代表需要进行gc,这样做原因是，随后可能存在key值又加入进来的情况，这样我们就仅需将已经失效的元素换成我们添加的value值即可，可以参见Put方法的第二步说明。这样避免了数组的频繁抖动引起的性能问题。 123456789public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service的启动过程(二)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-service-bind-src%2F</url>
    <content type="text"><![CDATA[继上一篇Service的启动过程(一)，本篇将继续对service的另一种启动方式，即绑定service进行分析。 同样的，我们从ContextImpl的bindService开启这个流程的分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Service的绑定状态，绑定状态下的Service用于和组件进行交互@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException("connection is null"); &#125; //通过ServiceConnection获取到一个InnterConnection，它实际上是个Binder， //后面AMS通过这个binder和服务端进行connection的通信 if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags);//通过ServiceConnection构造一个ServiceDispatcher &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125; //检验intent，从4.4开始 service的隐式调用将不安全，5.1以后不支持隐式调用 validateServiceIntent(service); try &#123; IBinder token = getActivityToken();//取到activity的token,实际上是ActivityRecord的appToken if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(); //Binder IPC调用，通过AMS来进一步绑定Service 这里调用的是bindService，注意要和startService做区分 int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( "Not allowed to bind to service " + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; return false; &#125;&#125; service的bind过程相比启动过程稍微复杂一点，因为bind需要将service绑定到组件上，这个需要通过一个回调来通知客户组件，bindServiceCommon中，首先会获取到一个IServiceConnection，实际上是个InnerConnection，它是个Binder,AMS端通过它来通知客户组件是否建立到Service的连接，随后通过Binder IPC调用bindService进一步的绑定操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//service的绑定过程，这里的caller是个binder，它代表了应用端public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) &#123; …… synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, userId); &#125;&#125;//bind过程的进一步处理int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) &#123; //获取调用者的进程信息 final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123;//未找到的话抛出安全异常 throw new SecurityException( "Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when binding service " + service); &#125; ActivityRecord activity = null; if (token != null) &#123; //token不为null时需要找到token对应的ActivityRecord activity = ActivityRecord.isInStackLocked(token); if (activity == null) &#123; Slog.w(TAG, "Binding with unknown activity: " + token); return 0; &#125; &#125; int clientLabel = 0; PendingIntent clientIntent = null; …… final boolean callerFg = callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE; //获取启动的service信息，同启动方式的一样 //其内部会为service创建ServiceRecord ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg); if (res == null) &#123; return 0; &#125; if (res.record == null) &#123; return -1; &#125; ServiceRecord s = res.record;//取到service对应的ServiceRecord,它实际上是个binder final long origId = Binder.clearCallingIdentity(); try &#123; …… AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); //代表一个客户组建的绑定连接 ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent); IBinder binder = connection.asBinder();//这个是应用端传来的IServiceConnection binder //这个connection可以对应多个ConnectionRecord，可见它是可以被多个组件绑定复用的binder ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); s.connections.put(binder, clist); &#125; clist.add(c);//添加到ServiceRecord对应的connections列表中 b.connections.add(c);//添加到AppBindRecord的连接列表中 if (activity != null) &#123; if (activity.connections == null) &#123; activity.connections = new HashSet&lt;ConnectionRecord&gt;(); &#125; activity.connections.add(c);//如果客户组件是Activity 添加到其对应的连接列表中 &#125; b.client.connections.add(c);//添加到客户端进程的连接列表中 if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true; &#125; if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c); &#125; clist = mServiceConnections.get(binder);//AMS的服务记录列表，这个同ServiceRecord的 if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); mServiceConnections.put(binder, clist); &#125; clist.add(c);//添加到AMS对应的连接列表中 //设定的标记是BIND_AUTO_CREATE if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); //这里会启动service的实例 调用onCreate回调 if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123; return 0; &#125; &#125; //如果service对应进程不为null，更新其对应的oom_adj和LRU if (s.app != null) &#123; // This could have made the service more important. mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities, b.client); mAm.updateOomAdjLocked(s.app); &#125; //如果service已经运行了，当再有组件进行绑定时就可以立马发布连接状态 //b.intent.received 为true表示service binder实体在AMS端已经被初始化过了 if (s.app != null &amp;&amp; b.intent.received) &#123; // Service is already running, so we can immediately // publish the connection. try &#123; c.conn.connected(s.name, b.intent.binder); &#125; catch (Exception e) &#123;&#125; if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; requestServiceBindingLocked(s, b.intent, callerFg, true); &#125; &#125; else if (!b.intent.requested) &#123;//表示还未请求绑定过 //否则需要进一步启动service 执行bind的过程 requestServiceBindingLocked(s, b.intent, callerFg, false); &#125; getServiceMap(s.userId).ensureNotStartingBackground(s); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return 1;&#125; AMS端的绑定过程做了以下几件事： 获取启动的service信息，同时会为要启动的service创建ServiceRecord(如果不存在的话) 为需要绑定的客户组件创建ConnectionRecord，它代表了一个客户连接。并将其存储在多个连接列表中方便存取。 通过bringUpServiceLocked启动service实例，这个方法我们之前介绍过. 通过requestServiceBindingLocked请求执行service的bind过程，这个最终会调用requestServiceBindingLocked通过ApplicationThread来通知应用端绑定service. 123456789101112131415161718192021222324//应用端service的绑定流程private void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token);//取到对应的service实例 if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); try &#123; if (!data.rebind) &#123; //service的绑定回调 onBind返回的实际上是一个Binder server IBinder binder = s.onBind(data.intent); //创建好binder server后然后进行publish 将service发布出去 ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, 0, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; &#125; &#125; catch (Exception e) &#123;&#125; &#125;&#125; 从客户端绑定service的流程来看，它除了会回调service onBind来返回一个IBinder实体，这个IBinder实体它实际上是我们的服务实体，这里它将通过AMS的publishService来发布该服务，按理来说这是service的binder实体第一次穿过Binder驱动，驱动此时会记录下该Binder节点，同时service并不会被SM所知，因此我们的service实际上是作为一个匿名binder存在的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//在service执行完onBind的流程后 会返回一个Binder server，这里对其进行发布public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException("Invalid service token"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125;//进一步发布service，这里的service时作为Binder本地代理端的void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (r != null) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord b = r.bindings.get(filter); if (b != null &amp;&amp; !b.received) &#123; b.binder = service; b.requested = true; b.received = true; //发布实际上就是将service通过之前注册的connection回调发送给相应的组件 for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni); for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); try &#123; //需要注意，这里的service实际上为binder client端，如果service运行于单独的进程中 //那么这个service返回给应用进程组件后，实际上它在java端是一个BinderProxy,在native端它是一个BpBinder c.conn.connected(r.name, service); &#125; catch (Exception e) &#123;&#125; &#125; &#125; &#125; serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 通过publishServiceLocked发布的service client binder最终会通过客户组件注册的接口回调给客户端。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service的启动过程(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-service-start-src%2F</url>
    <content type="text"><![CDATA[Service介绍 Service是Android的四大组件之一，官方对它的描述是 A Service is an application component representing either an application’s desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use. 大概意思为，Service是一个应用程序组件，它是在一个应用程序不和用户进行交互时在后台执行的一个长时间运行的操作，或者为其他应用进程所使用的功能模块(这里应该是说Service可以被Activity或者其他应用进行bindService)。总之，我们对于Service的理解就是它是一个可以在后台运行不和用户进行交互的应用组件。 在刚开始接触Service，貌似觉得Service和Thread有些类似，后面随着深入了解后，才发现Service和Thread完全是两回事，那么它和Thread的区别在哪里？我觉得主要由以下几点： Service作为Android组件，有它自己的声明周期，而Thread是操作系统中的概念，它是CPU分配时间片的最小单元。 Service是可以被其他组件进行操作的，比如Activity，而Thread不可以。 Service是运行于主线程上的，作为remote Service后，它是运行在独立的进程中的main线程上的，而Thread的运行是独立的，在new Thread后就于它所在的线程无关了。 Service的启动方式 startService 通过startService启动的Service会一直在后台运行，直到手动stopService或者stopSelf，这种方式启动的Service不和Activity组件进行交互，它经历的生命周期为onCreate-&gt;onStartCommand-&gt;onDestroy bindService 通过bindService可以将Service和其他应用组件进行绑定，这时Service是以Server的形式为其提供服务的，绑定Service的组件可以调用Service提供的方法，这种方式同启动方式不同，绑定的service的生命周期通常只是在为组件提供服务时处于运行状态，并不时一直在后台运行，组件解除绑定后，service相应的就被销毁了。bindService的生命周期为 onCreate-&gt;onBind-&gt;onUnbind-&gt;onDestroy，需要注意的时多次bindService后只需要一次unbind即可. 远程服务 当在AndroidMainfest的Service标签中中指定了android:process时，代表Service将运行于独立的进程中。这时候如果通过bindService绑定服务可能就需要借助于AIDL了(Messenger也是可以的)。 否则组件和Sevice运行在相同的进程中，这时候只需要在服务端拓展Binder类后返回即可。 Service绑定和启动的转换 Service的绑定和启动是可以同时进行的，即可以同时通过startService和bindService对其进行调用，这时候按照先后顺序有不同的结果。 先绑定后再启动 这种方式启动后service,Service转为启动方式，也就是服务运行不受绑定组件的限制，会一直在后台运行，直到stopService或者stopSelf。 先启动后在绑定 这种情况下，Service先是以启动方式运行在后台，当组件对Service进行绑定后，仍然可以对Service继续请求操作，只是解除绑定后,Service依然会在后台继续运行，不受解绑的影响。 startService的源码分析 接下来，我们将通过阅读Service的源码来进一步了解Android中的Service是如果启动的。startService是从ContextImpl开始的，它是Context上下文的实现类，我们的Activity继承自ContextThemeWrapper，后者又继承自ContextWrapper,在ContextWrapper中有个Context的mBase成员，它实际上就是ContextImpl，因为Context只是一个抽象类。 12345678910111213141516171819202122232425262728//Service的启动状态流程 @Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, mUser);&#125;private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; try &#123; validateServiceIntent(service);//校验service的Intent service.prepareToLeaveProcess(); //通过AMS的binder代理进行IPC调用 /**这里对参数进行说明： * mMainThread.getApplicationThread()： 是个ApplicationThread对象，它是个Binder server * 这里将它传递给AMS，AMS使用它和应用程序进行交互。 * service：要启动的service的intent * service.resolveTypeIfNeeded(getContentResolver())：MIME类型，未指定为null * user.getIdentifier：启动进程的用户id * */ ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier()); …… return cn; &#125; catch (RemoteException e) &#123; return null; &#125;&#125; startService开始调用startServiceCommon，在startServiceCommon中一开始先进行Intent的校验，在Android 4.4中对service的隐式启动做了安全警告，而在Android 5.1禁止通过隐式方式来启动service，接下来就是通过IPC Binder调用AMS的startService调用过程，这里需要注意传递的参数。 1234567891011121314151617//AMS端启动servicepublic ComponentName startService(IApplicationThread caller, Intent service,String resolvedType, int userId) &#123; enforceNotIsolatedCaller("startService"); …… synchronized(this) &#123; final int callingPid = Binder.getCallingPid();//调用者进程的pid final int callingUid = Binder.getCallingUid();//调用者进程的uid //这里清理调用者进程的uid和pid并将其保存在origId中，设置为当前进程的uid和pid，这是为了方便 //Binder server在当前进程中调用该进程的其他组件 final long origId = Binder.clearCallingIdentity(); //进一步调用startServiceLocked，这里的mServices为ActivityService,AMS使用它来管理应用端的service ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId);//还原调用者的pid和uid return res; &#125;&#125; 在AMS的startService中进一步调用startServiceLocked并传递给其调用者pid和uid信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//service的启动核心过程ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, int userId) &#123; final boolean callerFg;//代表是否是前台启动的 if (caller != null) &#123; //这里先通过caller获取到调用者的进程信息，放在ProcessRecord中 final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( "Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when starting service " + service); &#125; callerFg = callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE; &#125; else &#123; callerFg = true; &#125; //通过service intent获取到AndroidManifest中关于service定义的详细信息 ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPid, callingUid, userId, true, callerFg); if (res == null) &#123; return null; &#125; if (res.record == null) &#123; return new ComponentName("!", res.permission != null ? res.permission : "private to package"); &#125; //从获取的ServiceLookupResult中取到ServiceRecord ServiceRecord r = res.record; //检查权限 NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked( callingUid, r.packageName, service, service.getFlags(), null); if (unscheduleServiceRestartLocked(r, callingUid, false)) &#123; if (DEBUG_SERVICE) Slog.v(TAG, "START SERVICE WHILE RESTART PENDING: " + r); &#125; r.lastActivity = SystemClock.uptimeMillis(); r.startRequested = true; r.delayedStop = false; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), service, neededGrants)); final ServiceMap smap = getServiceMap(r.userId); boolean addToStarting = false; if (!callerFg &amp;&amp; r.app == null &amp;&amp; mAm.mStartedUsers.get(r.userId) != null) &#123; ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false); if (proc == null || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123; if (r.delayed) &#123; return r.name; &#125; if (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123; smap.mDelayedStartList.add(r); r.delayed = true; return r.name; &#125; addToStarting = true; &#125; else if (proc.curProcState &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123; addToStarting = true; &#125; &#125; …… //进一步启动service return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125; 首先通过调用者的信息获取到进程信息callerApp，随后通过retrieveServiceLocked获取到解析的Service在AndroidManifest的信息。在这个方法里会为Service创建ServiceRecord它在AMS端代表了当前启动的service，随后初始化了一些信息，比如将startRequested置为true表示请求进行启动service，第一次启动service时r.app是未绑定到ProcessRecord上的，通过getProcessRecordLocked获取service的进行信息，如果未指定android:process时，那么默认是在当前应用进程中启动。随后调用startServiceInnerLocked进一步启动service。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; ProcessStats.ServiceState stracker = r.getTracker(); …… //进一步启动service，这里会做一些实质性的工作 String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); …… return r.name;&#125;//在这里面会做一些service启动的实质性工作private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) &#123; //r.app和 r.app.thread不为null，说明service已经启动了， //这时候通过sendServiceArgsLocked进一步通知应用端 if (r.app != null &amp;&amp; r.app.thread != null) &#123; sendServiceArgsLocked(r, execInFg, false); return null; &#125; …… if (mRestartingServices.remove(r)) &#123;//正在启动service，就将其从重启列表中移除 clearRestartingIfNeededLocked(r); &#125; …… //如果设置了isolatedProcess，服务会在一个特殊的隔离进程下运行，这个进程与系统其他进程分开且没有自己的权限。 final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; final String procName = r.processName;//进程名，如果有的话 ProcessRecord app; if (!isolated) &#123; //获取service所在进程 app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null &amp;&amp; app.thread != null) &#123;//如果它和应用进程同属一个进程 try &#123; app.addPackage(r.appInfo.packageName, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg);//直接启动该service return null; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting service " + r.shortName, e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; &#125; else &#123; // If this service runs in an isolated process, then each time // we call startProcessLocked() we will get a new isolated // process, starting another process if we are currently waiting // for a previous process to come up. To deal with this, we store // in the service any current isolated process it is running in or // waiting to have come up. app = r.isolatedProc; &#125; // Not running -- get it started, and enqueue this service record // to be executed when the app comes up. if (app == null) &#123;//如果未找到service相应的进程，则需要为它启动一个单独的进程，进程名字为procName //这里为service启动进程和为activity启动进程是类似的，都是通过zygote forK出来的。 if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, "service", r.name, false, isolated, false)) == null) &#123; bringDownServiceLocked(r); return msg; &#125; if (isolated) &#123; r.isolatedProc = app; &#125; &#125; //注意启动进程的操作是异步的，通知zygote创建进程后将ServiceRecord放到service的等待列表中， //等进程启动完成后会从该列表取出service运行。 if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125; …… return null;&#125; 在startServiceInnerLocked中会调用bringUpServiceLocked进行一些启动的实质性工作，首先会检查ServiceRecord的app和app.thread，如果它们都不为null，说明service已经启动了，这时候走sendServiceArgsLocked的流程，后面我们看到它是如果工作的。 如果service设置了isolatedProcess，那么它会在一个单独的隔离进程中启动，否则通过AMS找到service的进程，如果它和应用进程是同一个进程，那么就直接调用realStartServiceLocked进行service的启动，否则service指定了启动的进程，这时候需要调用startProcessLocked通知zygote为其创建进程，并将其serviceRecord添加到mPendingServices，当进程创建完成后再从其中取出service进行启动流程，这个过程是异步进行的。 下面我们就分别看看这几种情况下的service是如何启动的： Service未启动的情况，这时候调用startProcessLocked进行启动 123456789101112131415161718192021222324252627//为应用或者服务创建进程final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; ProcessRecord app; …… //开启新的进程 startProcessLocked(app, hostingType, hostingNameStr); return (app.pid != 0) ? app : null;&#125;//开启新进程 同zygote交互private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… try &#123; …… // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. //为service或者activity创建新的进程 通过zygote进程执行 创建完成后回调ActivityThread并执行其main方法 Process.ProcessStartResult startResult = Process.start("android.app.ActivityThread", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); &#125; catch (RuntimeException e) &#123;&#125;&#125; 对于service进程不存在情况，需要通过zygote未service创建进程，这个过程同应用程序启动是类似的，Zygote未service创建完进程后，会在主线程中执行ActivityThread的main方法。这个主线程实际上就是ui线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//为activity 和 service创建完进程后，会在主线程(ui线程)中执行ActivityThread的main方法public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Security.addProvider(new AndroidKeyStoreProvider()); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//准备Looper循环 ActivityThread thread = new ActivityThread(); thread.attach(false);//这里会通知AMS应用进程启动完毕 if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); Looper.loop();//开启Looper循环 throw new RuntimeException("Main thread loop unexpectedly exited");&#125;private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName("&lt;pre-initialized&gt;", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread);//实际上是通知AMS进程启动起来了 &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; …… &#125; 在main方法中会调用ActivityThread的attach方法，这里会通过binder调用AMS的attachApplication，实际上就是让AMS知道这个进程的存在。AMS中的attchApplication只是简单的调用attachApplicationLocked来进行进一步的启动。 12345678910111213141516171819202122232425262728293031323334353637 //在这里会启动等待新进程的activity或者serviceprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; …… //通知应用进程进行bind thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); …… if (normalMode) &#123; try &#123; //通知ActivityStackSupervisor 进程已经创建，这时候需要看由没有要启动的activity if (mStackSupervisor.attachApplicationLocked(app, mHeadless)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true;//出错 &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; //通知ActivityServices 进程已经创建 这时候看有没有要启动的service didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true;//出错 &#125; &#125; ……&#125; 进程启动后，在AMS一端会去判断是否有需要启动的Activity或者service，之前我们了解到在启动service之前，AMS已经做好了准备，这里就去真正的启动service了。 frameworks/base/services/java/com/android/server/am/ActiveServices.java 1234567891011121314151617181920212223242526272829303132//进程创建后会通过这个方法来通知AMSboolean attachApplicationLocked(ProcessRecord proc, String processName) throws Exception &#123; boolean didSomething = false; // Collect any services that are waiting for this process to come up. if (mPendingServices.size() &gt; 0) &#123;//看有没有等待启动的服务 ServiceRecord sr = null; try &#123; //遍历等待的服务 for (int i=0; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; //从等待队列中移除 mPendingServices.remove(i); i--; proc.addPackage(sr.appInfo.packageName, mAm.mProcessStats); //启动service realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, "Exception in new application when starting service " + sr.shortName, e); throw e; &#125; &#125; …… return didSomething;&#125; 在ActiveServices的attachApplicationLocked方法中会去从等待列表中取出要启动的service，然后通过realStartServiceLocked来进行真正的启动 1234567891011121314151617181920212223242526272829303132333435363738394041424344//这里是AMS中启动Service的最后一步，完成收尾工作private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; …… r.app = app; r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); app.services.add(r); bumpServiceExecutingLocked(r, execInFg, "create"); mAm.updateLruProcessLocked(app, false, null); mAm.updateOomAdjLocked();//更新oom_adj，这个代表了该进程的优先级 boolean created = false; try &#123; String nameTerm; int lastPeriod = r.shortName.lastIndexOf('.'); nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.ensurePackageDexOpt(r.serviceInfo.packageName); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //通知应用进程创建Service app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; finally &#123; if (!created) &#123; app.services.remove(r); r.app = null; scheduleServiceRestartLocked(r, false); &#125; &#125; requestServiceBindingsLocked(r, execInFg); …… //通知service进行onStartCommand sendServiceArgsLocked(r, execInFg, true); ……&#125; 在realStartService中会通过IApplicationThread通知应用端服务的启动，在scheduleCreateService的IPC调用中，最终会触发service的onCreate回调。而在sendServiceArgsLocked会触发onStartCommand的回调，至此，service在ASM一端的启动过程就完成了。 当service的进程已经存在，那么直接调用realStartServiceLocked进行启动即可。 当service已经启动，这时候需要调用sendServiceArgsLocked来进一步完成启动，这里主要是回调onStartCommand 123456789101112131415161718192021222324252627282930313233343536373839404142434445private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) &#123; final int N = r.pendingStarts.size(); if (N == 0) &#123; return; &#125; while (r.pendingStarts.size() &gt; 0) &#123; try &#123; ServiceRecord.StartItem si = r.pendingStarts.remove(0); if (si.intent == null &amp;&amp; N &gt; 1) &#123; // If somehow we got a dummy null intent in the middle, // then skip it. DO NOT skip a null intent when it is // the only one in the list -- this is to support the // onStartCommand(null) case. continue; &#125; si.deliveredTime = SystemClock.uptimeMillis(); r.deliveredStarts.add(si); si.deliveryCount++; if (si.neededGrants != null) &#123; mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants, si.getUriPermissionsLocked()); &#125; bumpServiceExecutingLocked(r, execInFg, "start"); if (!oomAdjusted) &#123; oomAdjusted = true; mAm.updateOomAdjLocked(r.app); &#125; int flags = 0; if (si.deliveryCount &gt; 1) &#123; flags |= Service.START_FLAG_RETRY; &#125; if (si.doneExecutingCount &gt; 0) &#123; flags |= Service.START_FLAG_REDELIVERY; &#125; //通知应用端服务启动参数 r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent); &#125; catch (RemoteException e) &#123; break; &#125; catch (Exception e) &#123; break; &#125; &#125;&#125; 实际上这里是通过IApplicationThread回调应用端的scheduleServiceArgs方法，这是一个Binder的IPC调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId, int flags ,Intent args) &#123; //Service启动参数 ServiceArgsData s = new ServiceArgsData(); s.token = token; s.taskRemoved = taskRemoved; s.startId = startId; s.flags = flags; s.args = args; sendMessage(H.SERVICE_ARGS, s);&#125;//通知service启动的请求参数，实际上是调用onStartCommand回调private void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token);//根据token取到service实例 if (s != null) &#123; try &#123; if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); &#125; int res; if (!data.taskRemoved) &#123; res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; QueuedWork.waitToFinish(); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, 1, data.startId, res); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; ensureJitEnabled(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( "Unable to start service " + s + " with " + data.args + ": " + e.toString(), e); &#125; &#125; &#125;&#125; 可以看到scheduleServiceArgs最终会调用handleServiceArgs来进行onStartCommand的回调。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ServiceManager源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-servicemanager-src%2F</url>
    <content type="text"><![CDATA[ServiceManager是Android系统的服务大管家，它负责所有实名Server的管理，比如CameraService,WindowManagerService等等，所以它的重要性可想而知，ServiceManager是单独运行在一个系统进程中的，它在Init.rc的定义如下: 12345678910service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm Class 为core 属于核心级的 它的主方法在service_manager.c中定义 我们看看它的实现： 1234567891011121314151617frameworks/native/cmds/servicemanager/service_manager.cint main(int argc, char **argv)&#123; struct binder_state *bs; void *svcmgr = BINDER_SERVICE_MANAGER; //打开binder 这里映射的内存大小为128k bs = binder_open(128*1024); //使sm成为所有服务的大管家 if (binder_become_context_manager(bs)) &#123; ALOGE("cannot become context manager (%s)\n", strerror(errno)); return -1; &#125; svcmgr_handle = svcmgr; binder_loop(bs, svcmgr_handler);//binder循环 return 0;&#125; 进入主方法后，主要做了三件事： &lt;1&gt;. 打开binder驱动设备，servicemanager的业务并不复杂，这里映射的大小为128k。 &lt;2&gt;. 调用binder_become_context_manager使sevicemanger成为所有实名服务的大管家 &lt;3&gt;. 调用binder_loop进入binder循环，等待client端的请求。svcmgr_handler为servicemanager服务处理handler，它是一个函数指针，主要是处理它自身的业务逻辑。比如我们的client端通过AddService或者getService的服务就是在这里进行处理的。 下面我们分析servicemanager的binder_loop 123456789101112131415161718192021222324252627282930frameworks/native/cmds/servicemanager/binder.cvoid binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; unsigned readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); //不断的读取binder的内容 for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);//读取binder内容 if (res &lt; 0) &#123; ALOGE("binder_loop: ioctl failed (%s)\n", strerror(errno)); break; &#125; res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);//解析数据 …… &#125;&#125; Binder_loop中首先通过binder_write向Binder驱动写入BC_ENTER_LOOPER，表示进入binder循环，然后通过BINDER_WRITE_READ读取binder内容，结果存放在一个binder_write_read结构中,然后开始通过binder_parse解析数据，这里将我们的服务处理函数传递给它，那么数据应该是在这里交给我们的handler进行处理。 123456789101112131415161718192021222324252627282930313233frameworks/native/cmds/servicemanager/binder.cint binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func)&#123; …… switch(cmd) &#123; …… case BR_TRANSACTION: &#123; struct binder_txn *txn = (void *) ptr; if ((end - ptr) * sizeof(uint32_t) &lt; sizeof(struct binder_txn)) &#123; ALOGE("parse: txn too small!\n"); return -1; &#125; binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); binder_send_reply(bs, &amp;reply, txn-&gt;data, res); &#125; ptr += sizeof(*txn) / sizeof(uint32_t); break; &#125; …… &#125; &#125; return r;&#125; 可以看到在BR_TRANSACTION中的确是通过fun，也就是svcmgr_handler进行处理的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//sm的服务handlerframeworks/native/cmds/servicemanager/service_manager.cint svcmgr_handler(struct binder_state *bs, struct binder_txn *txn, struct binder_io *msg, struct binder_io *reply)&#123; struct svcinfo *si; uint16_t *s; unsigned len; void *ptr; uint32_t strict_policy; int allow_isolated; if (txn-&gt;target != svcmgr_handle) return -1; strict_policy = bio_get_uint32(msg); s = bio_get_string16(msg, &amp;len); if ((len != (sizeof(svcmgr_id) / 2)) || memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123; fprintf(stderr,"invalid id %s\n", str8(s)); return -1; &#125; switch(txn-&gt;code) &#123; case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); ptr = do_find_service(bs, s, len, txn-&gt;sender_euid); if (!ptr) break; bio_put_ref(reply, ptr); return 0; case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); ptr = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated)) return -1; break; case SVC_MGR_LIST_SERVICES: &#123; unsigned n = bio_get_uint32(msg); si = svclist; while ((n-- &gt; 0) &amp;&amp; si) si = si-&gt;next; if (si) &#123; bio_put_string16(reply, si-&gt;name); return 0; &#125; return -1; &#125; default: ALOGE("unknown code %d\n", txn-&gt;code); return -1; &#125; bio_put_uint32(reply, 0); return 0;&#125; Servicemanager作为服务的大管家它的业务并不负责，相比其他service的服务可以说是异常简单，我们看看它最重要的服务即添加服务和获取服务。 Servicemanager维护了一个svclist链表，每个添加进来的服务都会通过一个svcinfo进行描述，并添加到链表中。它的结构如下 1234567891011struct svcinfo &#123; struct svcinfo *next; void *ptr;//service的句柄 struct binder_death death; int allow_isolated; unsigned len;//服务名的长度 uint16_t name[0];//服务名&#125;;struct svcinfo *svclist = 0;//sm内部维护了一个svclist列表它是已经注册的服务列表 我们看看查找服务的过程 12345678910111213141516171819202122232425262728293031void *do_find_service(struct binder_state *bs, uint16_t *s, unsigned len, unsigned uid)&#123; struct svcinfo *si; si = find_svc(s, len); if (si &amp;&amp; si-&gt;ptr) &#123; if (!si-&gt;allow_isolated) &#123; // If this service doesn't allow access from isolated processes, // then check the uid to see if it is isolated. unsigned appid = uid % AID_USER; if (appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END) &#123; return 0; &#125; &#125; return si-&gt;ptr; &#125; else &#123; return 0; &#125;&#125;struct svcinfo *find_svc(uint16_t *s16, unsigned len)&#123; struct svcinfo *si; for (si = svclist; si; si = si-&gt;next) &#123; if ((len == si-&gt;len) &amp;&amp; !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) &#123; return si; &#125; &#125; return 0;&#125; 很简单，它在内部遍历链表，根据服务名进行查找如果找到返回对应的句柄si-&gt;ptr，否则返回0. 而添加服务的方法为do_add_service，它的实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546frameworks/native/cmds/servicemanager/service_manager.cint do_add_service(struct binder_state *bs, uint16_t *s, unsigned len, void *ptr, unsigned uid, int allow_isolated)&#123; struct svcinfo *si; if (!ptr || (len == 0) || (len &gt; 127)) return -1; if (!svc_can_register(uid, s)) &#123; ALOGE("add_service('%s',%p) uid=%d - PERMISSION DENIED\n", str8(s), ptr, uid); return -1; &#125; si = find_svc(s, len); if (si) &#123; if (si-&gt;ptr) &#123; ALOGE("add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n", str8(s), ptr, uid); svcinfo_death(bs, si); &#125; si-&gt;ptr = ptr; &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); if (!si) &#123; ALOGE("add_service('%s',%p) uid=%d - OUT OF MEMORY\n", str8(s), ptr, uid); return -1; &#125; si-&gt;ptr = ptr; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\0'; si-&gt;death.func = svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, ptr); binder_link_to_death(bs, ptr, &amp;si-&gt;death); return 0;&#125; 添加服务的名称长度不能大于127,随后在svclist中查找服务是否已经存在，如果存在，则释放之前的服务实例，将最新的服务句柄赋值给ptr，否则服务不存在，就需要为新的服务创建svcinfo结构，并对其进行初始化。同时将其添加到svclist的头部。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Binder系列：开篇]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-binder-1-src%2F</url>
    <content type="text"><![CDATA[综述 如果要对Android系统进行深入的了解，而不仅仅停留在对Framework层的理解，那么Binder是必须跨越的一部分内容，笔者认为，Android的消息事件机(Handler)和Binder是Android整个系统的骨骼架构，所有的血肉都依存这个骨骼架构建立起了庞大的Android系统，虽然从Linux的角度来讲，Android可能仅仅只是位于其上层的一个大型软件系统，但Binder的内容可以说是和Linux系统结合最为紧密的部分，它属于Linux Kernel层，实现了一套完整的进程通讯机制，而Android系统依赖于该机制提供各种服务。 基于Binder的分析，很多文章都会从kernel层，runtime层，framework层来进行分析，但往往一介绍就牵一发而动全身，各层相互交织，各种抽象的类，方法都需要了解透彻才能弄懂Binder的设计精髓。为了方便读者更好更快的理解Binder子系统，我打算采用自顶向下的方式结合具体的场景功能来解释Binder在其中是如何发挥作用的，而不仅仅是贴出相关的源码做简要的描述。另外，由于要理解kernel层binder部分的内容，要对linux系统和驱动部分有深刻的理解，而且这部分内容比较晦涩难以理解，所以kernel层的具体实现和细节我会单独进行分析，而对于它的上层，我们只需要知道Binder在kernel层提供了哪些功能以及如何这些提供给上层使用即可。 什么是Binder Binder顾名思义粘合剂，它的目的在于粘合住不同的进程，使之实现通信。准确的来说，Binder将粘接的进程分成了Server进程和Client进程。Client进程通过Binder来使用Server进程提供的服务，从而完成一系列的工作。这便是Binder存在的原因。 为什么是Binder 进程间的通信方式多种多样，常见的有共享内存，Socket，管道，消息队列，信号量等等，但Android为什么要另起炉灶开发出Binder作为IPC通信的方式，主要是因为以下几个原因： 从性能上来讲，Binder的效率比较好，一次完整的通信只需要一次数据拷贝 从架构上来讲，Binder采用的是C/S架构，结构比较简单和明确。 从安全性能上来讲，Binder在Server进程会根据权限策略进行控制访问。 Binder的架构 前面我们说过Binder是C/S架构，Client进程要访问Server端的进程来提供服务，Server进程一般在系统只存在一个，多个Client进程可以通过Server进程的句柄来和其进行通信，这个句柄是由Binder提供的，通过它可以和Server进程进行通信，这个也是由Binder保证的。 Android系统在此基础了上为了方便使用Binder机制，分别针对Framework层和Native层做了封装。 Java framework：Server端继承于Binder类，Client端继承于BinderProxy类。 Native Framework层：Server端继承于BBinder类，Client端继承于BpBinder。 为什么会针对不同层做不同的封装？实际上是由于Binder Server不仅在Native层存在(如SufaceFlinger，CameraService等)，同时在Framework层有有Binder Server(如ActivityManagerService,WindowManagerService等)为了方便各层能够更好的使用Binder机制，所以在每一层都对Binder进行了封装以方便使用。 但无论是Framework还是Native层的Binder Server，它们最终都要被Client端使用，因此必须有一个能够管理这些Server的大管家，它就是ServiceManager，而为了方便管理Server进程，Android系统提供了ServiceManager这个服务大管家，所有的实名Binder Server都需要在ServiceManager中注册了才能被Client进程使用。Client进程使用实名的Server服务也需要到ServiceManager取获取其对应的句柄，随后通过这个句柄和Server进程进行通信。这就是Binder IPC最基本的操作。我们可以将Android 的Binder机制同DNS机制做一个类比，Client请求Server进程进行IPC调用的过程就像是浏览器请求DNS进行域名解析的过程，在这个过程中，Client就是浏览器负责发起请求，ServiceManager就如DNS域名服务器，Server就像我们要访问的服务器，而Binder呢就是我们进行通信的路由器，浏览器请求访问服务器的过程需要知道服务器的Ip地址，有了这个IP地址才能够和服务器建立链接，然后进行通信，同样，Client同样需要从ServerManager得到Server进程的句柄，有了这个句柄，就可以通过它和Server进行进行通信了。 提纲 接下来，我们将分别从以下几个方面介绍Binder 理解Binder系列：服务管家ServiceManager 理解Binder系列：通信载体Parcel 理解Binder系列：Native层Binder的IPC过程 理解Binder系列：Java层Binder的IPC过程 理解Binder系列：Binder卟告原理及作用 理解Binder系列：匿名Binder 理解Binder系列：Binder的数据流过程 理解Binder系列：Binder的权限控制 在介绍完Binder的基本原理后，接下来会分析一些Binder应用的具体的场景 理解Binder系列：关于应用进程的Binder初始化 理解Binder系列：AIDL与Binder机制 理解Binder系列：自定义Binder服务 最后当我们对Binder有了具体的认识后，再回过头去深究Binder最为核心的机制，即Binder在driver中的实现内容，这部分的内容是最为晦涩难懂的部分，需要读者有一定的linux相关知识。 理解Binder系列：Binder驱动协议 理解Binder系列：Binder驱动工作机制 #参考 https://blog.csdn.net/universus/article/details/6211589]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ijkplayer的编译配置]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fijkplayer-rtsp%2F</url>
    <content type="text"><![CDATA[ijkplayer的编译 先下载 git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android 123456789101112131415161718checkout ffmpegcd ijkplayer-android./init-android.sh编译需要,可以配置在 ~/.bashrc中export ANDROID_NDK = xxx/xxxexport ANDROID_SDK = xxx/xxx下载完成后,编译ffmpegcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh all 可选择适合的平台编译完ffmpeg库后，再编译ijkplayercd .../compile-ijk.sh clean./compile-ijk.sh all 编译完成后的android/ijkplayer就是一个android工程，可以直接拷贝出来运行，在android/ijkplayer目录下的ijkplayer-armv7a，ijkplayer-arm64等文件夹下的src/main/libs下生成libijkffmpeg.so libijkplayer.so libijksdl.so三个库 ijkplayer 添加支持rtsp rtmp ijkplayer默认时不支持rtsp的，需要开启配置后重新编译库。 123cd ijkplayer-androidcd configvim module-lite.sh 12345678910111213添加export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-demuxer=rtsp"export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-demuxer=sdp"export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-demuxer=rtp"export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-demuxer=mjpeg"修改支持rtp，rtmpexport COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-protocol=rtmp"export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-protocol=rtp"添加export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-protocol=tcp"export COMMON_FF_CFG_FLAGS="$COMMON_FF_CFG_FLAGS --enable-decoder=mjpeg" 保存后，执行以下命令 12rm module.shln -s module-lite.sh module.sh 然后再重新编译 12./compile-ffmpeg.sh clean./compile-ffmpeg.sh all 编译ijkplayer 12./compile-ijk.sh clean./compile-ijk.sh all 编译完成后将android项目下最新的库拷贝到之前打开的ijkpalyer项目中即可 ijkplayer rtsp 的优化 通过测试发现之前编译的库打开rtsp时延时较大大概在13s左右,可以在ijkpalyer项目的依赖项目ijkplayer-java中，找到IikVideoView.java 文件，在createPlayer方法中添加以下配置 1234567891011121314/*以下时针对rtsp流的延时优化*/ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, "rtsp_transport", "tcp");ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "framedrop", 60);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "max-fps", 30);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "fps", 30);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "overlay-format", IjkMediaPlayer.SDL_FCC_YV12);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "packet-buffering", 0);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, "fflags", "nobuffer");ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, "max-buffer-size", 1024);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "min-frames", 10);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, "start-on-prepared", 1);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, "probsize", "4096");ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, "analyzeduration", 100L); 经过优化后可以在1~3内打开rtsp和rtmp连接 rtsp rtmp的测试 测试可以将地址加在SampleMediaListFragment中进行测试 测试的rtsp地址 rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov 测试的rtmp地址 ，没有找到合适的流 所以可以在本地通过nginx-rtmp-module搭建了推送流和点播服务 rtmp://192.168.2.233/live/stream (直播流) rtmp://192.168.2.233:1935/vod/test2.mp4 (点播) 从测试的效果来看 ijkplayer播放的效果还算比较理想 添加https支持 123cd ijkplayer-androidcheckout android openssl ./init-android-openssl.sh 编译 openssl 12345cd android/contrib编译 openssl./compile-openssl.sh clean./compile-openssl.sh all 编译ffmpeg ./compile-ffmpeg.sh clean ./compile-ffmpeg.sh all 编译 ijkplayer ./compil-ijk.sh all 编译完成后替换项目中的so库 测试地址 https://media.w3.org/2010/05/sintel/trailer.mp4]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解sychronized锁机制]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-synchronized-src%2F</url>
    <content type="text"><![CDATA[synchronized是java语言中用来保证线程同步的关键字，它的机制实际上是一种互斥锁，即通过Synchronized修饰的方法或者代码块，它可以保证同一时刻只有一个线程进入临界区访问保证其中的共享数据在，同时，它也可以保证共享数据内存的可见性，即一个线程对于共享数据的修改另外一个线程可以读到该修改的值（可能你会觉得这个理所当然，但事实上，由于各种如CPU或者编译器的指令重排，cache的回写等原因，当多个线程在操作共享数据时往往会有线程安全的问题，一个线程对于共享数据的修改可能另一个线程并不能够立马看到，这个是由于JMM并没有按照happen-before的规则去设计）。 synchronized使用方式 synchronized使我们在java中最常用的一种用来进行线程同步的方式，一般就三种最常见的使用方式： 修饰实例方法，锁是当前实例对象 修改静态方法，锁是当前class对象 修饰同步代码块，锁是指定的对象 如以下代码所示 1234567891011121314151617public class Test&#123; //修饰实例方法 public synchronized void fun1()&#123; &#125; //修饰静态方法 public synchronized static void fun2()&#123; &#125; //修饰同步代码块 public void fun3()&#123; synchronized(this)&#123; &#125; &#125;&#125; 底层语义 任何对象在JVM内存中都由三部分构成：对象头、实例数据和对齐填充，而对象头是java实现synchronized的基础，它使用的锁对象信息是存储在java对象头里的。 Java对象头 Java对象头包括两个部分，Mark Word和类型指针，其中Mark Word里存储了对象的hashCode,分代年龄，锁标志位，线程持有的锁，偏向线程ID等信息。类型指针用于确定这个对象是属于哪个类的实例 如32位JVM 中Mark Word默认存储结构为： 对象头除了默认的存储结构，还有如下可能的变化结构，它的存储结构并不是被设计成固定的。 从Mark word的存储结构可以看出，它有四种锁状态，分别是：无锁，偏向锁，轻量级锁和重量级锁，其中偏向锁和轻量级锁是在Java SE1.6中针对sychronized做的锁优化策略。关于锁优化的部分我们后面再介绍，这里我们主要分析重量级锁。重量级锁的标记位10，指向互斥量的指针这个其实是指向monitor对象（也称为管程或监视器锁），每个对象实际都和一个monitor对象关联，这也是每个对象之所以能够成为对象锁的原因。使用Synchronized进行同步，本质上就是对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。monitor对象的内部实现中有两个队列，分别位_WaitSet和_EntryList，当多个线程同时访问同步代码时，首先会进入_EntryList队列中，当线程获取到对象的monitor后，monitor对象记录下当前拥有者线程并将引用计数加1；当线程调用wait方法时，将释放当前持有的monitor，引用计数减1，同时该线程进入_waitSet队列中等待被唤醒。 synchronized 的实现原理 将上面的示例代码Test编译生成class文件后，通过javap -v Test查看class文件的字节码内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Classfile /F:/eclipse/demo/bin/demo/Test.class Last modified 2019-2-20; size 437 bytes MD5 checksum 55416227e14946b1fe0b5e1318122ea4 Compiled from "Test.java"public class demo.Test minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Class #2 // demo/Test #2 = Utf8 demo/Test #3 = Class #4 // java/lang/Object #4 = Utf8 java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Methodref #3.#9 // java/lang/Object."&lt;init&gt;":()V #9 = NameAndType #5:#6 // "&lt;init&gt;":()V #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Ldemo/Test; #14 = Utf8 fun1 #15 = Utf8 fun2 #16 = Utf8 fun3 #17 = Utf8 SourceFile #18 = Utf8 Test.java&#123; public demo.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ldemo/Test; public synchronized void fun1(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 14: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 this Ldemo/Test; public static synchronized void fun2(); descriptor: ()V flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED Code: stack=0, locals=0, args_size=0 0: return LineNumberTable: line 18: 0 LocalVariableTable: Start Length Slot Name Signature public void fun3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: dup 2: monitorenter 3: monitorexit 4: return LineNumberTable: line 21: 0 line 24: 4 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ldemo/Test;&#125; 可以看到对于sychronized在同步块中使用monitorenter，monitorexit两个指令来保证互斥性，其中monitorenter指向同步代码块的开始位置，而monitorexit指向同步代码块的结束位置，当执行monitorenter指令时当前线程会去获取对象的monitor，如果monitor的引用计数为0，那么就可以获取到monitor并将计数值加1，此时可以成功进入同步代码块，此时若有其他线程尝试获取monitor该线程会阻塞，而如果当前拥有monitor的线程再次尝试拥有monitor，那么此时也是可以获取到的，这是因为monitor是可重入的，这时候只要对计数值再加1即可。当通过monitorexit退出时，将计数值减1，如果此时计数值为0将释放monitor，这样其他线程就有机会获取到monitor。 而修饰同步方法则采用方法修饰符ACC_SYCHRONIZED来实现互斥性。它的实现是透明的，在sychronized修饰的同步方法被调用和放回操作时，JVM可以根据方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。如果方法的访问标志设置了ACC_SYCHRONIZED，执行线程将尝试先持有monitor，然后再执行方法体，最后在方法返回时释放monitor，同样的，如果一个线程持有了monitor，此时其他线程再次尝试持有monitor进入方法体时将会等待。需要注意的是，如果执行的同步方法抛出了异常，那么这个同步方法持有的monitor将在异常抛出的地方进行释放。 sychronized锁优化 Java SE 1.6对sychronized锁进行了优化，添加了偏向锁和轻量级锁，就如我们之前在对象头的结构中看到的。接下来简单介绍下JVM是如何对sychronized锁进行优化的。 偏向锁 偏向锁是基于这样的事实，大多数情况下，锁并不存在多线程的竞争，而是由同一个线程多次获得，此时为了降低获取锁时的开销而引入了偏向锁的概念。 偏向锁的概念是当一个线程获得锁，那么就进入偏向锁的模式，此时Mark word存储的是偏向锁结构，会记录下该线程的ID，当这个线程再次请求锁的时候，只需要简单测试下对象头Mark word是否存储着指向该线程的偏向锁，无需再做任何同步操作就可以再次获取到锁，在没有锁竞争的情况下，这个由较好的优化效果，因为同一线程是可能多次连续申请锁的。当出现多个线程的锁竞争时，每次申请锁的线程可能都是不同的，偏向锁会失效，此时偏向锁会升级为轻量级锁。 轻量级锁 轻量级锁基于这样的事实，对大多数的锁来说，在同步周期内都没有锁竞争，也就是在线程交替执行同步代码块的场景下，轻量级锁能够发挥其优化的作用。 当一个线程进入同步块的时候，如果同步对象锁状态为无锁状态，那么JVM会在该线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象的Mark word拷贝，称之为Displaced Mark Word，拷贝完成后，JVM会尝试使用CAS操作将对象头中Mark word的指针指向该记录，并将该记录的owner设置为锁对象的Mark word，如果更新成功，这个线程就有了该对象的锁，并将对象Mark word的锁标记位设置位00，表示对象处于轻量级锁状态，如果CAS更新失败了，JVM会检查对象的Mark word是否指向线程当前栈帧中的锁记录，如果是，那么说明当前线程已经拥有了这个对象的锁，可以直接进入到同步中执行。否则说明多个线程竞争锁，轻量级锁就膨胀为重量级锁。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reentrantlock源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-reentrantlock-src%2F</url>
    <content type="text"><![CDATA[ReentrantLock基于AQS实现的一种独占锁，也是重入锁。它实现了非公平锁和公平锁。本篇我们将通过源码对此做分析。 继承关系和构造 12345public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; private final Sync sync; ……&#125; ReentrantLock结构非常简单，它实现了Lock和Serializable接口，Lock接口包含了实现锁的基本方法，比如lock，unlock等。同时，ReentrantLock包含一个Sync对象，这里的Sync实际上为AQS的一种实现模型，关于AQS我们之前有所介绍，它是一种并发同步框架，ReentrantLock的两个模式的锁都是基于Sync实现的。 Sync同步模型 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is * implemented in subclasses, but both need nonfair * try for trylock method. */ final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; ……&#125; Sync实现了继承自AQS框架模型，它为子类提供了lock抽象方法。同时默认实现了nonfairTryAcquire即非公平锁的实现，以及tryRelease方法即锁的释放。ReentrantLock基于Sync实现了非公平和公平锁，默认是非公共锁。 123public ReentrantLock() &#123; sync = new NonfairSync();//默认实现了非公平锁&#125; ###非公平锁 123456789101112131415161718static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 基于Sync，NonfairSync实现了lock抽线方法，并且同时实现AQS的tryAcquire方法，这里我们看看非公平锁的实现。 非公平锁获取锁的实现： 通过CAS尝试获取锁，如果成功，当前线程将取得执行权 否则通过AQS的acquire来获取锁，最终通过tryAquire来获取锁，这里通过Sync的nonfairTryAcquire方法实现。 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 在nonfairTryAcquire方法中，通过getState获取锁状态，如果为0，则表示当前锁处于空闲状态，尝试通过CAS获取锁，如果成功，则获取执行权。否则判断当前线程是否已经执行，如果已经执行的话就表示线程已经获取到了锁，需要重入，这里对锁状态加1，否则就返回false交给AQS处理，即将当前线程封装为Node节点添加到FIFO队列中，然后park线程。 公平锁 12345678910111213141516171819202122232425262728293031static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 公平锁的lock实现是通过其tryAcquire方法实现，它的实现原理如下： 首先获取获取锁的状态，如果为0表示锁空闲，则再判断是否队列中还有等待的前继线程，如果没有的话尝试通过CAS获取锁，如果成功，线程获取执行权，否则返回false，将线程添加到等待队列。否则判断当前线程是否已经执行，如果是，则表示重入，需要对锁状态+1。 区别 公平锁和非公平锁的区别在于： 非公平锁再lock时不管当前锁的状态，直接尝试通过CAS获取锁，而非公共锁在lock时首先判断当前锁状态，如果已经被占有，就直接去队列中等待了。 在非公平锁和公平锁中如果都检测到锁空闲，非公平锁直接也是通过CAS尝试获取锁，而公平锁会去检查等待队列是否有线程在等待，如果没有才尝试通过CAS获取锁，否则直接添加到等待队列中。 可见非公平锁和公平锁的最大区别都在于，非公平锁的实现常常显的粗暴，有点类似于插队，即它不管当前队列和锁的情况先直接去插队(尝试获取锁)，成功了就直接去执行了，失败了就再到队列中排队，而公平锁显的温和许多，先看看队列或者锁是否都在忙，如果是就直接去队列中排队了。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS同步机制源码分析(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-aqs-frame-src%2F</url>
    <content type="text"><![CDATA[AQS 即AbStractQueuedSynchronizer 抽象队列同步器，他是一个并发同步器框架，许多锁的实现正是基于AQS实现的，比如ReentrantLock,Semaphore,ReadWriteLock等等都是，可以说这是java并发框架类最为重要的一个类。 它的继承结构如下： 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable 可以看到它是一个抽象类，继承自AbstractOwnableSynchronizer，它是一种再独占模式中的抽象独占同步器。 AQS的为我们提供了统一的实现锁的框架，它实现了如下基本功能： 获取同步状态 如果允许，则获取锁，如果不允许就阻塞线程，直到同步状态允许获取。 释放同步状态 修改同步状态，并且唤醒等待线程 同时AQS同步机制同时满足了如下需求： 独占锁和共享锁两种机制 线程阻塞后，如果需要取消，需要支持中断 线程阻塞后，如果有超时要求，应该支持超时中断机制 为了实现AQS的基本功能，其内部维护了一个同步状态state(通过volatile和CAS来保证其原子性和可见性)和一个CLH FIFO队列(非阻塞队列)，队列的节点Node代表了线程. Node节点的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static final class Node &#123; /** 线程已被取消 */ static final int CANCELLED = 1; /** 当前线程的后继线程需要被unpark(唤醒) */ static final int SIGNAL = -1; /** 线程(处在Condition休眠状态)在等待Condition唤醒 */ static final int CONDITION = -2; /** 共享锁 */ static final Node SHARED = new Node(); /** 独占锁 */ static final Node EXCLUSIVE = null; volatile int waitStatus; /** 前继节点 */ volatile Node prev; /** 后继节点 */ volatile Node next; volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** 获取前继节点 */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; /* 构造函数*/ Node() &#123;&#125; Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 基于AQS的实现有两种锁的模式，分别为独占锁和共享锁。基于这两种模式我们分别讨论同步状态的获取和释放。 独占模式 AQS的独占锁在获取锁时会通过acquire来获取同步状态，我们看看这个方法 独占： 123456789public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 独占可中断： 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 独占可超时： 1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; tryAcquire在AQS的未实现，它是由子类实现的，返回true，表示成功，线程继续，否则失败，阻塞线程并加入队列。 12345678910111213public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125;protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 释放成功会唤醒后续节点，这里tryRelease同样在AQS中未实现，需要在子类中处理。 共享模式 共享： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 共享可中断： 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 共享可超时： 1234567891011public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); &#125;protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 同tryAcquire类似，tryAcquireShared在AQS中未实现，它同样是由子类实现同步状态的更新获取逻辑的。 12345678910public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 可以看出，AQS通过一些tryAcquirexx tryReleasexx方法提供了同步器的实现框架，这些方法主要是来更新或者获取state同步状态的，而AQS基于其返回值决定是否阻塞执行线程并加入到其队列中。 使用场景 在竞争激烈的多线程环境下，使用非公平锁可以很大程度上提高系统运行的效率，如果一个线程持有锁时间过长那么每次获取非公平锁需要额外的一次CAS操作。 总结 AQS是通过volatile结合CAS实现抽象并发同步器，这种方式是java concurrent包实现的基础，一个通用化的实现模式： 首先，声明共享变量为volatile。 然后，使用CAS的原子条件更新来实现线程之间的同步。 同时，配合以volatile的读/写和所具有的volatile读和写的内存语义来实现线程之间的通信。 AQS内部通过一个非阻塞式的FIFO队列和volatile变量state来实现，FIFO队列和state都是通过CAS来实现同步。在内存语义上CAS具有volatile读和volatile写一样的效果，同时CAS保证了共享变量的原子性。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS同步机制源码分析(二)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-aqs-src%2F</url>
    <content type="text"><![CDATA[本篇我们主要分析AQS独占模式的源码，关于AQS的独占模式我们上一篇有所介绍。主要这里我们介绍acquire和release部分的代码。这会涉及到AQS的阻塞唤醒机制，还有其维护的FIFO队列。 阻塞过程 独占模式下的阻塞过程 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire返回boolean值，true代表状态更新成功线程继续，否则当前线程需要阻塞，并添加到队列中。这里addWaiter会为当前线程创建Nodj节点并添加到队列中。因为是独占模式节点模式为Node.EXCLUSIVE。 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; addWaiter中首先为线程创建node节点,如果tail不为null说明队列不为空，这里先尝试通过CAS将node添加到队尾，然后返回，如果CAS尝试失败，则通过调用enq添加。 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 首先enq是一个for循环，这里可以保证node节点一定可以添加到等待队列。首先判断队列是否为空，如果是则new一个Node节点作为当前空队列的头节点，同时将尾节点也指向它，然后在下个循环中同样通过CAS添加当前node节点到队列中。即使失败也通过循环再次尝试添加，直到成功。 我们看看AQS中队列的节点信息 12345678910111213/** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; AQS队列是通过head和tail节点来维护的，其中Node节点分别有前驱和后继节点。 它是一个简单的队列结构，而保证线程节点能够正确添加到队列中正是基于CAS，这使得它是一个非阻塞式的队列。 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg)&#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 添加Node到队列中后，有可能会阻塞当前线程，这里获取当前node的前驱，这个前驱节点如果等于head,说明队列中的头节点所代表的线程已经执行完毕release了，当前线程是从parck中解放出来的，这时候当前线程需要通过tryAcquire更新抢占锁，如果抢到了就将当前线程的node节点作为队列的头节点即head，head节点代表的线程是当前正在运行的线程。当然如果p不等于head了，说明它前面还有等待的线程再等待，需要注意的这个队列是一个非阻塞的FIFO队列，所以它需要等待前面的线程执行完毕，因此进入通过shouldParkAfterFailedAcquire判断是否应该park当前线程，返回true表示应该阻塞线程，然后通过parkAndCheckInterrupt来阻塞当前线程。 123456789101112131415161718192021222324252627private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 这里只有当node的前驱节点的waitStatus为Node.SIGNAL时才会返回true，此时表示前驱节点会unPark node节点的线程，所以可以park这个线程。如果前驱节点不满足这个条件，就需要查找一个不为CANCELED的节点作为node的前驱，并更新它的waitStatus为SIGNAL。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 线程的阻塞是在parkAndCheckInterrupt中进行的，阻塞使用了LockSupport的park。这样当前线程就阻塞在acquireQueued的for循环中等待被唤醒。 共享模式下的阻塞过程 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 在共享模式下的逻辑类似于独占模式，tryAcquireShared返回负值代表未获取到同步状态需要阻塞，这里是通过doAcquireShared来完成的。 123456789101112131415161718192021222324252627282930313233343536373839404142private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;``` 不同于独占模式下的阻塞模式，这里首先针对当前线程创建Node.SHARED节点，使用addWaiter添加到阻塞队列中，随后的逻辑基本和独占模式类似，即通过一个循环来判断当前节点是否满足唤醒的条件:1 当前节点是阻塞队列的第一个节点，且再次通过tryAcqurireShared获取到了同步状态，对于共享模式来说即满足 r&gt;=0，随后将本节点node设置为头结点根据需要设置中断返回。阻塞的逻辑同独占模式下，这里就不再赘述。## 唤醒操作```javapublic final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 当子类的实现tryRelease返回true表示释放了同步状态，这时候就可以唤醒当前node节点所代表线程的后继节点了。这一步是通过unparkSuccessor实现的。 123456789101112131415161718192021222324252627private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 这里取到当前队列的下一个node节点，并通过LockSupport.unpark解除相应线程的阻塞状态。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-threadlocal-src%2F</url>
    <content type="text"><![CDATA[ThreadLocal即线程本地变量，它的设计并不是用来处理并发的。它被用来为每个线程维护独立的变量副本。这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 明白了ThreadLocal设计的初衷，我们接着看看它的实现，首先我们看它的构造方法。 12public ThreadLocal() &#123;&#125; 内部是一个空的实现 设置元素 往ThreadLocal中设置一个对象是通过set方法来实现的 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 首先在set方法中先获取当前的线程对象，然后通过getMap获取一个ThreadLocalMap对象。 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; getmap方法返回的Thread 内部的成员threadLocals，它就是一个ThreadLocalMap对象是由Thread对象维护的。在线程中首次使用ThreadLocal的set时getMap返回的结果为null，它需要调用createMap来创建。否则就通过map的set方法来将value保存，这里的key就是我们的ThreadLocal对象。 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 首次创建是带有一个初始值的。我们看看ThreadLocalMap的构造方法。 1234567891011121314151617181920212223static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; private static final int INITIAL_CAPACITY = 16; private Entry[] table; private int size = 0; private int threshold; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; ……&#125; ThreadLocalMap初始的大小为16个Entry的数组，注意这里的Entry是一个WeakRefrence&lt;LocalThread&lt;?&gt;&gt;,它通过ThreadLocal的hashcode映射到对应的索引处。随后通过第一个值firstValue创建第一个Entry放到相应的位置。 1234567891011121314151617181920212223242526private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ThreadLocalMap的set方法首先通过hashcode计算要保存value的索引，随后从该索引处开始便利table，如果key值同e.get()，则说明找到了对应的Entry，则直接更新对应的value即可，否则如果k == null 说明ThreadLocal有可能已经被Gc回收，还记得Entry的key是弱引用，这时候需要将value的值重新替换这个失效的Entry即可。否则即使没找到对应的key，则为其生成一个新的Entry，并增加计数，如果size大于threadhold了需要对map的大小进行调整。 获取元素 123456789101112131415161718192021public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 获取元素是通过get元素完成的，首先获取到当前线程，通过该线程取到线程的ThreadLocalMap对象map,通过map以ThreadLocal当前对象作为key获取到Entry,如果Entry不为null，则返回相关的值。否则会返回一个初始值。这个初始值可以由我们自己通过initalValue来指定，默认返回null. 移除元素 1234567891011121314151617181920public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125;private void remove(ThreadLocal key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; 移除元素是通过ThreadLocalMap的remove来删除的，这个操作首先会去通过当前threadlocal对象计算在map中的索引，然后通过删除和当前key相同的那一项。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap源码走读]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjava-linkedhashmap-src%2F</url>
    <content type="text"><![CDATA[LinkedHashMap是HashMap的子类，它同HashMap的不同之处在于HashMap存放元素是无序的，而LinkedHashMap通过维护一个所有Entry的双向链表，保证了元素迭代的顺序，该迭代顺序可以是插入顺序或者是访问顺序。 继承关系 12345678910public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123; /** * The head of the doubly linked list. */ private transient Entry&lt;K,V&gt; header; ……&#125; header用于双链表的链表头 HashMap的Entry结构 1234567891011121314151617static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ...&#125; 123456789private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; ...&#125; LinkedHashMap的Entry结构继承自HashMap的Entry，多了两个元素before和after,这两个元素就是用于双链表的来维护元素插入顺序的，它和next的作用不同，next是用于table数组上的链式存储结构的。 注意该循环双向链表的头部存放的是最久访问的节点或最先插入的节点，尾部为最近访问的或最近插入的节点，迭代器遍历方向是从链表的头部开始到链表尾部结束，在链表尾部有一个空的header节点，该节点不存放key-value内容，为LinkedHashMap类的成员属性，循环双向链表的入口。 put和get方法访问元素都会导致被访问的元素被移动到双链表的尾部，头部即最近最久未访问的元素。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet源码实现]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjava-hashset-src%2F</url>
    <content type="text"><![CDATA[HashSet实现了Set接口，Set是一种无序不可重复的集合。HashSet内部通过HashMap来实现的 本篇我们介绍它的实现部分 12345678910111213141516public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; //内部通过HashMap实现 private transient HashMap&lt;E,Object&gt; map; //这个对象用来关联已经存在的对象的Value，已经存在的对象实际上为Key值 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;&#125; ####添加元素 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 添加元素到HashSet的方法异常简单，只是调用map的put方法，这里可以看到e实际上为map的key，它作为HashMap的元素 而PRESENT对象是与其关联的对象，map的put返回null表示之前没有添加过该key-value对。而HashSet的add返回true表示 e未添加过。 ####移除元素 123public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 移除元素是通过map的remove方法来实现的。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashtable源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-hashtable-src%2F</url>
    <content type="text"><![CDATA[HashTable同HashMap类似，它也是一种散列表，用于存储键值对。本篇将对HashTable源码进行分析。 继承关系和结构 123456789101112131415161718public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; private transient Entry&lt;K,V&gt;[] table; private transient int count; private int threshold; private float loadFactor; ……&#125;private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; int hash; final K key; V value; Entry&lt;K,V&gt; next; ……&#125; Hashtable不同于HashMap继承自Dictionary抽象类，但相同的继承了Map,Cloneable,Serializable接口。 成员类似于HashMap,table为散列表，count为元素个数，threshold为阈值，当容量大于等于阈值时扩容，loadFactor为加载因子用于计算阈值。Entry结构和HashMap一样，用于存储键值对。 构造方法 12345678910111213141516171819202122public Hashtable() &#123; this(11, 0.75f);&#125;public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f);&#125;public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); initHashSeedAsNeeded(initialCapacity);&#125; 构造方法默认大小为11 ，加载因子为0.75，阈值= 11*0.75 = 8 添加元素 1234567891011121314151617181920212223242526272829303132333435363738public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++; if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null;&#125;private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode();&#125; 添加的逻辑首先判断value是否为null，同时通过hash计算key的hash值，在hash方法中同样可以看到key值不能为你null，否则同样抛出异常。这点和HashMap不一样，计算完hash后，计算散列表的索引位置，然后遍历bucket，找到对应的key后，更新value值即可，否则判断count是否大于等于阈值，如果是则需要rehash，这个就是扩容的过程，最后为这个新的键值对创建Entry，并放在bucket的头部。 需要注意的是：put方法被synchronized修饰，即它是线程安全的。 移除元素 1234567891011121314151617181920public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null;&#125; 移除元素的过程也很简单，同样是通过hash值计算索引后取到对应的bucket，然后遍历找到对应的key值后从bucket删除即可。类似的remove也是线程安全的。 扩容 12345678910111213141516171819202122232425262728293031323334 protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;K,V&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;K,V&gt;[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); boolean rehash = initHashSeedAsNeeded(newCapacity); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; if (rehash) &#123; e.hash = hash(e.key); &#125; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125;&#125; Hashtable的扩容操作基本和HashMap是相同的，只不过新的容量=(oldCapacity &lt;&lt; 1) + 1 而HashMap中是旧容量的2倍。而且MAX_ARRAY_SIZE 为 Integer.MAX_VALUE - 8. 遍历 1234Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next();&#125; 通过迭代器迭代遍历的一般形式，当然也可以通过keySet,进行迭代。这里我们看看entrySet的实现即可。 12345public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet;&#125; entrySet会创建一个EntrySet对象 123456private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; ……&#125; iterator会通过getIterator返回一个迭代器 123456789101112131415private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return Collections.emptyEnumeration(); &#125; else &#123; return new Enumerator&lt;&gt;(type, false); &#125;&#125;private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return Collections.emptyIterator(); &#125; else &#123; return new Enumerator&lt;&gt;(type, true); &#125;&#125; Hashtable支持Enumberation和Iterator的遍历方式，Enumberation是比较旧的遍历方式，Hashtable中使用Enumberation是历史问题，同时Hashtable支持Iterator,这两种不同的迭代方式都是通过Enumberator实现的。实际是使用了标记做区分，false为Enumberation，true为Iterator. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; Entry[] table = Hashtable.this.table; int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; boolean iterator; protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; …… // Iterator methods public boolean hasNext() &#123; return hasMoreElements(); &#125; public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException("Hashtable Enumerator"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125;&#125; 可以看到对于Enumberation是不支持remove的，而Iterator支持remove。next方法会取出迭代器下一个可用的元素，它是通过nextElement实现的，hasNext则是判断迭代器中还有没有可用的元素，它通过hasMoreElements实现的。下面我们具体分析 123456789101112public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null;&#125; 初始情况下entry为null,index为table.length,可以看出hasMoreElements从散列表的后向开始遍历，判断当前entry是否为null，为null则切换bucket继续查找，不为null返回true. 1234567891011121314151617public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException("Hashtable Enumerator");&#125; nextElement用来获取可用的元素，这里可以获取到可用元素的条件是hasMoreElements返回true，即entry不为null，获取到后根据指定的type分别取到key，value或者entry返回，并且将entry赋为e.next即下个Entry。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-hashmap-src%2F</url>
    <content type="text"><![CDATA[HashMap是最常见使用最频繁的java集合容器之一，它用来存储键值对。 继承关系及结构 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable` 可以看出 HashMap 继承自AbstractMap，实现了Map，Cloneable，Serializable等接口 HashMap内部由hash数组(或者叫bucket数组)和链表组成结构，链表用来解决hash冲突，hash数组的每个元素都是一个单链表的头结点。 1234567891011121314public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; transient int size; int threshold; final float loadFactor; …… &#125; table为hash数组用来存储链表的头结点，theshhold为阈值，当size满足 size &gt;= threshold 时需要对hashmap扩容，threshold = newCapacity * loadFactor,这里newCapacity为期望的新的容量大小。 具体我们在扩容时说明。 Entry是HashMap存储元素的数据结构，它至少应该包含存储的键值对以及链表结构中的next节点引用 1234567static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; ……&#125; 除了上面说的三个元素，Entry还包含了hash信息，这里的hash值是通过key的hashcodef进行哈希后的值。hash函数为 1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 感兴趣的读者可以研究下这个hash方法，它能使得添加的元素均匀的分布在hash数组中。 构造方法 123456789101112131415161718192021public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();&#125; 默认的情况下，HashMap的容量为16，加载因子为0.75 ，所以阈值 threshold = 16，初始情况并没有通过loadFactor计算。init的实现为空，可见在构造方法中并没有去构造table数组，只是设置了一些参数。初始化table数组的过程是在添加第一个元素的时候进行的。 添加元素 了解了HashMap的结构后，接下来就看看怎么添加元素到HashMap中，这是通过put方法来完成的 12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; put过程分为下面几个步骤进行： 添加第一个元素的时，table还是空的数组，这时需要通过inflateTable来初始化数组 如果key值为null,使用putForNullKey添加元素 否则通过key值计算hash值，如果key值已经存在则更新数组，否则通过addEntry添加新的键值对到map中 下面我们具体分析上面的步骤，先看数组是如何初始化的 12345678private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125; 这个方法会通过roundUpToPowerOf2调整toSize，toSize为我们要设置的大小，这里调整为2的幂次方大且大于等于toSize,默认的大小一开始为16，这里调整后同样为16,然后计算阈值，通过capacity * loadFactor，当然阈值不能大于MAXIMUM_CAPACITY + 1，这里我们就明白了再构造方法中并不计算threshold，因为这里会进行真正的计算。最后 会通过initHashSeedAsNeeded生成一个hash seed ，这个seed在hash中会使用，我们不用关心了解即可。 然后我们看下key为null值时HashMap是如何处理的 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 可以看到当key值为null是，默认是加入table中索引为0的位置的,它的hash值也为0。如果在table[0]的链表中有key值为null的则更新value值即可，否则通过addEntry添加，最后一个参数0指定了添加到table的0索引指定的buket。 对于key值不为null的元素，首先对key进行哈希后得到hash值，通过hash值确认在table中的index位置，这个是通过indexfor完成的 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; 得到索引后，就可以通过遍历索引处的链表开始查找该元素，如果找到就更新value值，这里找到的条件为 1e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)) 即hash值和key值都要匹配，key值的匹配可能会通过equals进行匹配，这也是最常见的情况。 如果未找到key值对应的Entry，需要调用addEntry添加 1234567891011121314void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 如果添加元素时size值大于等于阈值且当前buket不为空则需要扩容，关于扩容我们后面再说，这里看如何为key-value创建Entry，在createEntry首先从table中取到对应的bucket,随后new一个新的Entry，同时将size加1. 123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 可以看出，新创建的Entry是作为链表的头结点的，而之前取出的e头结点在创建Entry时候赋值给新结点的next引用，这样就是每次添加新的元素都会添加到链表的头部。 删除元素 12345678910111213141516171819202122232425262728293031323334public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value);&#125;final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; 删除元素的逻辑和添加的大体上是类似的，首先通过key值计算hash值，这里需要注意当key为null时，hash值为0，随后从table中取到对应的bucket,最后遍历bucket，找到满足条件的key值，从链表中移除，并将size减1. 扩容 扩容的时候是在addEntry中进行的，这样可以分摊扩容操作的代价，具体看代码 12345if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length);&#125; 之前我们知道了table数组大小默认为16，阈值为16*0.75=12,也就是当map大小增加到12时就要增加容量了，这里的容量是针对table数组的。而size是map的元素个数。可以看到默认情况是扩充为原来容量的2倍。 1234567891011121314void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; Map的容量是有大小限制的，最大为MAXIMUM_CAPACITY默认为2^30，当容量已经是最大值时不允许再扩容了，否则根据新的容量大小创建新的Entry数组，同时使用transfer将旧table中的元素转移到新的table数组中，同时根据新的容量计算阈值threshold。 123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; transfer会将旧table中的元素转移到新的table中,转移过程可能需要对key进行重新hash。 注意事项 由于HashMap在操作bucket时需要先对key值进行hash，而hash过程中会通过key值的hashCode进行计算，所以在针对逻辑相等的对象不仅需要实现equals方法而且也应该实现hashCode方法以保证hashcode值在逻辑上相等，否则key会被映射到不同的bucket中导致查找失败。这个在Joshua Bloch《Effective java》一书中有所强调。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-arraylist-src%2F</url>
    <content type="text"><![CDATA[继承关系 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList是开发者广泛使用的java集合，它继承自AbstractList 实现了List接口，支持随机访问以及拷贝，持久化。 本篇主要对ArrayList的实现进行分析，首先我们看它的构造方法 1234567891011121314151617181920public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; ArrayList的构造方法很简单，主要是初始化elementData值，它是一个Object数组用来存储我们的元素。根据参数的不同实现也不同。 元素添加 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 首先调用ensureCapacityInternal来确保有足够的容量来存储e,随后将e保存在elementData数组中并增加size值 默认返回true。 在指定索引处添加元素 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 这个方法将元素element添加到数组中指定的index位置，所以效率上比add要慢，因为可能需要对数组元素进行挪动。同样这里需要保证足够的空间，并在添加完成后增加size计数。 对于Add方法，这里需要注意的是当elemmentData数组为空时，如果执行add(1,E)时会抛出IndexOutOfBoundsException 这是因为在Add之前通过rangeCheckForAdd检查了index的值是否在[0,size]的区间，如果不再该区间那么抛出该异常。 1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 元素删除 元素的删除有两个版本，分别针对索引和元素进行删除 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 通过索引删除，需要先对index做检测，删除index必须小于size,否则会报IndexOutOfBoundsException，然后从数组中取出index对应的元素oldValue，作为结果返回，随后计算需要移动的元素个数，然后通过System.arracopy完成index后面元素的移动。 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 通过元素删除首先判断要删除的元素o是否为null，如果为null，遍历当前数组找到对应的索引然后通过fastRemove删除，如果o不为null,则通过其equals方法在数组中找到对应的元素索引，然后通过fastRemove删除。 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 这里有个问题：可以用for循环直接删除ArrayList的特定元素？ 答案是不可以，不同的for循环删除可能错误都不同，如果时一般的for循环则只能删除一个元素， 而如果使用泛型for删除的话会抛出ConcurrentModificationException，使用泛型for会用到List内部的迭代器Itr，它在通过next遍历元素时会通过checkForComodification检查ArrayList的modCount和expectedModCount是否一直，不一致的话就会抛出ConcurrentModificationException异常。 12345678ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();arr.add()...for(String item:arr)&#123; if(item.equals(...))&#123; arr.remove(item); &#125;&#125; 这种删除方式在remove方法中删除元素会更新modCount计数，而expectedModCount只会在迭代器版本的remove方法中更新，所以导致了不一致的情况，正确的方法是使用list.iterator()对ArrayList循环删除。 扩容 我们看看ensureCapacityInternal是如何保证容量大小的，即ArrayList如何进行扩容的 1234567891011121314151617181920212223242526private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; DEFAULT_CAPACITY默认为10，也就是说第一次添加到ArrayList的时候会开辟大小为10的数组。如果需要的大小大于当先数组的大小需要调用grow来完成容量的增加。 grow的resize逻辑如下： 计算新的容量大小为 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)这个新的容量为原来的1.5倍。 如果新的容量小于我们需要的 则以我们需要的为准开辟空间 如果新的容量大于最大可以开辟的容量值(Integer.MAX_VALUE - 8)，那么需要hugeCapacity进行大容量的分配 使用Arrays的copyOf将原数组resize到指定大小]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP下载和编译]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-build%2F</url>
    <content type="text"><![CDATA[###windows下的源码下载 ####创建目录 新建目录 aosp，cd到目录下 然后 通过 git克隆以下镜像，这会在目录下创建manifest目录 git clone https://android.googlesource.com/platform/manifest.git //没有梯子使用清华源 git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git cd到manifest目录中，通过git branch -a查看分支版本 找到想要下载的分支版本进行下载，如 git checkout android-6.0.1_r79 最后通过以下python脚本进行下载 123456789101112131415161718192021222324252627282930313233import xml.dom.minidomimport osfrom subprocess import call# 1. 修改为源码要保存的路径rootdir = "D:/android_source_code/Android_6_0_1"# 2. 设置 git 安装的路径git = "C:/Develop/Git/bin/git.exe"# 3. 修改为第一步中 manifest 中 default.xml 保存的路径dom = xml.dom.minidom.parse("D:/android_source_code/manifest/default.xml")root = dom.documentElement#prefix = git + " clone https://android.googlesource.com/"# 4. 没有梯子使用清华源下载prefix = git + " clone https://aosp.tuna.tsinghua.edu.cn/"suffix = ".git" if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName("project"): os.chdir(rootdir) d = node.getAttribute("path") last = d.rfind("/") if last != -1: d = rootdir + "/" + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute("name") + suffix call(cmd) ###Android源码的下载 ####下载repo并配置repo 12345678sudo apt-get install git-core curlgit config --global user.email '邮箱'git config --global user.name '名字'mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo ####创建源码路径 12mkdir aospcd aosp ####下载 执行init repo init -u https://android.googlesource.com/platform/manifest 这样下载的是master的代码，如果要指定某个版本，可以通过 repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.4_r1 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成 REPO_URL = ‘https://mirrors.tuna.tsinghua.edu.cn/git/git-repo’ 然后下载通过 repo sync ####JDK的配置 编译KK(android4.4)需要jdk的版本是1.6，注意这里的jdk为oracle，不能是openjdk， 12345678910111213sudo mkdir /usr/local/jdk #jdk的安装路径sudo cp /home/youlor/Downloads/jdk-6u45-linux-x64.bin /usr/local/jdk#其中/home/youlor/Downloads/jdk-6u45-linux-x64.bin为jdk1.60_45的二进制文件所在路径cd /usr/local/jdksudo chmod +x jdk-6u45-linux-x64.binsudo ./jdk-6u45-linux-x64.bin#安装成功后，配置环境变量sudo gedit /etc/profile #打开配置文件将下面4行加入到末尾并保存退出export JAVA_HOME=/usr/local/jdk/jdk1.6.0_45export JRE_HOME=/usr/local/jdk/jdk1.6.0_45/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH make降级 在ubuntu16.04上的make版本默认是4.1，但编译kk需要的版本为3.81或者3.82，所以需要下载安装make-3.82 123456tar -xjvf make-3.81.tar.bz2./configuremakesudo make install最后通过make -v查看，安装完成后需要重新登录。 ####编译源码 123source build/envsetup.shluanch aosp_arm64-engmake -j4 ###下载及编译kernel ####kernel下载 12345lisc@lisc-ubuntu:/home/aosp/android-4.4$ mkdir kernellisc@lisc-ubuntu:/home/aosp/android-4.4$ cd kernellisc@lisc-ubuntu:/home/aosp/android-4.4/kernel$ git clone https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.gitlisc@lisc-ubuntu:/home/aosp/android-4.4/kernel$ git branch -alisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ git checkout -b android-goldfish-3.4 remotes/origin/android-goldfish-3.4 ####编译环境的配置 123lisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ export ARCH=armlisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ export SUBARCH=armlisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ export CROSS_COMPILE=arm-eabi- 将交叉编译工具设置到PATH中 lisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ export PATH=$PATH:/home/aosp/android-4.4/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6/bin ####编译kernel 123456789101112lisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ make goldfish_armv7_defconfig HOSTCC scripts/basic/fixdep HOSTCC scripts/kconfig/conf.o SHIPPED scripts/kconfig/zconf.tab.c SHIPPED scripts/kconfig/zconf.lex.c SHIPPED scripts/kconfig/zconf.hash.c HOSTCC scripts/kconfig/zconf.tab.o HOSTLD scripts/kconfig/conf## configuration written to .config#lisc@lisc-ubuntu:/home/aosp/android-4.4/kernel/goldfish$ make]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-handlerthread-src%2F</url>
    <content type="text"><![CDATA[HandlerThread是Android系统提供的具有消息循环功能的Thread，这里消息循环理所当然也是基于Looper实现。 我们知道UI线程在启动后会通过Looper的prepareMainLooper方法来为UI线程初始化Looper，然后进入消息循环。而其他非UI线程如果也想具有消息机制，同样能通过Looper的prepare方法为其创建Looper，然后通过loop方法进入消息循环。 继承关系 123456public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; ……&#125; 构造方法 123456789public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT;&#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority;&#125; HandlerThread的构造方法只是设置线程名字和优先级，优先级默认为THREAD_PRIORITY_DEFAULT 消息循环 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 当thread启动后调用run方法，在这里我们通过Looper的prepare方法来为线程创建Looper对象，并保存在Looper的ThreadLocal对象中，在调用loop前可以通过onLooperPrepared方法来做一些准备工作。 使用实例 123456789101112131415161718HandlerThread handlerThread = new HandlerThread("myhandlerthread");handlerThread.start()//子线程HandlerHandler mHandler = new Handler(handlerThread.getLooper(),new MyCallback());Handler mUIHandler = new Handler();class MyCallback implements Handler.Callback &#123; @Override public boolean handleMessage(Message msg) &#123; //在子线程中进行消息的处理 //通知主线程去更新UI mUIHandler.sendMessage(msg1); return false; &#125;&#125; handlerThread启动后，就可以通过其Looper来构造Handler了，这里我们w为Handler提供了CallBack,这样就可以在这个回调中处理消息了，需要注意的是这个回调是在子线程中进行的，如果消息处理完成后需要更新ui仍需要一个UI Handler来进行。 12345678910111213141516public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; HandlerThread的getLooper方法会等待线程启动后才会真正返回。而没有启动会直接返回null触发异常。 退出消息循环 我们默认的在run方法中调用了Looper的prepare方法，这个方法默认会调用 Looper的如下方法 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这个方法的quitAllowed方法为true表示可以推出消息循环，而在UI线程中调用prepareMainLooper方法中默认提供给prepare的值为false表示不允许退出消息循环。 1234567891011121314151617public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125;public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false;&#125; 实际上退出消息循环也是通过looper来完成的，不过最终都是调用MessageQueue的mQueue.quit(true)方法来完成。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler消息机制详解(一)]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-handler-framework-src%2F</url>
    <content type="text"><![CDATA[Handler是android系统中最重要的构成部分，它是消息机制的基础，同时也是整个系统运作的动力源，本篇将通过源码来分析Handler的消息机制，以便了解Android底层是如何实现消息机制。 消息机制简述 消息机制是一种事件机制，消息循环通过消息作为载体可以告知应用系统或者应用发生了什么事，应用根据消息内容做出反应，即消息处理。典型的在win32系统中基于消息循环的消息机制如下，通过不断的在UI线程读取消息内容并处理的过程，就是应用执行的流程： 1234567while(GetMessage(&amp;msg, NULL, 0, 0))&#123; if(!TranslateAccelerator(msg.hWnd, hAccelTable, &amp;msg))&#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125;&#125; Android的消息机制类似于win32的消息机制，它内部通过Looper来进行消息的循环，同样的，它也有自己的消息队列，通过循环读取消息队列的消息维持应用的运行。 Handler、Looper与MessageQueue、Message 要理解Android的消息机制，需要理解Handler、Looper与 MessageQueue以及它们之间的关系。这里我们分别做说明： Handller handler负责消息的发送和处理，如果将消息流程看做一个链式处理流程，它就处于前端和末端。关于handler的用处，官方的说法是: There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 就是说handler主要有两方面的作用： 投递消息或者runnable在未来某个时间点上执行 可以添加一个可以被执行的动作在不同的线程中，也就是可以实现线程切换 Looper Looper即消息循环，类似于上面的while循环，它不断的从消息队列中取消息，并通过handler进行处理，它会和一个线程关联起来。 MessageQueue 即消息队列，它用来存储handler投递的消息。 Message 消息实体，我们发送的消息会被封装成Message对象然后添加到消息队列中 消息的投递 handler的构造 我们知道了消息是通过Handler来进行投递的，那我们看看handler的构造方法，handler有多个构造方法，这里看我们平时用的那个，其他的读者自己分析 123456789101112131415public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; …… mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在handler的构造中，最主要的是取到线程关联的Looper，因为消息循环是在线程中不断处理消息事件的，而线程只能有一个消息循环，多了就没必要了。所以消息循环和线程是绑在一起的。这里我们将线程的Looper保存在Handler的mLooper中，同时Looper和一个MessageQueue关联，这里将其消息队列保存在mQueue中，我们通过Handler发送的消息就是添加到该队列中的。 Looper的构造 这里为什么直接可以通过Looper.myLooper获取到Looper对象呢？Handler的创建可以分为UI线程和非UI线程两种，这里我们关注在UI线程的创建，非UI线程的在分析HandlerThread时我们再说，由于UI线程在创建时调用了Looper的prepareMainLooper方法创建了Loope对象，所以这里能通过myLooper取到这个创建的Looper对象。 12345678910111213141516171819202122232425public final class Looper &#123; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); private static Looper sMainLooper; // guarded by Looper.class final MessageQueue mQueue; final Thread mThread; public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; ……&#125; Looper创建的Looper对象被保存在一个ThreadLocal对象中， ThreadLocal即线程本地变量，这里它会为每个线程保存一个Looper对象和线程关联。 MessageQueue的构造 在创建Looper时，会去创建Looper关联的消息队列MessageQueue 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 这里的quitAllowed表示是否允许退出消息循环，在UI线程这个为false，表示不允许退出。 消息结构 12345678910111213public final class Message implements Parcelable &#123; public int what; public int arg1; public int arg2; public Object obj; public Messenger replyTo; public int sendingUid = -1; long when; Handler target; Runnable callback; Message next; ……&#125; 从Message的结构中可以看到它支持由what指定的message和Runnable ，消息的参数通过arg1和arg2或者obj附带。target指定了处理消息的Handler。 Handler的投递 接下来我们看看消息的投递方法 1234567891011121314151617181920212223242526272829303132333435public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;…… handler主要用来做消息的投递，它有众多的投递方法，大体上分为两类，一类通过sendxx来发送message，另一类通过post来发送runnable,不过最终都他们都会封装成Message对象然后通过sendMessageAtTime来将其添加到消息队列中。 123456789101112131415161718public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从函数sendMessageAtTime名字可以看出它将消息投递在未来某一个时间点上，当当前时间到达该时间点后触发该消息执行。这里添加消息是通过enqueueMessage来完成的。enqueueMessage中首先指定了消息的target为this，也就是当前Handler,然后通过MessageQueue的enqueueMessage添加消息到消息队列中。 MessageQueue消息的投递 通过MessageQueue的enqueueMessage将消息对象Message投递到其队列中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; enqueueMessage的逻辑很简单，分两个情况： 添加的Message作为队列的头，这个时候根据需要唤醒等待消息事件的线程 添加的Message不作为队列头，Message会插入到MessagQueue队列中，这个时候需要根据消息的when即消息的投递到的时间点来插入到具体位置，这也是大多数的情况。从这里也可以看出消息队列是以when进行排序的，靠前的时间点处于队列的前面相比靠后的要先被取出来。 消息循环 当消息队列有消息时，消息循环就需要不停的进行处理，这个工作是Looper的loop方法来做的。同样在在UI线程创建时需要调用这个方法启动消息循环 1234567891011121314151617181920212223242526public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; …… for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; …… &#125;&#125; 这里先判断Looper是否调用了prepare，前面我们知道prepare时才会创建Looper对象和消息队列，如果没有创建当然就不能启动消息循环，否则就可以拿到消息队列，进入for循环 不断的通过MessageQueue的next方法取出消息对象msg，然后通过msg的target即Handler调用dispatchMessage方法进行处理。这么看来Looper的逻辑是非常简单的。需要注意的是MessageQueue的next方法是可能阻塞的，因为当前队列可能还没message或者message指定的时间点还未到，这时线程就是阻塞的。接下来我们就看看next的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; MessageQueue的next方法会返回一个队列中一个Message实体，也可能返回null。next的处理也是通过一个for循环处理的，因为next是可能阻塞的，它是通过nativePollOnce来实现的，它有两个参数ptr和nextPollTimeoutMillis，ptr代表了native层的MessageQueue，而nextPollTimeoutMillis代表了阻塞的时长，有以下几种可能： nextPollTimeoutMillis = -1 ,一直阻塞不超时 nextPollTimeoutMillis = 0 ，不会阻塞，立即返回 nextPollTimeoutMillis &gt;0 ,最长阻塞nextPollTimeoutMillis毫秒，如果期间被唤醒后会立即返回。 循环之前nextPollTimeoutMillis为0 表示立即返回，然后通过队列中的头Message，来判断是否需要继续阻塞，满足now&lt;msg.when表示还未到触发的时间点。否则从队列中取出该msg并返回给loop，并置mBlocked = false表示没有阻塞。 在取消息前,我们看到如下代码： 1234567if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 这里的msg.target为null,它并不是一个普通的Message,而是一个Message屏障，这个屏障的作用就是使它之后的所有同步消息不会被执行。 我们看看这个屏障是如何添加的 1234567891011121314151617181920212223242526272829303132public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 那么为什么Android消息机制会允许这个屏障消息的存在？或者说它有哪些使用的场景？事实上屏障消息的存在说明有某些重要的消息将要执行而不能受其他同步消息的影响。在framework中我们发现了postSyncBarrier被用在了ViewRootImpl的scheduleTraversals中，这个方法被用来启动UI绘制流程，UI绘制的过程会通过UI线程的Handler发送来自SurfaceFlinger的Vsync信号，Vsync信号是用来同步UI界面更新绘制的。总之，这个地方了解即可。 消息的投递 消息的投递过程是在Looper中开始的，通过msg.target的dispatchMessage方法来进行，我们知道msg.target就是Handler. 12345678910111213public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; dispatchMessage的过程先判断msg是否设置有callback，如果设置了callback通过handleCallback进行处理，其实就是调用我们post的Runnable方法，否则通过handler的mCallback来处理，这个mCallback可以在构造方法中进行设置，它的原型如下： 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 如果未设置Handler的Callback ,那就通过handler的 handleMessage来处理，这个方法默认是个空实现。我们可以在创建Handler时复写这个方法。 消息的移除 123456789101112131415161718192021public final void removeMessages(int what) &#123; mQueue.removeMessages(this, what, null);&#125;public final void removeMessages(int what, Object object) &#123; mQueue.removeMessages(this, what, object);&#125;public final void removeCallbacks(Runnable r)&#123; mQueue.removeMessages(this, r, null);&#125; public final void removeCallbacks(Runnable r,Object token)&#123; mQueue.removeMessages(this, r, token);&#125;public final void removeCallbacksAndMessages(Object token) &#123; mQueue.removeCallbacksAndMessages(this, token);&#125; MessageQueue中移除message的实现如下 123456789101112131415161718192021222324252627282930313233void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); p = n; &#125; // Remove all messages after front. while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125;` 移除相应message或者runnable的逻辑都是相同的，removeCallbacksAndMessages类似，这里我们只看removeMessages的实现，满足移除必须满足的条件： 消息对象p不为null p.target即处理该消息的handler要匹配一致 p.what即指定的消息类型要匹配 p.obj为null或者和消息的obj匹配 其中第3个条件在移除runnable类的消息是为匹配p.callback，在同时移除message和runnable时不做匹配。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volley网络库源码分析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fandroid-libray-volley-src%2F</url>
    <content type="text"><![CDATA[综述 volley有三个层次的线程，分别为main thread、cache thread 以及network thrads。RequestQueue会维护一个缓存调度线程和一个网络调度线程，当一个Request被加入到队列中时，cache线程会对其进行筛选，如果这个请求的内容可以在缓存中找到，cache线程会亲自解析相应内容，并分发到UI线程。如果缓存中没有，这个请求就会被加入到NetWorkQueue中，所有真正准备进行网络通信的Request都在这里，第一个可用的net线程会从Queue中取出一个请求发送给服务器。当响应数据到的时候，这个net线程会解析原始响应数据并缓存，随后将解析的结果发送给主线程。 基本使用 首先在使用中，我们会在应用中创建一个请求队列 1mRequestQueue = Volley.newRequestQueue(this); newRequestQueue的实现如下： 123456789101112131415161718192021//volley.javapublic static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123;&#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue;&#125; 在创建请求队列中，我们还会创建一个BasicNetWork 这是volley使用的网络请求库，通过一个httpstack 对象来初始化，HttpStack是一个网络请求的接口。可以看到，在SDK版本小于9时默认使用的是HttpClient ，否则就用HttpUrlConnection当做其请求库。随后创建完queue后就启动该请求队列。在看start之前我们先看看RequestQueue类。 1234567891011121314151617181920212223242526272829303132333435363738394041public class RequestQueue &#123; /** Used for generating monotonically-increasing sequence numbers for requests. */ private AtomicInteger mSequenceGenerator = new AtomicInteger(); /** * Staging area for requests that already have a duplicate request in flight. * * &lt;ul&gt; * &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache * key.&lt;/li&gt; * &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request * is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt; * &lt;/ul&gt; */ private final Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&gt;&gt;(); /** * The set of all requests currently being processed by this RequestQueue. A Request * will be in this set if it is waiting in any queue or currently being processed by * any dispatcher. */ private final Set&lt;Request&gt; mCurrentRequests = new HashSet&lt;Request&gt;();//请求队列 /** The cache triage queue. */ private final PriorityBlockingQueue&lt;Request&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&gt;(); //缓存阻塞队列 /** The queue of requests that are actually going out to the network. */ private final PriorityBlockingQueue&lt;Request&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&gt;(); //网络请求阻塞队列 /** Number of network request dispatcher threads to start. */ private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4; //默认线程池大小 /** Cache interface for retrieving and storing respones. */ private final Cache mCache; //使用的缓存对象 /** Network interface for performing requests. */ private final Network mNetwork; //使用的网络请求对象 /** Response delivery mechanism. */ private final ResponseDelivery mDelivery;//转发器 /** The network dispatchers. */ private NetworkDispatcher[] mDispatchers; //网络调度线程 /** The cache dispatcher. */ private CacheDispatcher mCacheDispatcher; //缓存调度线程 ...&#125; RequestQueue包含了多个队列和调度器以及一个ResponseDelivery转发器，这里NetworkDispatcher和CacheDispatcher都是继承自Thread类。 构造方法 123456789101112public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123; mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery;&#125;public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 再来看start方法： 1234567891011121314 //RequestQueue.javapublic void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; 在start中，创建了缓存调度线程（一个）和网络调度线程（四个）,并启动它们。也就是说，在我们创建了请求队列后，就有5个线程在后台运行，不断等待网络请求的到来。我们创建好请求队列后，我们一般会add到该队列，所以看下add的源码 12345678910111213141516171819202122232425262728293031323334353637public Request add(Request request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this);//设置请求所属队列 synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request);//添加该请求 &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber());//得到该请求序列 request.addMarker("add-to-queue"); // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) &#123; //判断是否可缓存 mNetworkQueue.add(request);//不可缓存的话就直接添加到网络请求队列中 return request; &#125; // Insert request into stage if there's already a request with the same cache key in flight. synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey();//得到请求的key，实际上就是请求的url if (mWaitingRequests.containsKey(cacheKey)) &#123; //等待请求map表中已经存在该请求了 // There is already a request in flight. Queue up. Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);//获取该请求对应的等待队列 if (stagedRequests == null) &#123; stagedRequests = new LinkedList&lt;Request&gt;(); &#125; stagedRequests.add(request); //添加请求进来 mWaitingRequests.put(cacheKey, stagedRequests);//重置请求的map if (VolleyLog.DEBUG) &#123; VolleyLog.v("Request for cacheKey=%s is in flight, putting on hold.", cacheKey); &#125; &#125; else &#123; //请求目前还未添加进缓存队列 // Insert 'null' queue for this cacheKey, indicating there is now a request in // flight. mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); //添加到缓存队列 &#125; return request; &#125;&#125; 这里主要针对需要缓存的request说下，volley默认的request是需要缓存的，在需要缓存时，主要针对mWaitingRequests这个map表进行操作。这map表主要用来记录对应每个请求目前的请求队列，因为volley在网络出现问题后会对再次request进行重试，而重试的次数是可以设置的，重试一旦超过设置值就会超时。这里用mWaitingRequests就是来记录重试队列的。在应用层添加完request后，缓存调度线程就可以处理这个request了，所以看看CacheDispatcher的run方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//CacheDispatcher @Overridepublic void run() &#123; if (DEBUG) VolleyLog.v("start new dispatcher"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. mCache.initialize(); //缓存初始化 while (true) &#123; try &#123; // Get a request from the cache triage queue, blocking until // at least one is available. final Request request = mCacheQueue.take(); //取一个请求出来 request.addMarker("cache-queue-take"); // If the request has been canceled, don't bother dispatching it. if (request.isCanceled()) &#123; //如果被取消了就continue request.finish("cache-discard-canceled"); continue; &#125; // Attempt to retrieve this item from cache. Cache.Entry entry = mCache.get(request.getCacheKey()); //取该request对应的缓存 if (entry == null) &#123; request.addMarker("cache-miss"); // Cache miss; send off to the network dispatcher. mNetworkQueue.put(request); //没有缓存就直接添加到网络请求队列中，然后continue continue; &#125; // If it is completely expired, just send it to the network. if (entry.isExpired()) &#123; //缓存是否过期 request.addMarker("cache-hit-expired"); request.setCacheEntry(entry); mNetworkQueue.put(request); //如果过期，同样需要添加到网络请求队列中 continue; &#125; // We have a cache hit; parse its data for delivery back to the request. request.addMarker("cache-hit"); //这里就算缓冲命中了 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker("cache-hit-parsed"); if (!entry.refreshNeeded()) &#123; // Completely unexpired cache hit. Just deliver the response. mDelivery.postResponse(request, response); //通过转发器递交响应给Main Thread &#125; else &#123; //缓存命中了，但是需要刷新的情况 // Soft-expired cache hit. We can deliver the cached response, // but we need to also send the request to the network for // refreshing. request.addMarker("cache-hit-refresh-needed"); request.setCacheEntry(entry); // Mark the response as intermediate. response.intermediate = true; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. //先递交响应给main thread 随后在将该请求添加到网络请求队列以刷新缓存 mDelivery.postResponse(request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Not much we can do about this. &#125; &#125; &#125;); &#125; &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; &#125; &#125; 总体来说CacheDispatcher的处理流程很简单 ，主要的内容在注释我做了说明。在取到一个request后，需要该请求是否存在缓存，该缓存是否过期，是否需要刷新等问题。 接下来在看看NetworkDispatcher这个网络调度线程，它的任务就是从网络请求队列中取出request进行网络请求了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 @Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Request request; while (true) &#123; try &#123; // Take a request from the queue. request = mQueue.take(); //取出一个请求 &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker("network-queue-take"); // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; //如果被取消了continue request.finish("network-discard-cancelled"); continue; &#125; // Tag the request (if API &gt;= 14) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; TrafficStats.setThreadStatsTag(request.getTrafficStatsTag()); &#125; // Perform the network request. //通过网络请求库向服务器请求数据，响应保存在networkResponse中 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker("network-http-complete"); // If the server returned 304 AND we delivered a response already, // we're done -- don't deliver a second identical response. //响应请求的内容为被修改，服务器会返回304的响应码 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish("not-modified"); continue; &#125; // Parse the response here on the worker thread. //对相应进行解析，这里调用的parseNetworkResponse在request子类中实现 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker("network-parse-complete"); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; //需要缓存 mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker("network-cache-written"); &#125; // Post the response back. request.markDelivered(); mDelivery.postResponse(request, response); //转发器投递响应到主线程 &#125; catch (VolleyError volleyError) &#123; parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, "Unhandled exception %s", e.toString()); mDelivery.postError(request, new VolleyError(e)); &#125; &#125; &#125; 可以看到网络请求线程的处理更加简单，主要就是从网络请求队列中取出reqeust进行网络请求，并根据设置将响应保存在缓存中，最后转发响应到主线程中。 我们看到在缓存调度线程和网络调度线程中都使用到了ResponseDelivery对象将结果投递到主线程，这里我们看看这个Delivery 。事实上，ResponseDelivery只是一个接口，我们在创建RequestQueue时使用的ExecutorDelivery它实现了该接口。 1234public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 这里使用通过一个Handler来构造 123456789101112131415161718192021public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;;&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null);&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker("post-response"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; Dlivery的有两个重载的PostResponse，在缓存调度线程和网络调度线程都使用了两个参数的，三个参数的用在了缓存需要刷新时的情况，这时我们不仅要将结果投递给主线程而且要刷新缓存（其实只是将请求添加到了网络请求队列中），刷新缓存的操作就是通过第三个参数Runable实现的。 我们看看这个ResponseDeliveryRunnable 123456789101112131415161718192021222324252627282930313233343536private class ResponseDeliveryRunnable implements Runnable &#123; private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123; mRequest = request; mResponse = response; mRunnable = runnable; &#125; @SuppressWarnings("unchecked") @Override public void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish("canceled-at-delivery"); return; &#125; // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); //同样调用两个参数的将响应投递给主线程 &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we're done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker("intermediate-response"); &#125; else &#123; mRequest.finish("done"); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); //调用run方法 &#125; &#125;&#125; 下面我们看看Request类，这个请求类在我们的主线程中使用，是个抽象类，其子类需要实现 12abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);abstract protected void deliverResponse(T response); 分别用来解析响应和转发响应 在Request中，有个RetryPolicy成员通过DefaultRetryPolicy构造，这是个重试策略，主要在用在请求需要重新请求时，我们看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class DefaultRetryPolicy implements RetryPolicy &#123; /** The current timeout in milliseconds. */ private int mCurrentTimeoutMs; /** The current retry count. */ private int mCurrentRetryCount; //当前重试次数 /** The maximum number of attempts. */ private final int mMaxNumRetries; //最大重试次数 /** The backoff multiplier for for the policy. */ private final float mBackoffMultiplier; //备值因子 /** The default socket timeout in milliseconds */ public static final int DEFAULT_TIMEOUT_MS = 2500; /** The default number of retries */ public static final int DEFAULT_MAX_RETRIES = 1; /** The default backoff multiplier */ public static final float DEFAULT_BACKOFF_MULT = 1f; /** * Constructs a new retry policy using the default timeouts. */ public DefaultRetryPolicy() &#123; this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT); &#125; /** * Constructs a new retry policy. * @param initialTimeoutMs The initial timeout for the policy. * @param maxNumRetries The maximum number of retries. * @param backoffMultiplier Backoff multiplier for the policy. */ public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123; mCurrentTimeoutMs = initialTimeoutMs; mMaxNumRetries = maxNumRetries; mBackoffMultiplier = backoffMultiplier; &#125; .... /** * Prepares for the next retry by applying a backoff to the timeout. * @param error The error code of the last attempt. */ @Override public void retry(VolleyError error) throws VolleyError &#123; mCurrentRetryCount++; //重试次数加1 mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);//计算当前超时时间 if (!hasAttemptRemaining()) &#123; throw error; &#125; &#125; /** * Returns true if this policy has attempts remaining, false otherwise. */ protected boolean hasAttemptRemaining() &#123; return mCurrentRetryCount &lt;= mMaxNumRetries; &#125;&#125; 最后我们看看这个RetryPolicy的使用，它主要用在了网络请求类BasicNetWork中，主要看看接口方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = new HashMap&lt;String, String&gt;(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); addCacheHeaders(headers, request.getCacheEntry()); httpResponse = mHttpStack.performRequest(request, headers); //请求数据，获取响应 StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); //获取状态码 responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // Handle cache validation. if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, request.getCacheEntry().data, responseHeaders, true); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusLine); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false); &#125; catch (SocketTimeoutException e) &#123;//socket 超时 attemptRetryOnException("socket", request, new TimeoutError()); &#125; catch (ConnectTimeoutException e) &#123; //连接超时 attemptRetryOnException("connection", request, new TimeoutError()); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException("Bad URL " + request.getUrl(), e); &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; if (httpResponse != null) &#123; statusCode = httpResponse.getStatusLine().getStatusCode(); &#125; else &#123; throw new NoConnectionError(e); &#125; VolleyLog.e("Unexpected response code %d for %s", statusCode, request.getUrl()); if (responseContents != null) &#123; networkResponse = new NetworkResponse(statusCode, responseContents, responseHeaders, false); if (statusCode == HttpStatus.SC_UNAUTHORIZED || statusCode == HttpStatus.SC_FORBIDDEN) &#123;//未认证异常 attemptRetryOnException("auth", request, new AuthFailureError(networkResponse)); &#125; else &#123; // TODO: Only throw ServerError for 5xx status codes. throw new ServerError(networkResponse); &#125; &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; 我们看到performRequest是通过一个while循环来实现的，这是为了在发生请求出错是再次进行重试。在request超时、或者认证失败后都会调用attemptRetryOnException，这里就会进行重试。 12345678910111213private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request, VolleyError exception) throws VolleyError &#123; RetryPolicy retryPolicy = request.getRetryPolicy();//获取重试策略 int oldTimeout = request.getTimeoutMs(); //获取超时值 try &#123; retryPolicy.retry(exception);//重试 &#125; catch (VolleyError e) &#123; request.addMarker( String.format("%s-timeout-giveup [timeout=%s]", logPrefix, oldTimeout)); throw e; &#125; request.addMarker(String.format("%s-retry [timeout=%s]", logPrefix, oldTimeout));&#125; 注意这里退出重试循环是通过retry抛出VolleyError异常来结束的 volley的缓存策略 volley的缓存是通过服务端进行控制的，这样的方式比本地存储更加灵活，同服务端进行交互缓存能降低通信量，同时减轻本地缓存的压力。比如之前我们看到了服务端如何通过304的响应码通知内容未修改，这时就不需要再进行请求了。 volley的缓存类是在创建RequestQueue时指定的，这个缓存类以流的方式实现了Cach Entry的存取。所以我们看看这个Entry 12345678910111213141516171819202122public static class Entry &#123; /** The data returned from cache. */ public byte[] data; //缓存的字节流 /** ETag for cache coherency. */ public String etag; /** Date of this response as reported by the server. */ public long serverDate; /** TTL for this record. */ public long ttl; /** Soft TTL for this record. */ public long softTtl; /** Immutable response headers as received from server; must be non-null. */ public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); /** True if the entry is expired. */ public boolean isExpired() &#123; return this.ttl &lt; System.currentTimeMillis(); &#125; /** True if a refresh is needed from the original data source. */ public boolean refreshNeeded() &#123; return this.softTtl &lt; System.currentTimeMillis(); &#125;&#125; 需要说明的是，这个Entry对应我们一个请求的缓存条目，这个是在Request子类根据响应解析出来的。解析类为HttpHeaderParser，当然我们也可以根据需求自己定义类来解析响应得到想要的缓存。下面我们看看这个解析的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//HttpHeaderParser.javapublic static Cache.Entry parseCacheHeaders(NetworkResponse response) &#123; long now = System.currentTimeMillis(); Map&lt;String, String&gt; headers = response.headers; long serverDate = 0; long serverExpires = 0; long softExpire = 0; long maxAge = 0; boolean hasCacheControl = false; String serverEtag = null; String headerValue; headerValue = headers.get("Date"); //得到date if (headerValue != null) &#123; serverDate = parseDateAsEpoch(headerValue); &#125; headerValue = headers.get("Cache-Control"); //获取Cache-Control值，服务端需要设置这个值来标记缓存 if (headerValue != null) &#123; hasCacheControl = true; String[] tokens = headerValue.split(","); for (int i = 0; i &lt; tokens.length; i++) &#123; String token = tokens[i].trim(); if (token.equals("no-cache") || token.equals("no-store")) &#123; //对应的值no-cache、no-store return null; &#125; else if (token.startsWith("max-age=")) &#123; //对应的值为max-age,这个值标记了缓存的生存时间 try &#123; maxAge = Long.parseLong(token.substring(8)); &#125; catch (Exception e) &#123; &#125; &#125; else if (token.equals("must-revalidate") || token.equals("proxy-revalidate")) &#123; maxAge = 0; &#125; &#125; &#125; headerValue = headers.get("Expires"); //过期时间 if (headerValue != null) &#123; serverExpires = parseDateAsEpoch(headerValue); &#125; serverEtag = headers.get("ETag"); // Cache-Control takes precedence over an Expires header, even if both exist and Expires // is more restrictive. if (hasCacheControl) &#123; softExpire = now + maxAge * 1000;//计算过期时间 这里以毫秒为单位 &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123; // Default semantic for Expire header in HTTP specification is softExpire. softExpire = now + (serverExpires - serverDate);//通过过期日期来计算过期时间 &#125; Cache.Entry entry = new Cache.Entry(); entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; entry.ttl = entry.softTtl;//其实就是我们的过期时间 entry.serverDate = serverDate; entry.responseHeaders = headers; return entry; &#125; 我们在缓存调度线程中判断缓存条目失效的方法为 123public boolean isExpired() &#123; return this.ttl &lt; System.currentTimeMillis();&#125; 即当前ttl的值小于当前系统时间就算过期了。所以我们需要服务端设置头部Cache-Control的max-age或者expires来控制缓存的生命时间已达到本地缓存的目的。 总结 volley使用场景 数据量不大但通信频繁的场景 相关链接 Volley主页]]></content>
      <categories>
        <category>Android Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器ECS环境搭建及配置]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fnote-server-kuibu-deploy%2F</url>
    <content type="text"><![CDATA[关于跬步应用的服务器部署过程，程序通过python编写，部署在阿里ECS云服务器上。 系统基本信息 登陆 阿里云服务器 1234567891011121314Ubuntu 12.04 CPU 1核内存 512M 带宽1M所在可用区： 青岛可用区B 服务器登陆名：root 服务器登录密码：********** IP地址：115.28.200.10910.144.82.22 内 部署前的准备 安装Xshell 登陆服务器进行服务的部署 首先检查 python版本 123456789python –v 创建目录mkdir /home/kuibu/mkdir /kuibu/images/mkdir /kuibu/images/user_photos/mkdir /kuibu/images/topic/mkdir /kuibu/images/covermkdir /kuibu/images/thumbnail/mkdir /kuibu/log/ 安装WINSCP (或者其他FTP客户端)，服务端需安装配置vsftp(具体见附录一) 登陆用来上传文件，还可以用来查看文件结构 安装mysql 及mysqldb 123sduo Apt-get update sudo apt-get mysql-serversudo apt-get python-mysqldb 安装nginx 12sudo apt-get nginx sudo /etc/init.d/nginx start Nginx的配置文件是/etc/nginx/nginx.conf,具体的配置信息见后. 安装后在本地测试是否成功http://115.28.200.109/ Mysql 服务 客户端连接服务端的问题,安装完mysql 后，为客户端创建一个用户 123456Use mysql ; CREATE USER kuibu IDENTIFIED BY “123”123为远端的登录密码 Grant all privileges on *.* to ‘ kuibu’@’%’ WITH GRANT OPTIONkuibu 表示用户 % 表示远端的任意主机 如果主机IP知道了就不要这么设置了 搭建环境 下载virtualenv.py (这里使用已经下载好的，后面的可以略过) 1234567通过命令$sudo easy_install virtualenv 或者$sudo pip install virtualenv Unbuntu 下可以通过软件包管理Sudo apt-get install python-virtualenv 创建虚拟环境 12345cd 到 /home/kuibu/$ virtualenv flask 或者使用下载好的virtualenv.py 创建 python virtualenv.py flask ; 每次使用时首先激活虚拟环境$ source ./flask/bin/activate 3. 创建项目目录 mkdir /flask/apps/ 其中存放我们服务端项目的代码 4. 安装flask 完成上面的步骤，接下来就来安装flask等其附属的第三方模块： 12345678910$ flask/bin/pip install flask$ flask/bin/pip install flask-sqlalchemy$ flask/bin/pip install flask-httpauth$ flask/bin/pip install redis$ flask/bin/pip install MySQL-python #mysqldb $ flask/bin/pip install passlib$flask/bin/pip install flask-socketio$flask/bin/pip install PIL (具体看附录的PIL安装)nginx配置sudo apt-get nginx 这里需要&gt;1.4的稳定版 获取最新版nginx稳定版参见 http://www.kaijia.me/2013/05/ubuntu-latest-nginx-repo-collection/ 1sudo /etc/init.d/nginx start 配置文件 /etc/nginx/sites-avaliable/default, nginx的优化配置文件在/etc/nginx/nginx.conf 部署 基本架构 nginx + flask + gunicorn + gevent Nginx反向代理及配置 跬步使用到socketio， 部署要使用 gunicorn 作为web服务容器，所以首先要安装先切换到虚拟环境，然后pip install gunicorn 即可，详见http://gunicorn.org/ ，注意这里需要加上版本号 pip install gunicorn==18.0 gunicorn 作为web服务容器，前端使用nginx做反向代理，配置如下 1234567891011121314151617181920212223242526272829server &#123;listen 80;server_name localhost;location / &#123; proxy_pass http://127.0.0.1:5000; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;location /socket.io &#123; proxy_pass http://127.0.0.1:5000/socket.io; proxy_redirect off; proxy_buffering off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; &#125; location ~ ^/(images|javascript|js|css|flash|media|static|files)/&#123; root /home/kuibu/ ; expires 30d ; &#125;&#125; 重启nginx 配置gunicorn 在项目目录下编写配置文件gunicorn.conf 先切换到项目目录 cd apps ; 编写配置文件gunicorn.conf 12345678910workers = 4backlog = 2048bind = &apos;127.0.0.1:5000&apos;worker_class=&quot;socketio.sgunicorn.GeventSocketIOWorker&quot; #sync,gevent,meinheld,socketio.sgunicorn.GeventSocketIOWorkerproc_name=&apos;kuibu&apos;pidfile= &apos;/tmp/kuibu.pid&apos;logfile = &apos;/home/kuibu/log/debug.log&apos;debug=Truedaemon=Trueerrorlog=&apos;/home/kuibu/log/error.log&apos; 1..bin/gunicorn --config gunicorn.conf run:app 启动成功后，通过命令查看后台进程 1ps -ef | grep kuibu 参考链接 http://flask-socketio.readthedocs.org/en/latest/ http://www.open-open.com/lib/view/open1423107543014.html 使用 supervisor 管理gunicorn 进程 基本用法 1234##sudo安装 sudo apt-get install supervisor ##启动服务 sudo service supervisor start##终止服务 sudo service supervisor stop##也可以直接kill pid ps -A | grep supervisor 参考配置 配置示例 文件内容 1[program:dylan] 注意项目目录和gunicorn的配置文件地址 1234command=/home/bob/dylan/bin/gunicorn runserver:app -c /home/bob/dylan/gunicorn.conf directory=/home/bob/dylan user=root autostart=true autorestart=true log文件的位置 1stdout_logfile=/home/bob/logs/gunicorn_supervisor.log 重新读取配置 123456sudo supervisorctl reread##启动服务 sudo supervisorctl start kuibu##停止服务 sudo supervisorctl stop kuibu ##有问题就重启supervisor的总服务 sudo service supervisor stop sudo service supervisor start 通过浏览器管理supervisor 配置/etc/supervisor/supervisord.conf 添加以下内容 1234567891011[unix_http_server]file=/var/run//supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)chown=nobody:nogroupusername = eslipassword = 123 [inet_http_server]port = 127.0.0.1:9001username = eslipassword = 123 详见 http://supervisord.org/configuration.html#inet-http-server-section-settings 2. 在对应的nginx配置中添加 12345678910111213location /supervisor &#123; proxy_pass http://127.0.0.1:9001/; proxy_redirect off; proxy_buffering off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;;&#125; 这样我们就可以远程对其进行管理。 测试 安装ab测试工具 sudo apt-get install apache2-utils 简单测试 $time ab -n 200 -c 200 http://115.28.200.109/caddy/api/v1.0/test 实际测试 time ab -n 2000 -c 1000 -H keywords:dt -p /home/kuibu/param.conf -T ‘application/json; charset=utf8’ http://115.28.200.109/caddy/api/v1.0/get_collections 其中params.conf 的内容如下： data_type=HOME_LIST&amp;uid=9&amp;action=INIT&amp;threshold=-1 压力测试结果 在远程对web服务器进行压力测试，往往效果不理想（因为网络延时过大），建议使用内网的另一台或者多台服务器通过内网进行测试，这样得出的数据，准确度会高很多。如果只有单独的一台服务器，可以直接本地测试，比远程测试效果要准确。 关于ab的使用，参考 http://www.ha97.com/4617.html 附录一 安装其他模块 Ubuntu/Debian安装vsftp软件 更新软件源 首先需要更新系统的软件源，便捷工具下载地址：http://help.aliyun.com/manual?spm=0.0.0.0.zJ3dBU&amp;helpId=1692 安装vsftp 使用apt-get命令安装vsftp 1#apt-get install vsftpd –y 添加ftp帐号和目录 先检查一下nologin的位置，通常在/usr/sbin/nologin或者/sbin/nologin下。使用下面的命令创建帐户，该命令指定了/alidata/www/wwwroot为用户pwftp的家目录，您可以自己定义帐户名和目录: 1234567#useradd -d /alidata/www/wwwroot -s /sbin/nologin pwftp 修改该帐户密码:#passwd pwftp 修改指定目录的权限#chown -R pwftp.pwftp /alidata/www/wwwroot 配置vsftp 编辑vsftp配置文件，命令如下： 1#vi /etc/vsftpd.conf 将配置文件中”anonymous_enable=YES “改为 “anonymous_enable=NO” 取消如下配置前的注释符号： 12345local_enable=YESwrite_enable=YESchroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list 保存退出,编辑/etc/vsftpd.chroot_list文件，将ftp的帐户名添加进去，保存退出 修改shell配置 vi编辑/etc/shells，如果该文件里没有/usr/sbin/nologin或者/sbin/nologin（具体看当前系统配置）则追加进去 重启vsftp服务并测试登录,使用命令启动vsftp服务: 1#service vsftpd restart 然后用帐号pwftp测试下是否可以登陆ftp。目录是/alidata/www/wwwroot。 PIL安装 具体参见 http://jinvan.com/post/install-pil-on-ubuntu 安装依赖包 1sudo apt-get install libjpeg8-dev zlib1g-dev libfreetype6-dev 2. 创建链接，因为PIP安装软件包时，并没有安装在系统路径里，因此做一个软连接。 123ln -s /usr/lib/`uname -i`-linux-gnu/libfreetype.so /usr/lib/ln -s /usr/lib/`uname -i`-linux-gnu/libjpeg.so /usr/lib/ln -s /usr/lib/`uname -i`-linux-gnu/libz.so /usr/lib/ 准备工作做好了，安装PIL 12sudo pip install pil sudo pip install PIL --allow-external PIL --allow-unverified PIL 附录二 Error 汇总 安装Mysql-python 报错 Python.h: No such file or directory 需要 1$ sudo apt-get install python-dev 2. IOError: [Errno 26] Text file busy: ‘flask/bin/python’ Lsof 1unlink flask/bin/python greenlet.h:8:20: fatal error: Python.h: No such file or directory 1解决 sudo apt-get install python-dev 4. 安装MySQL-python EnvironmentError: mysql_config not found 1sudo apt-get install libmysqlclient-dev 5. 关于使用flask - socketio 123../bin/gunicorn -c gunicorn.conf run:app使用socketio.sgunicorn.GeventSocketIOWorker 代替了 gevent 报错AttributeError: &apos;socket&apos; object has no attribute &apos;cfg_addr&apos; 这是由于gunicorn 版本问题引起的，当前版本如果&gt;18.0 修会出现这个问题， 所以需要将当前版本回归到18.0及以下 https://github.com/miguelgrinberg/Flask-SocketIO/issues/93 附录三 Linux命令 杀死服务进程 ps -ef | grep kuibu kill -s 9 24578 查看目录权限 ll 查看内存使用 free –m top]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask原理剖析]]></title>
    <url>%2F%5Bobject%20Object%5D%2Faosp-asynctask-src%2F</url>
    <content type="text"><![CDATA[基本用法 AsyncTask是Android种常用的一种轻量级异步类，它的基本使用如下： 123456789101112131415161718192021222324class SomeTask extends AsyncTask&lt;Integer, Integer, String&gt;&#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); //任务执行前的回调 &#125; @Override protected String doInBackground(Integer... params) &#123; //这里我们做耗时的操作 &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; super.onProgressUpdate(progress); //处理任务进度 &#125; @Override protected void onPostExecute(String result) &#123; super.onPostExecute(result); //回调，这里可以进行UI的操作 &#125; &#125;SomeTask task = new SomeTask();task.execute(100); AsycTask种有四个基本的回调方法，它们分别是 onPreExecute 在任务执行前在UI线程回调 doInBackground 在后台线程种执行任务 onProgressUpdate 将任务的执行进度通过onProgreeUpdate通知给UI线程 onPostExecute 将任务执行的结果回调给UI线程 源码分析 为了清楚的了解AsyncTask内部的原理机制，本篇将会对其源码进行解析，在这之前我们先看看它的类结构定义 AsyncTask的类结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; private static final String LOG_TAG = "AsyncTask"; private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();//CPU数目 private static final int CORE_POOL_SIZE = CPU_COUNT + 1;//初始的线程个数=当前CPU数目+1 private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//最大的线程个数=CPU数目*2+1 private static final int KEEP_ALIVE = 1;//保活时间1s private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125; &#125;; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);//阻塞队列的大小为128 /** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); //根据上面的配置我们可以计算出 可以提交的总任务数目=128+CPU数目*2+1 /** * An &#123;@link Executor&#125; that executes tasks one at a time in serial * order. This serialization is global to a particular process. */ public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static final int MESSAGE_POST_RESULT = 0x1; private static final int MESSAGE_POST_PROGRESS = 0x2; private static final InternalHandler sHandler = new InternalHandler(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; private volatile Status mStatus = Status.PENDING;//任务的状态 private final AtomicBoolean mCancelled = new AtomicBoolean(); private final AtomicBoolean mTaskInvoked = new AtomicBoolean();&#125; AsyncTask是个抽象的泛型类，它有三个抽象的参数&lt;Params, Progress, Result&gt;，分别代表着后台任务附带的参数Params，执行任务的进度Progress以及执行执行的结果Result。它的类成员主要如下： THREAD_POOL_EXECUTOR 这是AsyncTask执行异步任务的线程池，线程池的基本大小为CPU_COUNT + 1，最大大小为CPU_COUNT * 2 + 1，并使用一个有界大小为128的LinkedBlockingQueue作为其工作队列，线程保活时间为1s。 sDefaultExecutor 它是一个SerialExecutor，这个是用来对提交的任务进行管理的的执行器，任务最终通过它提交给线程池，后面再详细介绍。 sHandler 它是一个InternalHandler，负责投递执行进度和最终结果给UI线程的Handler。 mWorker 这是一个WorkerRunnable类型的Callable，负责执行AsyncTask的后台任务。 mFuture FutureTask可以看作是mWorker的包裹，负责处理一些任务执行完的收尾工作，它是最终提交给SerialExecutor的任务。 mStatus AsyncTask当前的状态，默认是Status.PENDING状态表示等待任务中。 需要注意的是除了mStatus，以上所有的成员均为static final类型，也就是说这些成员是给AsyncTask类使用的。 了解了类成员再看看它的构造方法 1234567891011121314151617181920212223242526272829public AsyncTask() &#123; //mWorker就是我们要执行的后台任务，它是一个Callable mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true);//设置我们的回调被调用了 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams));//这里调用了我们的后台任务，并在执行完成后post到UI线程 &#125; &#125;; //通过我们的后台任务mWorker来创建一个FutureTask，当任务执行完成后调用done mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; //当我们的任务可能由于异常等原因没有得到调用后这时候依然需要调用postResult将结果投递到UI线程 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occured while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; AsyncTask只有这一个默认构造方法，在其内部会构造一个WorkerRunnable代表着我们的后台任务，WorkerRunnable仅仅是继承了Callable同时内部有一个Params数组代表着后台任务附带的参数，以及一个最终提交给任务调度器的FutureTask，它实际上可以看作是mWorker的包裹，内部保存了mWroker这个callable。 任务提交 AsyncTask一般通过execute方法来提交我们的异步任务，在提交时会传递参数Params给execute方法，我们看看它的实现 1234567891011121314151617181920212223242526public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING;//置任务的状态为RUNNINT onPreExecute();//回调任务执行前的回调 mWorker.mParams = params; exec.execute(mFuture);//执行mFuture的run方法 return this;&#125; 在execute方法中通过executeOnExecutor实现，在它内部首先检测当前mStatus的状态，如果已经执行或者完成那么抛出异常，这说明AsyncTask是只能够被执行一次的，否则置mStatus为Status.RUNNING表示正在执行状态。然后回调onPreExecute，这个是任务执行前的回调。随后将参数保存在mWorker中，然后通过将后台任务提交给sDefaultExecutor即任务调度器它是个SerialExecutor，我们看看它的实现。 任务调度器SerialExecutor 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();//任务队列 Runnable mActive;//当前执行的任务 public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext();//当一个任务执行完毕就接着执行下一个 &#125; &#125; &#125;);//任务提交后先添加到任务队列中 if (mActive == null) &#123;//如果没有任务执行 scheduleNext();//从任务队列中取出任务开始执行 &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; SerialExecutor内部实现很简单，它有一个ArrayDeque类型的任务队列mTasks，以及一个Runnable类型的mActive代表当前执行的任务。通过execute方法将mFuture包装后添加到mTasks中，然后判断mActivie是否为null，一开始肯定是null，这时候就通过scheduleNext从mTask队列中取出一个任务赋值给mActive然后交给线程池执行。线程池会执行下面的代码 1234567public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext();//当一个任务执行完毕就接着执行下一个 &#125;&#125; 这段代码将在线程中执行，这里的r实际就是我们提交的mFuture，这时候执行它的run方法，执行完成后调用scheduleNext方法开始下一个任务的执行。可见SerialExecutor是一个串行的任务调度器。它在一个任务执行完成后才开始调用下个任务执行。 任务的执行过程 在上面我们知道了SerialExecutor通过scheduleNext从任务队列中取出一个任务提交给线程池开始执行，而提交的任务内部最终会去执行FutureTask的run方法，而run方法中最终会执行它内部的callable，也就是mWorker，还记得么，我们在构造方法中创建的它，实现是这样的： 123456789mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true);//设置我们的回调被调用了 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams));//这里调用了我们的后台任务，并在执行完成后post到UI线程 &#125;&#125;; 在call回调中执行doInBackground方法执行后台任务，并将执行的结果通过postResult发送给UI线程，这里都是在线程池中的线程中执行的。 结果的投递 任务执行的结果是在线程中通过postResult方法投递给UI线程的，我们看看它的实现： 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 通过sHandler处理投递的MESSAG_POST_RESULT消息，投递的结果被封装在了AsyncTaskResult类型的对象中。我们看下这个类 12345678910@SuppressWarnings(&#123;"RawUseOfParameterizedType"&#125;)private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 在AsyncTaskResult内部保存了AsyncTask的实例mTask以及投递的结果mData。 接下来就是通过sHandler也就是InternalHandler来处理消息，我们看看InternalHandler的实现： 12345678910111213141516private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT://执行的结果通过InternalHandler来执行 // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 在InternalHandler内部只处理了两类消息，MESSAGE_POST_RESULT和MESSAGE_POST_PROGRESS，当我们在doBackground方法中执行后台任务时，可以通过publishProgress方法来通知UI线程我们当前任务的进度，在publishProgress方法中会通过InternalHandler来发送MESSAGE_POST_PROGRESS消息，InternalHandler接收到消息后通过onProgressUpdate回调告知UI层，而MESSAGE_POST_RESULT通过finish来处理。我们先看看finish方法的具体实现 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result);//调用任务完成的回调，这里已经在UI线程了 &#125; mStatus = Status.FINISHED;//标记任务已经完成了&#125; 在finish方法中首先判断任务是否被取消，如果已经取消回调onCancelled处理，否则执行onPostExecute回调将结果投递给UI线程，最后修改mStatus的状态为Status.FINISHED表示任务已经执行完成。 总结 从AsyncTask的实现来看，它本质上和Thread+Handler的方式类似，内部对于任务的处理默认是串行进行处理的(当然如果通过executeOnExecutor也是可以进行并行处理的)。AsyncTask最大的又是也许就是封装的几个线程回调使得在Android执行后台任务时使用起来更加方便整体来看是一个完整可控的过程。但由于AsyncTask的设计涉及到UI线程，所以太耗时的任务并不太适用于AsyncTask,况且在串行的情况下提交的任务可能要经过很长时间才能被处理完成。它内部的线程池决定了它适合同类型的任务，而对不同类型的任务处理第一可能会降低线程池的效率，第二可能会增加代码复杂性。另一个方面AsyncTask的使用不当会带来令人诟病的内存泄漏问题，因为AsyncTask和UI组件的生命周期并不同步，比如非静态的AsyncTask会持有Activity的引用，当屏幕旋转时AsyncTask可能会去更新一个已经销毁掉的Activity，这些都要求我们在使用AsyncTask时应该更加谨慎，一般是采用静态的AsyncTask结合弱引用的方式，并且在UI组件生命期结束的时候通过cancel及时的取消任务，同时在AsyncTask内部我们也可以根据取消状态来做相应的处理。]]></content>
      <categories>
        <category>AOSP</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池相关概念]]></title>
    <url>%2F%5Bobject%20Object%5D%2Fjdk-threadpool-src%2F</url>
    <content type="text"><![CDATA[线程池 关于参数的描述 123456789101112131415161718192021222324/** @param corePoolSize the number of threads to keep in the pool, even* if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set* @param maximumPoolSize the maximum number of threads to allow in the* pool* @param keepAliveTime when the number of threads is greater than* the core, this is the maximum time that excess idle threads* will wait for new tasks before terminating.* @param unit the time unit for the &#123;@code keepAliveTime&#125; argument* @param workQueue the queue to use for holding tasks before they are* executed. This queue will hold only the &#123;@code Runnable&#125;* tasks submitted by the &#123;@code execute&#125; method.* @param threadFactory the factory to use when the executor* creates a new thread* @param handler the handler to use when execution is blocked* because the thread bounds and queue capacities are reached*/public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize 线程的核心线程数，核心线程是会保持在线程池中，即使核心线程处于空闲状态，除非allowCoreThreadTimeOut被设置。 maximumPoolSize： 指的是线程池中允许的最大的线程数 keepAliveTime： 当线程数大于核心线程数时，多余的空闲线程等待任务的超时时间为keepAliveTime，超时后空闲线程将会被终止 unit： keepAliveTime的时间单位 workQueue：线程池的任务队列，这个队列是阻塞式队列，任务通过execute提交。 threadFactor： 用于创建线程池中线程的工厂类 handler：饱和策略 线程池任务处理过程 当通过execute提交新任务到线程池中，线程池会做如下操作： 如果线程池中正在运行的线程小于corePoolSize，则创建一个新的线程来执行任务。否则，执行步骤2 判断线程工作队列workQueue是否已经满，如果工作队列没有满，则将新提交的任务存储在工作队列中等待。否则执行步骤3 判断线程池中正在运行的线程数是否小于maximumPoolSize，如果小于，则创建线程运行这个任务，否则执行步骤4 这时候线程池的工作队列已满，正在运行的线程数已达到maximumPoolSize指定的值，该任务交给饱和策略处理。 当创建的线程处于空闲状态时，如果超过keepAliveTime的时间，线程池会判断当前运行的线程是否大于coorPoolSize,如果是，那么线程被终止掉。所有线程池的任务完成后，它最终会收缩到coorPoolSize的大小。 这个过程说明，并不是先加入任务就一定会先执行。假设队列大小为 4，corePoolSize为2，maximumPoolSize为6，那么当加入15个任务时，执行的顺序类似这样：首先执行任务 1、2，然后任务3~6被放入队列。这时候队列满了，任务7、8、9、10 会被马上执行，而任务 11~15 则会抛出异常。最终顺序是：1、2、7、8、9、10、3、4、5、6。当然这个过程是针对指定大小的ArrayBlockingQueue来说，如果是LinkedBlockingQueue，因为该队列无大小限制，所以不存在上述问题 常用线程池 Java通过Executors提供四种线程池，分别为： newCachedThreadPool() 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒处于等待任务到来）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池的最大值是Integer的最大值(2^31-1)。 newFixedThreadPool(nThreads) 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newSingleThreadExecutor 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newScheduledThreadPool(int corePoolSize) 1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS, new DelayedWorkQueue());&#125; 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
</search>
