{"meta":{"title":"esli's Blog","subtitle":"day day up","description":null,"author":"esli","url":"http://esligh.github.io"},"pages":[{"title":"分类","date":"2018-05-18T10:11:48.000Z","updated":"2018-05-18T10:13:07.340Z","comments":true,"path":"categories/index.html","permalink":"http://esligh.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-05-18T10:01:15.000Z","updated":"2018-05-18T14:56:05.422Z","comments":true,"path":"about/index.html","permalink":"http://esligh.github.io/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-05-18T12:48:57.191Z","updated":"2018-05-18T09:48:44.096Z","comments":true,"path":"links/index.html","permalink":"http://esligh.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-18T08:30:09.000Z","updated":"2018-05-18T14:38:42.924Z","comments":false,"path":"tags/index.html","permalink":"http://esligh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ActivityManagerService-Launcher 启动应用流程","slug":"aosp-startactivity-1","date":"2017-09-19T07:30:20.000Z","updated":"2018-05-19T09:03:09.246Z","comments":true,"path":"2017/09/19/aosp-startactivity-1/","link":"","permalink":"http://esligh.github.io/2017/09/19/aosp-startactivity-1/","excerpt":"","text":"综述 ActivityManagerService 即活动管理服务，它负责管理我们应用的activity，service等与系统交互的组件，为了方便起见，我们简称为AMS。我们知道Activity在启动过程中会经历一系列的生命周期，这些生命周期反应了AMS创建和管理Activity的整个过程，并且在这之间又同时需要和WindowManagerService进行交互操作，这就导致activity的启动是个异常复杂的工作。本篇不打算对整个流程的细节做过多的分析，只涉及activity启动过程的关键部分。 Activity启动方式-Launcher 首先activity的启动方式有多种可能的情况，比如最典型的就是点击Launcher上的图标启动，或者在应用内部打开activity进行跳转，还有通过adb 来启动activity，但无论是哪种启动方式，最基本的流程都是类似的。这里我们以Launcher启动作为描述的标准场景来简单了解下在activity启动过程中都会发生什么事情以使activity能够展现在我们眼前。 Launcher是一个标准的系统桌面应用，它用来管理系统中的所有已安装的app，这些app都是以网格化的形式在Launcher中显示的。我们点击一个app图标就会开始启动整个app并启动它的主activity。 Launcher启动是会给Intent添加flag Intent.FLAG_ACTIVITY_NEW_TASK,这表示我们会为这个应用创建一个新的任务栈。紧接就是启动指定的activity，正式开始startActivity的启动。 1234567891011121314151617181920packages/apps/Launcher2/src/com/android/launcher2/Launcher.javaboolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); if (useLaunchAnimation) &#123; ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); startActivity(intent, opts.toBundle()); &#125; else &#123; startActivity(intent);//调用activity的startActivity启动 &#125; return true; &#125; catch (SecurityException e) &#123;&#125; return false;&#125; 从Launcher启动的activity默认添加了FLAG_ACTIVITY_NEW_TASK，表示为应用创建新的任务栈。 这里我们从Launcher启动传递给startActivityForResult的requestCode为-1，说明我们不接受activity的返回值。 1234567891011Activity: startActivity-&gt;startActivityForResult1. [Activity.startActivityForResult]===&gt;[Instrumention.execStartActivity]public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123; …… Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this,intent, requestCode, options); ……&#125; execStartActivity 参数说明,对于Launcher启动： who: 为Launcher应用 mMainThread.getApplicationThread(): 为Launcher的ApplicationThread它是一个Binder target: 为this 代表Launcher这个Activity requestCode: -1 intent: 为要启动应用的Activity的意图 options: null 这里通过Instrumention来调用execStartActivity 1234567891011121314151617181920212.[Instrumention.execStartActivity]===&gt;[AMS.startActivity]public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; …… try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //通过AMS启动Activity 这个是通过binder调用完成 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); //检查启动的结果 这里如果Activity在manifest中未注册就会报错 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123;&#125; …… return null;&#125; 在Instrumention中会通过ActivityManagerNative获取到AMS的代理，到这里就开始通过Binder进行IPC调用了。我们这里继续看AMS中startActivity的实现，AMS时SystemServer进程中的众多服务之一，关于它启动的细节请参见SystemServer.java. 1234567891011[AMS.startActivity]===&gt;[AMS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivity(IApplicationThread caller, StringcallingPackage,Intent intent, String resolvedType, IBinder resultTo,String resultWho, int requestCode, int startFlags,String profileFile, ParcelFileDescriptor profileFd, Bundle options)&#123;//启动流程在AMS的入口 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());&#125; 这里我们对传递的参数做个说明： caller：代表Launcher的ApplicationThread 它是个Binder对象 callingPackage: 调用者即Launcher的包名 Intent: 要启动的activity的意图 resolvedType: Intent中指定的MIME类型 一般不指定的为null resultTo : token 代表着Launcher的activityRecord的- appToken，实际上就是代表着Launcher. resultWho : null requestCode:-1 startFlags : 0 profileFile:-1 profileFd:null Options:null 123456789101112131415161718[AMS.startActivityAsUser]===&gt;[ASS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,false, true, \"startActivity\", null); // TODO: Switch to user app stacks here. //mStackSupervisor是一个ActivityStackSupervisor ，从名字上看是对ActivityStack进行操作的 //这里callingUid为-1 profileFile为null profileFd为null return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, null, null, options, userId);&#125; AMS作为activity的管理者，它很懒，不做什么事情，几乎大部分Service都类似，他们不会真正的做事情，而是交给其他的&quot;代理&quot;对象去做事情。这里的&quot;代理&quot;对象就是ActivityStackSupervisor从名称上来看它负责监控和管理ActivityStack。 12345678910111213141516171819202122232425262728293031frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config, Bundle options, int userId) &#123; …… // Collect information about the target of the Intent. ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profileFile, profileFd, userId);//收集参数Intent的相关信息到aInfo中 synchronized (mService) &#123; int callingPid;//Launcher:默认传递进来的为-1 if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = Binder.getCallingPid(); callingUid = Binder.getCallingUid(); &#125; else &#123; callingPid = callingUid = -1;//Launcher:D &#125; ……… //继续调用startActivityLocked进行启动流程 int res = startActivityLocked(caller, intent, resolvedType, aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, startFlags, options, componentSpecified, null); ……&#125; startActivityMayWait方法中会从待启动的activity的intent中获取ActivityInfo，随后再去设置callingPid 和 callingUid为-1.在进一步调用startActivityLocked。 1234567891011121314151617181920212223242526272829303132333435frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options, boolean componentSpecified, ActivityRecord[] outActivity) &#123; ProcessRecord callerApp = null; if (caller != null) &#123;//校验调用者进程对于Launcher来说 即Launcher所在的应用进程 callerApp = mService.getRecordForAppLocked(caller);//查找调用者在AMS中的ProcessRecord信息 if (callerApp != null) &#123; callingPid = callerApp.pid;//调用者的进程id callingUid = callerApp.info.uid;//调用者的用户id &#125;…… &#125; /做一些权限检测工作 final int startAnyPerm = mService.checkPermission( START_ANY_ACTIVITY, callingPid, callingUid); final int componentPerm = mService.checkComponentPermission(aInfo.permission, callingPid, callingUid, aInfo.applicationInfo.uid, aInfo.exported); //为新的Activity创建ActivityRecord AMS中AcitivtyRecord用来描述Activity ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, this); //继续调用启动流程 //Launcher:sourceRecord保存着Launcher Activity的实体信息 需要注意的是这里doResume参数默认位true err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options); &#125; 这个方法主要做的事情包括： 1.初始化调用者的进程id和用户id,这是通过查找它的ProcessRecord来进行的。 2.做一些权限检查，比如调用者的权限和启动组件的权限等 3.为待启动的activity创建AtivityRecord，同时会创建appToken，用来代表这个ActivityRecord，间接代表要启动的activity. 4.进一步调用startActivityUncheckedLocked来进一步启动，这里的sourceRecord为Launcher的ActivityRecord。r就是我们要启动的activity的activityRecord 123456789101112131415161718192021222324252627282930313233343536373839404142final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; …… if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; if (r.resultTo == null) &#123; //Launcher:这里调用findTaskLocked找到是否存在r的实例，这里查找的结果应该是null，因为是从Launcher加载 ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); &#125; &#125; …… if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;//Launcher：true 需要一个新的task targetStack = adjustStackFocus(r); moveHomeStack(targetStack.isHomeStack()); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, true), null, true);//创建TaskRecord 并保存在r的task成员中 &#125; else &#123; r.setTask(reuseTask, reuseTask, true); &#125; newTask = true; …… &#125; …… mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,intent, r.getUriPermissionsLocked()); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); mService.setFocusedActivityLocked(r); &#125; 这一步会首先为要启动的activity找到一个task,然而由Launcher启动的时候activity的task还并未创建，这时候需要为其创建一个task并通过setTask设置到r中去。紧接着这里调用startActivityLocked进一步处理，同时将mLastPausedActivity置null,表示当前没有被暂停的activity。将mFocusedActivity设置为当前的activity，表示为焦点activity.对于Launcher启动这里newTask为true。 12345678910111213141516171819202122232425final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task;//ActivityRecord中存储的TaskRecord final int taskId = rTask.taskId; if (taskForIdLocked(taskId) == null || newTask) &#123; insertTaskAtTop(rTask); mWindowManager.moveTaskToTop(taskId); &#125; …… task.addActivityToTop(r);//将ActivityRecord放到task栈的顶部 task.setFrontOfTask();//将task栈设置为前台栈 r.putInHistory(); if (!isHomeStack() || numActivities() &gt; 0) &#123; …… &#125;else&#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0, r.userId,r.info.configChanges); &#125; if (doResume) &#123; mStackSupervisor.resumeTopActivitiesLocked();//又回到ActivityStackSupervisor &#125;&#125; 这一步首先将要启动的activity对应的ActivityRecord 即r放到其对应TaskRecord的顶部，然后将其Task设置为前台栈.随后为该Activity添加AppWindowToken，这个token时WMS用来标记AMS端的Activity对应的window的。最后调用resumeTopActivitiesLocked进一步处理栈顶activity. 12345678910111213141516171819202122boolean resumeTopActivitiesLocked() &#123; return resumeTopActivitiesLocked(null, null, null); &#125; boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = getFocusedStack(); &#125; boolean result = false; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (isFrontStack(stack)) &#123; if (stack == targetStack) &#123; result = stack.resumeTopActivityLocked(target, targetOptions); &#125; else &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result; &#125; 1234567891011121314151617181920212223242526272829303132333435final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; ActivityRecord next = topRunningActivityLocked(null); …… mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); …… //暂停当前执行的activity 为栈顶activity启动坐准备 boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving); if (mResumedActivity != null) &#123;//当前正在执行的activity pausing = true; startPausingLocked(userLeaving, false);//暂定activity &#125; …… if (prev != null) &#123; &#125;else&#123; if (mNoAnimActivities.contains(next)) &#123;//如果next不包含入场动画 anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); if (next.app != null &amp;&amp; next.app.thread != null) &#123; …… &#125;else&#123; …… mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125; 这组方法用来恢复启动task栈顶的activity，其中next即我们要执行的activity，它已经被放在了task栈顶，这里如果next已经在相关的休眠或者停止队列中需要将其从中移除，并重置sleeping状态，这些都是为next的启动做准备。这里最重要的一步就是需要将当前正在执行的mResumedActivity 暂停，这样才能执行task栈顶的activity .这是通过startSpercificActivityLocked来执行的。 12345678910111213 void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; …… &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); &#125; 这个方法用来启动我们具体的activity，首先获取activity对应的进程信息ProcessRecord，由于Launcher启动，activity的进程还未创建，所以这里需要为activity创建进程。 123456789private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… //为服务或者activity创建新的进程 通过zygote进程执行 创建完成后回调ActivityThread并执行其main方法 Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); ……&#125; 到这里会通过zygote为activity创建进程，这是通过和zygote进程通过socket通信来完成的，zygote为Activity创建进程后，会调用ActivityThread的main方法。 我们看看ActivityThread的main方法 12345678910111213141516public static void main(String[] args) &#123; …… Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 进程启动后需要创建要给ActivityThread对象，并调用其attach方法。在attach方法中会做许多初始工作。从main方法可以看到进程的主线程是作为ui线程的。 12345678910111213private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; …… IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;else&#123;……&#125;&#125; 在attach方法中会调用AMS的attachApplicaton，这里的mAppThread是我们的ApplicationThread对象，它是一个binder服务,在ActivityThread对象创建的时候生成，它在这里传递给AMS，这样AMS就可以使用其代理binder来和应用程序进行通信。比如activity众多的生命周期事件是通过这个binder对象通知应用端的。 123456789 @Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//进一步调用 Binder.restoreCallingIdentity(origId); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; app.makeActive(thread, mProcessStats); …… thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); …… if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app, mHeadless)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ……&#125; 这里AMS做一些初始化工作后 又会调用到应用端的bindApplication。应用端会在这个时机为应用创建Application对象，随后AMS分别调用mStackSupervisor和mServices的attachApplicationLocked，这里会将等待启动的acitivty或者service启动起来。后面我们继续分析 12345678910111213public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; …… sendMessage(H.BIND_APPLICATION, data); &#125; 这里会通过H对象 其实是个handler 来发送BIND_APPLICATION消息，这会调用handleBindApplication方法来处理该消息。 12345678private void handleBindApplication(AppBindData data) &#123; …… Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; …… mInstrumentation.callApplicationOnCreate(app); ……&#125; 在应用端的handleBindApplication时会为应用创建application对象，同时调用onCreate回调。 12345678910111213141516171819202122232425262728293031boolean attachApplicationLocked(ProcessRecord app, boolean headless) throws Exception &#123; boolean didSomething = false; final String processName = app.processName; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (headless) &#123; &#125; else if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception in new application when starting activity \" + hr.intent.getComponent().flattenToShortString(), e); throw e; &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething; &#125; AMS回调完成应用端的application初始化后，会进一步调用attachApplicationLocked来继续执行activity的任务。在这个方法中首先取到前台的ActivityStack，然后找到task栈顶的activity，最后通过realStartActivityLocked来真正的启动hr所代表的activity. 1234567891011121314151617181920frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; …… mWindowManager.setAppVisibility(r.appToken, true); …… r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); …… app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, app.repProcState, r.icicle, results, newIntents, !andResume, mService.isNextTransitionForward(), profileFile, profileFd, profileAutoStop); ……&#125; 到这一步，WMS会将app的设置为可见，这里是将r.appToken作为key的，这个appToken是我们在为activity创建ActivityRecord时创建的，它作为一个Binder用来在WMS端标记我们的activity,同时也可以和WMS通信。随后通知应用端开始加载Activity,App.thread就是我们的ApplicationThread，它是在进程创建后，应用端的binder server，主要被AMS使用和应用端的通信。 12345678910111213141516171819202122232425262728293031public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token;//token? 这个token实际上就是ActivityRecord的appToken 代表了待启动的Activity r.ident = ident; r.intent = intent; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profileFile = profileName; r.profileFd = profileFd; r.autoStopProfiler = autoStopProfiler; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在scheduleLaunchActivity中构造了一个 ActivityClientRecord对象，随后发送H_LAUNCH_ACTIVITY，然后调用handleLaunchActivity。 123456789101112private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //紧接着执行resume activity的流程 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); …… &#125; ……&#125; 到这里就开始加载activity，首先是调用performLaunchActivity，这里面会去调用onCreate和onStart等回调，而handleResumeActivity中会将activity显示出来，并调用onResume回调。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; …… java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建activi的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); …… if (activity != null) &#123; //为activity创建context 实际上为contextImpl Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //调用activity的attach进行初始化 activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //回调onCreate mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart();//onStart回调 r.stopped = false; &#125; …… &#125; r.paused = true; mActivities.put(r.token, r);&#125; 这个方法主要创建activity对象，并为其创建context，实际上为contextImpl，通过attach方法将context设置到activity中。同时为activity设置window，即PhoneWindow. 随后回调onCreate，onStart等方法。 123456789101112131415161718192021final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ActivityClientRecord r = performResumeActivity(token, clearHide); …… if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView();//取到decorView decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager();//取到WindowManager实际为WindowManagerImpl WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;//window类型 测量Z序会用到 l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l);//这里会添加window到WMS中 &#125; &#125; ……&#125; 到这里就真正的将activity相应的window添加到了WMS中，activity被显示在桌面上。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"Vsync信号图形绘制-Choreographer源码分析","slug":"aosp-choreographer","date":"2017-09-10T12:30:20.000Z","updated":"2018-05-19T10:14:31.597Z","comments":true,"path":"2017/09/10/aosp-choreographer/","link":"","permalink":"http://esligh.github.io/2017/09/10/aosp-choreographer/","excerpt":"","text":"Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。 Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vsync信号。垂直信号到来后就要开始准备绘制下一帧的数据。Choreographer主要是在ViewRootImpl中使用的，ViewRootImpl是view树的管理者，负责view树的逻辑处理及事件事件输入。 所有的绘制流程是从ViewRootImpl.java的scheduleTraversals开始的，这个方法会去请求vsync信号，并在信号到来时去绘制更新ui。 12345678910void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //请求vsync信号，当vsync信号到达后开始mTraversalRunnable任务,垂直信号的接受由ChoreoGrpaher负责 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); …… &#125;&#125; 这里我们不关心具体的绘制过程，主要是看Choreographer如何通过vysnc信号来协调界面的绘制。 这里首先是通过Choreographer对象mChoreographer对象post了一个回调，告诉Choreographer当vsync信号到达时帮我调用mTraversalRunable回调。这个回调的定义如下： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal();//vsync信号到达后执行绘制流程 &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); doTraversal()内部会调用performTraversals()方法，从而开启view绘制的三大流程。 下面我们看看Choreographer是如何将vsync接受信号并告之ViewRoomImpl的刷新回调的。我们就从这个postCallback入手分析。 12345678910111213141516171819202122232425262728public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; …… postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;//post一个延时回调private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //将请求的回调按照相应的类型添加到回调队列中，这里会根据一个失效时间来构造 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123;//延时为0时调用 ，对于scheduleTraversals走这里 scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; postCallback最终会调用postCallbackDelayedInternal，参数delayMillis为0，所以会调用scheduleFrameLocked进一步进行操作。这里需要注意的是每次请求都会添加到其类型对应的回调队列中， 这里的mCallbackQueues是一个根据类型区分的回调队列，有四种类型，分别是输入回调，动画回调和绘制回调以及Choreographer.CALLBACK_COMMIT。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123;//使用vsync信号更新 if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame on vsync.\"); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123;//通过ui线程发送请求等待一个vsync信号 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125;``` 这个USE_VSYNC代表我们系统使用vsync信号进行屏幕信号的同步，这个方法是在我们的ui线程操作的，所以会发送MSG_DO_SCHEDULE_VSYNC请求vsync信号。这里的mHandler是一个FrameHandler```javaprivate final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync();//请求vsync信号 break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 接着调用doScheduleVsync 1234567void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125; 123private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();//请求vsync信号&#125; 这里的mDisplayEventReceiver是一个FrameDisplayEventReceiver对象，它继承了DisplayEventReceiver，其中实现了其方法onVsync，这个方法就是当onVsync信号到达时的回调方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//垂直信号到达@Overridepublic void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won't send us vsyncs for secondary displays // but that could change in the future so let's log a message to help us remember // that we need to fix this. //并不是sf内置的display if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, \"Received vsync from secondary display, but we don't support \" + \"this case yet. Choreographer needs a way to explicitly request \" + \"vsync for a specific display to ensure it doesn't lose track \" + \"of its scheduled vsync.\"); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, \"Frame time is \" + ((timestampNanos - now) * 0.000001f) + \" ms in the future! Check that graphics HAL is generating vsync \" + \"timestamps using the correct timebase.\"); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, \"Already have a pending vsync event. There should only be \" + \"one at a time.\"); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125;@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);//垂直信号到来触发&#125;&#125; 垂直信号vsync到来后会触发doFrame，在这个方法里面会进行我们的回调，即mTraversalRunnable。 12345678910111213141516171819202122void doFrame(long frameTimeNanos, int frame) &#123; …… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);//回调输入事件的相关回调 mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);//回调动画相关的回调 mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);//回调绘制相关的回调 doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ……&#125; 123456789101112131415161718192021222324void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS);//获取相关类型的回调 if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true;…… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"RunCallback: type=\" + callbackType + \", action=\" + c.action + \", token=\" + c.token + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos);//调用回调 &#125; &#125; ……&#125; 这里会根据类型从队列中取出相应的回调进行调用。这个就是上层对于vsync的处理。接下来我们看看底层的vsync信号是如何传递给Choreographer的。这就需要看看FrameDisplayEventReceiver的父类DisplayEventReceiver，这个DisplayEventReceiver会通过native层进行初始化，native层通过它的成员方法dispatchVsync将vsync信号报告给上层，即调用onVsync。我们先看其构造方法: 1234567891011public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException(\"looper must not be null\"); &#125; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource);//初始化接收器 mCloseGuard.open(\"dispose\");&#125; 其构造方法是调用nativeInit进行初始化的，并将当前对象this作为一个接收器传递给底层。我们看看这个方法 123456789101112131415161718192021222324frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp//注册显示事件接收器 receiverWeak即DisplayEventReceiverstatic jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj, jint vsyncSource) &#123; //这个messageQueue是通过ui线程的Looper构造的 sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, \"MessageQueue is not initialized.\"); return 0; &#125; sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue, vsyncSource);//创建本地接收器 status_t status = receiver-&gt;initialize();//初始化native的接受器 if (status) &#123; String8 message; message.appendFormat(\"Failed to initialize display event receiver. status=%d\", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 在初始化方法中会创建本地的接受器对象，它同时是用我们传递的java层的接受器对象构造的，构造完成后即进行初始化。这个NativeDisplayEventReceiver的定义如下 12345678910111213141516171819//native的显示事件接受器class NativeDisplayEventReceiver : public DisplayEventDispatcher &#123;public: NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource); void dispose();protected: virtual ~NativeDisplayEventReceiver();private: jobject mReceiverWeakGlobal;//java层的接收器对象 sp&lt;MessageQueue&gt; mMessageQueue; DisplayEventReceiver mReceiver; virtual void dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count); virtual void dispatchHotplug(nsecs_t timestamp, int32_t id, bool connected);&#125;; NativeDisplayEventReceiver继承自DisplayEventDispatcher，而DisplayEventDispatcher又实现了LooperCallback的接口handleEvent，这个方法是Looper的事件回调，也就是当Looper接受到消息后会对其进行调用，那么这个DisplayEventDispatcher就是负责进行消息事件的转发的。后面我们看看它是如何将vsync信号转发的。 12345678910111213141516//初始化receiverstatus_t DisplayEventDispatcher::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(\"Failed to initialize display event receiver, status=%d\", result); return result; &#125; int rc = mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL);//添加事件侦听,这里的this代表注册的是一个LooperCallback, //当事件到达后会调用其handleEvent方法,这个可以具体参见Looper的实现 if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 这里的addFd将其注册到为Looper的事件回调，注意这里第四个参数this，因为DisplayEventDispatcher是继承LooperCallback的。这样当事件到来后会调用handleEvent。 还有，在NativeDisplayEventReceiver的内部持有一个DisplayEventReceiver对象，这个对象比较重要，它是负责和Sf打交道的。 1234567891011DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != NULL) &#123; //通过sf建立连接，这里就应该很熟悉了，这个连接创建好后在第一次引用时会去注册到EventThread中 mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource); if (mEventConnection != NULL) &#123; mDataChannel = std::make_unique&lt;gui::BitTube&gt;(); mEventConnection-&gt;stealReceiveChannel(mDataChannel.get()); &#125; &#125;&#125; 12345678sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection( ISurfaceComposer::VsyncSource vsyncSource) &#123; if (vsyncSource == eVsyncSourceSurfaceFlinger) &#123; return mSFEventThread-&gt;createEventConnection(); &#125; else &#123;//如果时app端的就走这里 return mEventThread-&gt;createEventConnection(); &#125;&#125; 刚刚说到DisplayEventReceiver是和Sf打交道的， 它和NativeDisplayEventReceiver是同时创建的。在其构造方法中首先通过sf的createDisplayEventConnection创建一个连接对象即Connection对象，mEventThread是管理绘图延时对象的vsync信号处理，它是一个EventThread。Connection就是由它创建的。 123sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));//创建一个新的连接，这个连接在第一个被引用时会去进行注册&#125; 这个connection在第一次被引用时会进行注册，即将其添加到mEventThread的连接队列，在vsync消息到来时调用其postEvent方法对事件进行转发。 1234567891011121314151617181920212223242526272829303132333435void EventThread::Connection::onFirstRef() &#123; // NOTE: mEventThread doesn't hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125;//注册创建的连接，实际上时将创建的连接添加到监听队列，并通知等待的线程status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; Mutex::Autolock _l(mLock); mDisplayEventConnections.add(connection);//添加到连接队列中 mCondition.broadcast();//唤醒等待的线程 return NO_ERROR;&#125;bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event);//post事件 …… &#125; return true;&#125;status_t EventThread::Connection::postEvent( const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; postEvent实际上会调用DisplayEventReceiver的setEvents方法，这样会触发getEvents的回调从而通过DisplayEventDispatcher的handleEvent回调方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel, Event const* events, size_t count)&#123; return gui::BitTube::sendObjects(dataChannel, events, count);//发送接受到的事件&#125;int DisplayEventDispatcher::handleEvent(int, int events, void*)&#123; …… // Drain all pending events, keep the last vsync. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;//丢弃所有的等待事件，只保留上次的vsync信号事件 ALOGV(\"dispatcher %p ~ Vsync pulse: timestamp=%\" PRId64 \", id=%d, count=%d\", this, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount); mWaitingForVsync = false; dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);//分派vsync信号 &#125; return 1; // keep the callback&#125;bool DisplayEventDispatcher::processPendingEvents( nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123;//等待事件到来 ALOGV(\"dispatcher %p ~ Read %d events.\", this, int(n)); for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // Later vsync events will just overwrite the info from earlier // ones. That's fine, we only care about the most recent. gotVsync = true; *outTimestamp = ev.header.timestamp;//timestamp *outId = ev.header.id;//id *outCount = ev.vsync.count;//count break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; &#125; &#125; return gotVsync;&#125;&#125;void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal)); if (receiverObj.get()) &#123; ALOGV(\"receiver %p ~ Invoking vsync handler.\", this); env-&gt;CallVoidMethod(receiverObj.get(), gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); ALOGV(\"receiver %p ~ Returned from vsync handler.\", this); &#125; mMessageQueue-&gt;raiseAndClearException(env, \"dispatchVsync\");&#125; 最终调用NativeDisplayEventReceiver的dispatchVsync回调给java层的dispatchVsync，这样vsync信号就传递给上层应用了。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]}]}