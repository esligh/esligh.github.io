{"meta":{"title":"esli's Blog","subtitle":"day day up","description":null,"author":"esli","url":"http://esligh.github.io"},"pages":[{"title":"关于","date":"2018-05-18T10:01:15.000Z","updated":"2018-05-18T14:56:05.422Z","comments":true,"path":"about/index.html","permalink":"http://esligh.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-18T08:30:09.000Z","updated":"2018-05-18T14:38:42.924Z","comments":false,"path":"tags/index.html","permalink":"http://esligh.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-18T10:11:48.000Z","updated":"2018-05-18T10:13:07.340Z","comments":true,"path":"categories/index.html","permalink":"http://esligh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-05-18T12:48:57.191Z","updated":"2018-05-18T09:48:44.096Z","comments":true,"path":"links/index.html","permalink":"http://esligh.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"InputMangerService之Input事件分发流程","slug":"aosp-inputmanager-input-dispatch-src","date":"2017-09-29T11:45:56.000Z","updated":"2018-05-19T15:01:55.702Z","comments":true,"path":"2017/09/29/aosp-inputmanager-input-dispatch-src/","link":"","permalink":"http://esligh.github.io/2017/09/29/aosp-inputmanager-input-dispatch-src/","excerpt":"","text":"InputManagerService负责Android输入设备的事件管理，输入事件是Android应用程序最重要的组成部分，因此我们有必要对整个事件的流程进行分析。我们知道输入事件如触摸事件的分发流程是从view树的根部开始向下传递的，但本篇不对此进行分析，而是从事件发生的源头到该步所做的工作进行梳理。那么既然IMS最终要将事件投递到view树中，即DecorView对象上，那么可以想到IMS必然和WMS有不可分割的关系，其实，也可以想到，输入事件要被应用进行处理，必然投递到某一个前台窗口，后面我们会看到他们之间的紧密关系。 事件输入的流程启动 我们知道SystemServer在启动的时候会启动众多的系统服务，这些服务中就包括了WMS和IMS。下面我们看看他们分别是如何启动的。 frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112131415161718192021222324252627public void initAndLoop()&#123; …… // Create a handler thread just for the window manager to enjoy. HandlerThread wmHandlerThread = new HandlerThread(\"WindowManager\"); wmHandlerThread.start(); //为WMS单独创建的HandlerThread Handler wmHandler = new Handler(wmHandlerThread.getLooper()); …… //创建输入管理服务 inputManager = new InputManagerService(context, wmHandler); Slog.i(TAG, \"Window Manager\"); wm = WindowManagerService.main(context, power, display, inputManager, wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore);//创建WMS 同时这里将输入管理服务和其关联在一起 ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); …… //为输入管理服务设置回调 这个回调来自WMS inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start();//启动输入管理的流程 ……&#125; SystemServer进程在启动时会调用其Main方法进行一些初始化工作，initAndLoop就是在整个时候进行的，它会注册多个系统服务到Sm中去，这里我们关注WMS和IMS即可。 首先创建IMS的实例，并将其作为参数传递给WMS，随后将这两个服务的实例都加入到SM中 这里我们先看IMS的实例创建过程，它需要一个context和一个Handler作为参数来构造。这个Handler时为WMS创建的，这里传给IMS，说明他们之间共享这个Handler. SystemServer中通过该构造方法创建IMS 注意这个handler是供WMS使用的，它里传过来说明它想和WMS共享handler frameworks/base/services/java/com/android/server/input/InputManagerService.java 123456789public InputManagerService(Context context, Handler handler) &#123; this.mContext = context; this.mHandler = new InputManagerHandler(handler.getLooper()); mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack); mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); //创建native层的InputManager对象，结果保存在mPtr&#125; IMS的构造很简单，它实际上调用natvieInit来创建native层的InputManger对象，对应于java层的IMS，结果返回给mPtr，注意这里的第三个参数为handler的MessageQueue. frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 1234567891011121314//创建Native层的InputManager对象static jint nativeInit(JNIEnv* env, jclass clazz, jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, \"MessageQueue is not initialized.\"); return 0; &#125; NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper());//直接看NativeInputManager的实现 im-&gt;incStrong(0); return reinterpret_cast&lt;jint&gt;(im);&#125; 首先我们得到java层传进来的MessageQueue对象，然后通过它构造一个NativeInputManager对象，并返回给上层。我们接着看其构造 frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 12345678910111213141516171819//Native层的InputManger构造方法NativeInputManager::NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : mLooper(looper) &#123; JNIEnv* env = jniEnv(); mContextObj = env-&gt;NewGlobalRef(contextObj); mServiceObj = env-&gt;NewGlobalRef(serviceObj); &#123; AutoMutex _l(mLock); mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE; mLocked.pointerSpeed = 0; mLocked.pointerGesturesEnabled = true; mLocked.showTouches = false; &#125; sp&lt;EventHub&gt; eventHub = new EventHub(); mInputManager = new InputManager(eventHub, this, this);&#125; 这里我们主要创建两个对象，一个EventHub对象，它是用来监听输入事件，也就是输入设备产生的Input事件。另一个对象为InputManager，它以eventHub对象作为其参数构造，这个InputMangager才是真正c++层的IMS服务，NativeInputManager只能算是一个壳，它持有InputMangaer的引用罢了，真正的事情应该是在InputManager中进行的。 frameworks/base/services/input/InputManager.cpp 1234567891011121314151617//c++层真正的IMS服务类InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; //创建分派对象，用来分派Input事件 例如KeyEvent，MotionEvent mDispatcher = new InputDispatcher(dispatcherPolicy); //创建事件reader，这个是InputManger中的Input事件源，实际上它是通过eventHub得到事件的。 //同时，它和mDispatcher关联是因为需要将事件交给它来分派 mReader = new InputReader(eventHub, readerPolicy, mDispatcher); initialize();//初始化&#125;void InputManager::initialize() &#123; mReaderThread = new InputReaderThread(mReader); mDispatcherThread = new InputDispatcherThread(mDispatcher);&#125; InputManager的构造方法做了三件事： 创建InputDispatcher对象，这个对象使用来分派Input事件的 创建InputReader对象，它的主要任务从EventHub读取事件并交给InputDispatcher处理，所里在其构造中我们可以看到eventHub和mDispatcher 初始化InputManger，分别为InputReader和InputDispatcher创建线程，InputManager的主要工作就是在这两个线程中完成的。 到这里InputManager就创建完成了，但它并没有开始工作，因为线程还未跑起来，其实在我们之前SystemServer可以看到，IMS在创建好实例后还需要关联上WMS，然后设置一个Window回调后才调用start启动工作。这个start流程会调用nativeStart进行native层的InputManager来启动真正的工作。 12345678910111213141516status_t InputManager::start() &#123; status_t result = mDispatcherThread-&gt;run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY); if (result) &#123; ALOGE(\"Could not start InputDispatcher thread due to error %d.\", result); return result; &#125; result = mReaderThread-&gt;run(\"InputReader\", PRIORITY_URGENT_DISPLAY); if (result) &#123; ALOGE(\"Could not start InputReader thread due to error %d.\", result); mDispatcherThread-&gt;requestExit(); return result; &#125; return OK;&#125; 在InputManager的start中我们会启动初始化中创建的两个线程，分别用来处理读取Input事件和分派Input事件。接下来我们就从这两个线程的工作入手分析Input事件从下到上的整个流程。 输入事件在IMS中的分派 我们先看Reader线程的工作，它就是不断的通过mReader的loopOnce读取事件。所以具体的工作还是InputReader进行的，我们接下来就看InputReader的实现。 frameworks/base/services/input/InputReader.cpp 1234bool InputReaderThread::threadLoop() &#123; mReader-&gt;loopOnce(); return true;&#125; frameworks/base/services/input/InputReader.cpp 12345678910111213141516InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, const sp&lt;InputListenerInterface&gt;&amp; listener) : mContext(this), mEventHub(eventHub), mPolicy(policy), mGlobalMetaState(0), mGeneration(1), mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX), mConfigurationChangesToRefresh(0) &#123; mQueuedListener = new QueuedInputListener(listener); &#123; // acquire lock AutoMutex _l(mLock); refreshConfigurationLocked(0); updateGlobalMetaStateLocked(); &#125; // release lock&#125; 在InputReader的构造中我们传递了EventHub作为事件传递的源，还有InputDispatcher作为事件的分派者的listener，其中通过该listener构造了QueueInputListener对象，这个对象的用途后面我们再介绍。 frameworks/base/services/input/InputReader.cpp 123456789101112131415161718192021222324252627void InputReader::loopOnce() &#123; int32_t oldGeneration; int32_t timeoutMillis; bool inputDevicesChanged = false; Vector&lt;InputDeviceInfo&gt; inputDevices; …… size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock AutoMutex _l(mLock); mReaderIsAliveCondition.broadcast(); if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; &#125; …… // Flush queued events out to the listener. // This must happen outside of the lock because the listener could potentially call // back into the InputReader's methods, such as getScanCodeState, or become blocked // on another thread similarly waiting to acquire the InputReader lock thereby // resulting in a deadlock. This situation is actually quite plausible because the // listener is actually the input dispatcher, which calls into the window manager, // which occasionally calls into the input reader. mQueuedListener-&gt;flush();&#125; InputReader的线程的主要工作就是调用loopOnce，在这个方法中会通过我们在构造方法中传递的mEventHub对象来获取Input事件，结果保存在mEventBuffer,并返回count代表我们读取的事件数目，接着通过processEventsLocked进行处理，实际上这里会将读取的事件保存在一个缓冲队列中，最后调用mQueueListener的flush将事件发送出去。下面我们接着看着个流程。 frameworks/base/services/input/InputReader.cpp 12345678910111213141516171819202122232425262728293031323334353637void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; int32_t deviceId = rawEvent-&gt;deviceId; while (batchSize &lt; count) &#123; if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT || rawEvent[batchSize].deviceId != deviceId) &#123; break; &#125; batchSize += 1; &#125;#if DEBUG_RAW_EVENTS ALOGD(\"BatchSize: %d Count: %d\", batchSize, count);#endif processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; else &#123; switch (rawEvent-&gt;type) &#123; case EventHubInterface::DEVICE_ADDED: addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::DEVICE_REMOVED: removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::FINISHED_DEVICE_SCAN: handleConfigurationChangedLocked(rawEvent-&gt;when); break; default: ALOG_ASSERT(false); // can't happen break; &#125; &#125; count -= batchSize; rawEvent += batchSize; &#125;&#125; 我们看到事件消息一开始是作为一个RawEvent对象来根据其类型分别进行处理的，最基本的设备添加移除都通过专门的方法处理，其他事件都通过processEventsForDeviceLocked进行处理。至于addDeviceLocked，它是在添加输入设备时调用，用来添加输入设备的，在里面会对设备创建相应的InputDevice对象，同时创建会创建一些InputMapper，比如KeyboardInputMapper，TouchInputMapper等，这些InputMapper都保存在mMappers的列表中，后面我们会看到输入事件会交给这些mapper来进行处理。 12345678910111213141516void InputReader::processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count) &#123; ssize_t deviceIndex = mDevices.indexOfKey(deviceId); if (deviceIndex &lt; 0) &#123; ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId); return; &#125; InputDevice* device = mDevices.valueAt(deviceIndex); if (device-&gt;isIgnored()) &#123; //ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId); return; &#125; device-&gt;process(rawEvents, count);&#125; 这一步我们通过mDevices取到对应的InputDevice,然后调用process进一步处理输入事件。 frameworks/base/services/input/InputReader.cpp 1234567891011void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123; if()&#123; …… &#125; else &#123; for (size_t i = 0; i &lt; numMappers; i++) &#123; InputMapper* mapper = mMappers[i]; mapper-&gt;process(rawEvent); &#125; &#125;&#125; 到这一步，input事件就交给Device，这里我们看看KeyboardInputMapper对键盘输入事件的处理。 frameworks/base/services/input/InputReader.cpp 123456789101112131415161718192021void KeyboardInputMapper::process(const RawEvent* rawEvent) &#123; switch (rawEvent-&gt;type) &#123; case EV_KEY: &#123; int32_t scanCode = rawEvent-&gt;code; int32_t usageCode = mCurrentHidUsage; mCurrentHidUsage = 0; if (isKeyboardOrGamepadKey(scanCode)) &#123; int32_t keyCode; uint32_t flags; if (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123; keyCode = AKEYCODE_UNKNOWN; flags = 0; &#125; processKey(rawEvent-&gt;when, rawEvent-&gt;value != 0, keyCode, scanCode, flags); &#125; break; &#125; …… &#125;&#125; 在process进一步调用processKey，表示处理按键事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode, int32_t scanCode, uint32_t policyFlags) &#123; if (down) &#123; // Rotate key codes according to orientation if needed. if (mParameters.orientationAware &amp;&amp; mParameters.hasAssociatedDisplay) &#123; keyCode = rotateKeyCode(keyCode, mOrientation); &#125; // Add key down. ssize_t keyDownIndex = findKeyDown(scanCode); if (keyDownIndex &gt;= 0) &#123; // key repeat, be sure to use same keycode as before in case of rotation keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode; &#125; else &#123; // key down if ((policyFlags &amp; POLICY_FLAG_VIRTUAL) &amp;&amp; mContext-&gt;shouldDropVirtualKey(when, getDevice(), keyCode, scanCode)) &#123; return; &#125; mKeyDowns.push(); KeyDown&amp; keyDown = mKeyDowns.editTop(); keyDown.keyCode = keyCode; keyDown.scanCode = scanCode; &#125; mDownTime = when; &#125; else &#123; // Remove key down. ssize_t keyDownIndex = findKeyDown(scanCode); if (keyDownIndex &gt;= 0) &#123; // key up, be sure to use same keycode as before in case of rotation keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode; mKeyDowns.removeAt(size_t(keyDownIndex)); &#125; else &#123; // key was not actually down ALOGI(\"Dropping key up from device %s because the key was not down. \" \"keyCode=%d, scanCode=%d\", getDeviceName().string(), keyCode, scanCode); return; &#125; &#125; …… NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime); getListener()-&gt;notifyKey(&amp;args);&#125; 这里首先对按键进行适当的处理，比如按键按下时，需要根据屏幕方向对按键的code进行旋转，这么做的原因可能是因为不同屏幕方向的key code表示的意义是不同的。还有如果对按下事件，如果以及存在了，就会发送持续的发送前一次的key code，否则就是按下事件，最后需要将key事件封装为一个NotifyKeyArgs参数，这些被封装的对象都是继承自NotifyArgs通过mQueuedListener,即QueuedInputListener的notifyKey分发这次Input消息。 frameworks/base/services/input/InputListener.cpp 123void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) &#123; mArgsQueue.push(new NotifyKeyArgs(*args));&#125; 这个NotifyKey只是将封装的事件参数添加到一个参数队列mArgsQueue中，真正的发送是在flush中进行,它是在loopOnce中的最后调用的表示要将事件派发出去了。 frameworks/base/services/input/InputListener.cpp 12345678910111213void QueuedInputListener::flush() &#123; size_t count = mArgsQueue.size(); for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args; &#125; mArgsQueue.clear();&#125;void NotifyKeyArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123; listener-&gt;notifyKey(this);&#125; 在flush中实际上调用的是NotifyArgs的notify方法。在其方法中调用了Listener的notifyKey这个listener即 QueuedInputListener的mInnerListener，这个mInnerListener即是在创建QueuedInputListener时传递的参数InputDispatcher，这个就是我们的派发者对象。因为InputReader的主要任务就是将读取的Input事件交给InputDispatcher进行处理。 frameworks/base/services/input/InputDispatcher.cpp 1234567891011121314151617181920void InputDispatcher::notifyKey(const NotifyKeyArgs* args) &#123; …… bool needWake; &#123; // acquire lock mLock.lock(); …… int32_t repeatCount = 0; KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, args-&gt;keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime); needWake = enqueueInboundEventLocked(newEntry); mLock.unlock(); &#125; // release lock if (needWake) &#123; mLooper-&gt;wake(); &#125;&#125; InputDipatcher通过notifyKey来处理InputReader交给的事件，这里通过事件参数args来构造一个KeyEntry对象，并通过enqueuInboundEventLocked将其加入到一个队列中去，等待进行处理，并根据needWake来决定唤醒Looper。 frameworks/base/services/input/InputDispatcher.cpp 1234567891011121314151617181920212223242526272829bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; bool needWake = mInboundQueue.isEmpty(); mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); switch (entry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; // Optimize app switch latency. // If the application takes too long to catch up then we drop all events preceding // the app switch key. KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry); if (isAppSwitchKeyEventLocked(keyEntry)) &#123; if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123; mAppSwitchSawKeyDown = true; &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123; if (mAppSwitchSawKeyDown) &#123;#if DEBUG_APP_SWITCH ALOGD(\"App switch is pending!\");#endif mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT; mAppSwitchSawKeyDown = false; needWake = true; &#125; &#125; &#125; break; &#125;&#125;&#125; return needWake;&#125; enqueueInboundEventLocked将新的keyEvent加入到mInboundQueue中去，如果一开始这个队列是空的，就需要唤醒Looper了表示有新的事件需要处理。当事件到来后就会触发InputDipatcher的dispatchOnce，还记得？这个方法是在InputDipatcherThread的threadloop中循环调用进行事件处理的。我们看看它的具体实现 123456789101112131415161718192021222324void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis);&#125; 这里事件的真正处理是在dispatchOnceInnerLocked中进行处理的。它会负责处理队列中的输入事件。然后通过pollOnce将事件发送出去，这是InputDispatcher的职责。下面我们看看dispatchOnceInnerLocked的具体实现。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213141516171819202122232425void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); …… if (! mPendingEvent) &#123; if (mInboundQueue.isEmpty()) &#123; …… &#125; else &#123; // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.dequeueAtHead(); traceInboundQueueLengthLocked(); &#125; …… // Get ready to dispatch the event. resetANRTimeoutsLocked();//重置ANR &#125; switch (mPendingEvent-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); …… done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; &#125; ……&#125; 这个方法首先判断mInboundQueue队列是否有事件要处理，有的话就先取出队头的事件放到mPendingEvent中，根据事件类型分别进行处理，这里我们看类型为TYPE_KEY的输入事件。然后调用dispatchKeyLocked进行处理。 12345678910111213141516171819202122bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; …… // Identify targets. Vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); if (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123; return false; &#125; setInjectionResultLocked(entry, injectionResult); if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123; return true; &#125; addMonitoringTargetsLocked(inputTargets); // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; 取出待处理的事件后通过dispatchKeyLocked进行处理，这个方法首先根据 findFocusedWindowTargetsLocked找到需要派发的目标对象inputTargets，然后通过 dispatchEventLocked进一步处理。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123; …… for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; else &#123; &#125; &#125;&#125; dispatchEventLocked方法主要是将待发送的输入事件发送给目标对象，这个目标对象是实际上为一个Connection，内部通过InputChannel构造，它是通过registerInputChannel中添加到一个mConnectionByFd的map中维护的。 123456void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; // Not splitting. Enqueue dispatch entries for the event as is. enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);&#125; prepareDispatchCycleLocked进一步调用enqueueDispatchEntriesLocked 1234567891011121314151617181920212223void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.isEmpty(); // Enqueue dispatch entries for the requested modes. enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_OUTSIDE); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection); &#125;&#125; 再接着调用startDispatchCycleLocked 1234567891011121314151617181920212223242526272829303132333435void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; …… while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125; …… &#125; …… // Re-enqueue the event on the wait queue. connection-&gt;outboundQueue.dequeue(dispatchEntry); traceOutboundQueueLengthLocked(connection); connection-&gt;waitQueue.enqueueAtTail(dispatchEntry); traceWaitQueueLengthLocked(connection); &#125;&#125; 到这里其实InputDispatcher的任务基本结束了，它已经将任务转给了具体的Connection进行处理，这个Connection即是再Dispatcher中注册的客户。下面我们分析这些Connection是如何注册到InputDispatcher的。这里我们从底层到上层追上去进行回顾整个流程 首先registerInputChannel是再NativeInputManager的registerInputChannel中调用的，而后者也应该是再Java层的InputManagerService中调用的，那么谁回去调用IMS的registerInputChannel呢？ InputChannel的注册 回顾我们之前再SystemServer中所做的事情，再IMS创建后会关联到WMS上，因为输入事件最终是要交给WMS负责分发给客户端的应用程序的。所以注册channel应该是再WMS上进行的。我们下来就看看这个注册的流程以及最终的事件是如何发布到上层的。首先我们去看那WMS的main方法 12345678910111213141516171819202122232425262728public static WindowManagerService main(final Context context, final PowerManagerService pm, final DisplayManagerService dm, final InputManagerService im, final Handler wmHandler, final boolean haveInputMethods, final boolean showBootMsgs, final boolean onlyCore) &#123; final WindowManagerService[] holder = new WindowManagerService[1]; wmHandler.runWithScissors(new Runnable() &#123; @Override public void run() &#123; holder[0] = new WindowManagerService(context, pm, dm, im, haveInputMethods, showBootMsgs, onlyCore);//创建WMS实例 &#125; &#125;, 0); return holder[0];&#125;``` Main主要负责创建WMS实例，所以我们看看其构造方法。```javaprivate WindowManagerService(Context context, PowerManagerService pm, DisplayManagerService displayManager, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) &#123; …… //WMS内部持有IMS的引用 mInputManager = inputManager; // Must be before createDisplayContentLocked. …… &#125; 在构造方法中实际上只是将IMS的实例保存在mInputManager中罢了，并没有任何注册的线索。那么注册的流程是在哪里呢？其实可以想象的到，当应用启动后，只有当界面显示出来的时候才能够接受输入事件，而且只有当前有焦点的窗口才可以对事件进行处理，而那些在任务栈中处于停止状态的窗口不对其进行处理。那么当窗口加入到WMS中时应该回去注册相应的channel用来接收事件。 12345678910111213141516171819public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; …… ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; root.setView(view, wparams, panelParentView); ……&#125; 这里我们主要看看ViewRootImpl的setView 12345678910111213141516171819202122232425262728293031323334353637383940414243public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; …… //这次layout是为接受输入事件做准备，最重要的工作就是设置当前窗口为WMS中具 有焦点的窗口 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; //为窗口创建一个Client端的InputChannel,它是用来监听Input事件的。 mInputChannel = new InputChannel(); &#125; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; …… if (mInputChannel != null) &#123;//前面为该window创建了InputChannel所以不为null if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue();//创建一个InputQueue mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ……&#125; 在setView中会去创建InputChannel，在这之前会调用一次requestLayout，这里的主要工作就是设置当前窗口为WMS中具有焦点的窗口，为接受输入事件做准备。那么这个InputChannel会去注册到InputDispatcher中？实际上不是的，注意这个方法还在我们的应用端。而接受InputDispather也就是IMS的输入事件的是WMS，那么事件的流程应该是IMS到WMS然后再到应用端程序。下面我们追踪mInputChannel来看看具体是怎么样的。 我们先看到mInputChannel，它的创建过程，它的构造方法是个空方法，这么说InputChannel现在在java层只是一个空壳，而真正的初始化是在native层的。接着我们看到mInputChannel被传递给了addToDisplay,这个方法将当前窗口添加到WMS中，它会通过Binder调用WMS的addWindow方法。所以我们去WMS中看看addWindow的实现 frameworks/base/services/java/com/android/server/wm/WindowManagerService.java 12345678910111213141516public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; …… if (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; String name = win.makeInputChannelName(); InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); win.setInputChannel(inputChannels[0]); inputChannels[1].transferTo(outInputChannel); mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); &#125; ……&#125; 这里的outInputChannel就是我们客户端传递的mInputChannel，这里我们看到首先我们调用InputChannel的openInputChannelPair方法打开了一对InputChannel，这一对InputChannel分别是为Client和Server端的channel,用来负责应用端以及WMS的输入事件的接受通道。其中索引为0的为服务端的，而索引为1的为客户端的。我们看到inputChannels[0]先被保存在win中，也即是WindowState中，WindowState表示当前窗口，随后通过mInputManager调用registerInputChannel注册到InputDispatcher中。 而inputchanel[1]被转换为outInputChannel作为出参传递给应用端。这里我们先分析注册到InputDispatcher的这个InputChannel，随后再分析传递到客户端的inputchannel。 首先我们分析openInputChannelPair流程。 frameworks/base/core/java/android/view/InputChannel.java 12345678910public static InputChannel[] openInputChannelPair(String name) &#123; if (name == null) &#123; throw new IllegalArgumentException(\"name must not be null\"); &#125; if (DEBUG) &#123; Slog.d(TAG, \"Opening input channel pair '\" + name + \"'\"); &#125; return nativeOpenInputChannelPair(name);&#125; 这个方法直接调用了native层的nativeOpenInputChannelPair方法 frameworks/base/core/jni/android_view_InputChannel.cpp 1234567891011121314151617181920212223242526272829303132333435363738static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL); String8 name(nameChars); env-&gt;ReleaseStringUTFChars(nameObj, nameChars); sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); if (result) &#123; String8 message; message.appendFormat(\"Could not open input channel pair. status=%d\", result); jniThrowRuntimeException(env, message.string()); return NULL; &#125; jobjectArray channelPair = env-&gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; jobject serverChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(serverChannel)); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; jobject clientChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(clientChannel)); if (env-&gt;ExceptionCheck()) &#123; return NULL; &#125; env-&gt;SetObjectArrayElement(channelPair, 0, serverChannelObj); env-&gt;SetObjectArrayElement(channelPair, 1, clientChannelObj); return channelPair;&#125; 这个方法调用c++层的InputChannle(定义在InputTransport中)打开一对InputChannel对象，serverChannel和clientChannel，随后通过这两个对象调用android_view_input_channel_createInputChannel构造java层的InputChannel对象。 frameworks/native/libs/input/InputTransport.cpp 123456789101112131415161718192021222324252627status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(\"channel '%s' ~ Could not create socket pair. errno=%d\", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); String8 serverChannelName = name; serverChannelName.append(\" (server)\"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(\" (client)\"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK;&#125; 首先通过socketpair创建一对相互连接的unnamed socket，这两个socket都可以互相进行读写，相比以前的管道通信，它是全双工的通信，即一端的socket既可以读又可以写。 创建好后，通过这两个socket分别去构造两个InputChannel作为服务端和客户端的读写通道。传递好后就可以将他们传递给java层使用了，这是通过android_view_input_channel_createInputChannel实现的。 123456789101112131415static jobject android_view_InputChannel_createInputChannel(JNIEnv* env, NativeInputChannel* nativeInputChannel) &#123; jobject inputChannelObj = env-&gt;NewObject(gInputChannelClassInfo.clazz, gInputChannelClassInfo.ctor); if (inputChannelObj) &#123; android_view_InputChannel_setNativeInputChannel(env, inputChannelObj, nativeInputChannel); &#125; return inputChannelObj;&#125;static void android_view_InputChannel_setNativeInputChannel(JNIEnv* env, jobject inputChannelObj, NativeInputChannel* nativeInputChannel) &#123; env-&gt;SetIntField(inputChannelObj, gInputChannelClassInfo.mPtr, reinterpret_cast&lt;jint&gt;(nativeInputChannel));&#125; java层持有的其实是NativeInputChannel，它内部持有我们之前构造的InputChannel。 这个对象的地址会保存在java层的InputChannel的mPtr中。 创建好channel后接下来我们看看IMS是如何注册我们的服务端的InputChannel的 在之前addWindow中我们看到创建好Channel pair后就会调用IMS的registerInputChannel来注册服务端的Channel. frameworks/base/services/java/com/android/server/input/InputManagerService.java 12345678public void registerInputChannel(InputChannel inputChannel, InputWindowHandle inputWindowHandle) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException(\"inputChannel must not be null.\"); &#125; nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);&#125; frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp 123456status_t NativeInputManager::registerInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel( inputChannel, inputWindowHandle, monitor);&#125; 这个mINputManager就是我们c++层的InputMnager，通过getDispatcher获取到的InputDispatcher对象就是我们在创建InputManger对象时创建的mDispatcher。 frameworks/base/services/input/InputDispatcher.cpp 12345678910111213141516171819202122232425262728status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; &#123; // acquire lock AutoMutex _l(mLock); if (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123; ALOGW(\"Attempted to register already registered input channel '%s'\", inputChannel-&gt;getName().string()); return BAD_VALUE; &#125; sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; 这里我们通过传递进来的InputChannel先创建一个Connection对象，随后添加到一个mConnectionsByFd这个Map中去。需要注意的是在注册完成之后会去为这个描述符注册回调handleReceiveCallBack中。 123456InputDispatcher::Connection::Connection(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) : status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle), monitor(monitor), inputPublisher(inputChannel), inputPublisherBlocked(false) &#123;&#125; 这里可以看到通过InputChannel构造一个InputPublisher对象，这个InputChannel是我们服务端的Channel,它最终是给WMS使用的。还记得？在InputDispater中正是通过它的publishKeyEvent方法来发布输入事件到WMS的。 12345678910111213141516171819202122232425262728status_t InputPublisher::publishKeyEvent( uint32_t seq, int32_t deviceId, int32_t source, int32_t action, int32_t flags, int32_t keyCode, int32_t scanCode, int32_t metaState, int32_t repeatCount, nsecs_t downTime, nsecs_t eventTime) &#123; InputMessage msg; msg.header.type = InputMessage::TYPE_KEY; msg.body.key.seq = seq; msg.body.key.deviceId = deviceId; msg.body.key.source = source; msg.body.key.action = action; msg.body.key.flags = flags; msg.body.key.keyCode = keyCode; msg.body.key.scanCode = scanCode; msg.body.key.metaState = metaState; msg.body.key.repeatCount = repeatCount; msg.body.key.downTime = downTime; msg.body.key.eventTime = eventTime; return mChannel-&gt;sendMessage(&amp;msg);&#125; 在publishKeyEvent中我们通过调用InputChannel的sendMessage将事件发送出去。 123456789status_t InputChannel::sendMessage(const InputMessage* msg) &#123; size_t msgLength = msg-&gt;size(); ssize_t nWrite; do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); …… return OK;&#125; 在sendMessage中实际上我们使用的是为WMS注册InputChannel来发送的事件消息，它的接收端位于我们应用程序的另一个InputChannel。接下来我们就需要看看应用程序是如何接受这个输入事件的。 应用端输入事件的接受 在WMS的addView中我们构造了一对InputChannel，其中一个作为服务端注册到了InputDispatcher中，另一个作为结果返回给了应用端，应用端正是使用这个InputChannel来监听输入事件的。 在ViewRootImpl的setView中调用了addToDisplay后就得到了这个InputChannel,随后又使用该InputChannel构造了一个一个WindowInputEvetnReceiver对象 12345678if (mInputChannel != null) &#123;//前面为该window创建了InputChannel所以不为null if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue();//创建一个InputQueue mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());&#125; 这个WindowInputEventReceiver的实现如下 123456789101112131415161718192021final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; @Override public void onBatchedInputEventPending() &#123; scheduleConsumeBatchedInput(); &#125; @Override public void dispose() &#123; unscheduleConsumeBatchedInput(); super.dispose(); &#125;&#125; 从其实现来看它继承自InputEventReceiver，是用来接受输入事件的，其中onInputEvent重载了接受事件的方法。 123456789101112131415public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException(\"inputChannel must not be null\"); &#125; if (looper == null) &#123; throw new IllegalArgumentException(\"looper must not be null\"); &#125; mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(\"dispose\");&#125; 这里的inputChannel是客户端使用的，它会通过nativeInit进行初始化，同时这个Looper是我们的主线程的Looper。 12345678910111213141516171819202122232425262728static jint nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); if (inputChannel == NULL) &#123; jniThrowRuntimeException(env, \"InputChannel is not initialized.\"); return 0; &#125; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, \"MessageQueue is not initialized.\"); return 0; &#125; sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); status_t status = receiver-&gt;initialize(); if (status) &#123; String8 message; message.appendFormat(\"Failed to initialize input event receiver. status=%d\", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jint&gt;(receiver.get());&#125; nativeInit在native层创建对应的NativeInputEventReceiver对象，并调用了initialize进行初始化,同时将该native对象作为结果返回给java层的InputEventReceiver的mReceiverPtr成员。 123456789101112NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mInputConsumer(inputChannel), mMessageQueue(messageQueue), mBatchedInputEventPending(false), mFdEvents(0) &#123;&#125;status_t NativeInputEventReceiver::initialize() &#123; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125; NativeInputEventReceiver的构造方法很简单，会通过inputchannel构造一个InputConsumer mInputConsumer，从名字来看它是一个输入事件的消费者，也就是我们客户端程序。 1234567891011void NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里将InputChannel的描述符fd取出来，然后通过主线程的Looper进行监听，当需要读取输入事件时会触发handleEVent回调。 1234567891011int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) &#123; …… if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, \"handleReceiveCallback\"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125; ……&#125; 随后调用consumeEvents进一步对事件进行消费 123456789101112131415161718192021222324252627status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; …… ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (status) &#123; …… return status; &#125; …… if (inputEventObj) &#123; env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); env-&gt;DeleteLocalRef(inputEventObj); &#125; else &#123; ALOGW(\"channel '%s' ~ Failed to obtain event object.\", getInputChannelName()); skipCallbacks = true; &#125; &#125; …… &#125;&#125; 这里先调用InputConsumer的consume方法进行事件的读取，随后通过gInputReceiverClassInfo的dispatchInputEvent方法发布到java层的InputEventReceiver frameworks/native/libs/input/InputTransport.cpp 123456789101112131415161718192021222324252627282930313233status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; *outSeq = 0; *outEvent = NULL; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; if (mMsgDeferred) &#123; // mMsg contains a valid input message from the previous call to consume // that has not yet been processed. mMsgDeferred = false; &#125; else &#123; // Receive a fresh message. status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); …… &#125; switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; KeyEvent* keyEvent = factory-&gt;createKeyEvent(); if (!keyEvent) return NO_MEMORY; initializeKeyEvent(keyEvent, &amp;mMsg); *outSeq = mMsg.body.key.seq; *outEvent = keyEvent; break; &#125; …… &#125; return OK;&#125; 这里首先通过Client端的InputChannel来读取服务发送的输入事件，然后将结果保存在outEvent中 frameworks/native/libs/input/InputTransport.cpp 12345678status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; nRead = ::recv(mFd, msg, sizeof(InputMessage), MSG_DONTWAIT); &#125; while (nRead == -1 &amp;&amp; errno == EINTR); …… return OK;&#125; 接下来就到java层看看我们如何接受输入事件的，刚才说过，输入事件最终是通过InputEventReceiver的dispatchInputEvent接受的。 123456// Called from native code.@SuppressWarnings(\"unused\")private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; 在dispatchInputEvent中是通过onInputEvent处理的，它真正的工作是它的子类WindowInputEventReceiver中进行处理的，它是在ViewRootImpl中定义的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; @Override public void onBatchedInputEventPending() &#123; scheduleConsumeBatchedInput(); &#125; @Override public void dispose() &#123; unscheduleConsumeBatchedInput(); super.dispose(); &#125;&#125;void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; mPendingInputEventCount += 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); if (processImmediately) &#123; doProcessInputEvents(); &#125; else &#123; scheduleProcessInputEvents(); &#125;&#125; 这里先将待处理的事件入队，并调用doProcessInputEvents进一步处理。 123456789101112131415161718192021222324void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); deliverInputEvent(q); &#125; // We are done processing all input events that we can process right now // so we can clear the pending flag immediately. if (mProcessInputEventsScheduled) &#123; mProcessInputEventsScheduled = false; mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS); &#125;&#125; doProcessInputEvents的处理逻辑很简单，如果队列中有待处理的事件就循环调用deliverInputEvent进行处理。 123456789101112131415161718192021222324252627private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\"); try &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125;public final void deliver(QueuedInputEvent q) &#123; if ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123; forward(q); &#125; else if (shouldDropInputEvent(q)) &#123; finish(q, false); &#125; else &#123; apply(q, onProcess(q)); &#125;&#125; 在deliverInputEvent中，事件被交给一个InputStage进行处理，这个InputState实际上是一个职责链，事件沿着职责链进行传递，当某个Stage需要处理的话就调用apply来调用onProcess进行事件的消费。这个职责链是在ViewRootImpl的setview中创建的。 123456789101112131415// Set up the input pipeline.CharSequence counterSuffix = attrs.getTitle();InputStage syntheticInputStage = new SyntheticInputStage();InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage);InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, \"aq:native-post-ime:\" + counterSuffix);InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);InputStage imeStage = new ImeInputStage(earlyPostImeStage, \"aq:ime:\" + counterSuffix);InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, \"aq:native-pre-ime:\" + counterSuffix);mFirstInputStage = nativePreImeStage;mFirstPostImeInputStage = earlyPostImeStage; 对于处理键盘输入事件，我们会交给viewPostImeStage进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final class ViewPostImeInputStage extends InputStage &#123; public ViewPostImeInputStage(InputStage next) &#123; super(next); &#125; @Override protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; // If delivering a new non-key event, make sure the window is // now allowed to start updating. handleDispatchDoneAnimating(); final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q); &#125; else &#123; //处理触摸事件 return processGenericMotionEvent(q); &#125; &#125; &#125; private int processKeyEvent(QueuedInputEvent q) &#123; final KeyEvent event = (KeyEvent)q.mEvent; if (event.getAction() != KeyEvent.ACTION_UP) &#123; // If delivering a new key event, make sure the window is // now allowed to start updating. handleDispatchDoneAnimating(); &#125; // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) &#123; return FINISH_HANDLED; &#125; …… &#125; return FORWARD; &#125; private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; if (mView.dispatchPointerEvent(event)) &#123; return FINISH_HANDLED; &#125; return FORWARD; &#125; …… private int processGenericMotionEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; // Deliver the event to the view. if (mView.dispatchGenericMotionEvent(event)) &#123; return FINISH_HANDLED; &#125; return FORWARD; &#125;&#125; 在onProcess中如果事件类型为keyevent会交给processKeyEvent进行处理，后者会将事件投递给mView，即我们的DecorView，这样输入事件就可以view树上进行传递了。关于在view树中的处理流程，我们在另一篇中再做介绍。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"Zygote进程启动过程分析","slug":"aosp-system-zygote-startup","date":"2017-09-25T12:03:05.000Z","updated":"2018-05-19T11:47:54.443Z","comments":true,"path":"2017/09/25/aosp-system-zygote-startup/","link":"","permalink":"http://esligh.github.io/2017/09/25/aosp-system-zygote-startup/","excerpt":"","text":"zygote进程定义 Init进程是Android系统中用户空间的第一个进程， 它最重要的工作就是创建zygote进程。而在Android系统中，所有应用程序的进程以及系统服务进程SystemServer都是由Zygote进程孕育出来的。所有Zygote的地位非同小可，本文就分析它的启动过程。 Android系统启动后运行的第一个进程是init进程，它的目录在system/core/init/init.cpp 在这里会进行启动属性服务以及解析init.rc文件，init.rc文件是android系统的配置文件，它如下格式所示： 12345678system/core/rootdir/init.rcservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 每一个service命令都会促使init进程调用fork函数来创建一个新的进程，这里service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process，后面的则是要传给app_process的参数。class main指的是zygote的class name为main。 zygote要执行的程序是system/bin/app_process这样会进入main函数。在main中会执行AppRuntime的start来进一步启动zygote。 frameworks/base/cmds/app_process/app_main.cpp 1234567int main(int argc, char* const argv[])&#123;……runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);……&#125; 这里的runtime是AppRuntime的实例，AppRuntime是继承自AndroidRuntime，这里的start方法就是在AndroidRuntime里定义的。 //启动android运行时 这包括了启动虚拟机和调用callName所定义的静态main方法 这里时指com.android.internal.os.ZygoteInit frameworks/base/core/jni/AndroidRuntime.cpp 123456789101112131415161718192021222324252627282930void AndroidRuntime::start(const char* className, const char* options)&#123; …… JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env) != 0) &#123;//启动虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123;//在虚拟机中注册function ALOGE(\"Unable to register all android natives\\n\"); return; &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName);//找到ZygoteInit类 if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\");//调用静态main方法 &#125;&#125; Zygote进程在启动时会创建JavaVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个JavaVM的实例拷贝.在启动zygote时传递进来的类为com.android.internal.os.ZygoteInit，这里通过反射的方式来调用其main方法进一步完成启动初始化的过程。 123456789101112131415161718192021222324252627282930//在AndroidRuntime的start方法通过反射调用的public static void main(String argv[]) &#123; try &#123; // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); registerZygoteSocket();//注册zygote本地Socket服务 监听来自AMS的创建应用进程请求 EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload();//预加载 一些资源，类等 …… if (argv[1].equals(\"start-system-server\")) &#123; startSystemServer();//启动SystemServer进程 &#125; else if (!argv[1].equals(\"\")) &#123; throw new RuntimeException(argv[0] + USAGE_STRING); &#125; Log.i(TAG, \"Accepting command socket connections\"); runSelectLoop();//等待客户端请求 closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run();// &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 在zygote的初始化中，做了以下几件事件： 通过registerServerSocket创建zygote的socket服务，它是一个LocalSocketServer用来等待AMS请求zygote创建应用进程的请求。 监听socket服务，等待AMS创建应用程序的请求 创建SystemServer进程 值得注意的是，无论是创建systemServer进程还是创建应用进程，最终都会通过捕获MethodAndArgsCaller异常来执行参数指定的class的main方法，后面我们分析SystemServer启动及应用进程的启动时就会看到。 这里我们接着看看注册socket服务的代码，它仅仅是创建了LocalServerSocket的本地socket对象 1234567891011121314151617181920private static void registerZygoteSocket() &#123; if (sServerSocket == null) &#123; int fileDesc; try &#123; String env = System.getenv(ANDROID_SOCKET_ENV); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException( ANDROID_SOCKET_ENV + \" unset or invalid\", ex); &#125; try &#123; sServerSocket = new LocalServerSocket( createFileDescriptor(fileDesc)); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125;&#125; SystemServer进程的创建流程 这里我们重点关注SystemServer的创建流程，继续关注startSystemServer 1234567891011121314151617181920212223242526272829303132333435363738394041private static boolean startSystemServer() throws MethodAndArgsCaller, RuntimeException &#123; …… /* Hardcoded command line to start the system server */ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--runtime-init\", \"--nice-name=system_server\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);//fork 出systemServer进程 &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; handleSystemServerProcess(parsedArgs);//在子进程中调用 &#125; return true;&#125; 在startSystemServer中仅仅fork出进程后随后进一步在handleSystemServerProcess中进一步对SystemServer进行初始化 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112131415161718192021222324252627private static void handleSystemServerProcess(//进一步处理SystemServer进程的相关工作 ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket();//关闭从父进程继承来的socket // set umask to 0077 so new files and directories will default to owner-only permissions. Libcore.os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, parsedArgs.remainingArgs); &#125; else &#123; /* * Pass the remaining arguments to SystemServer. */ //此时的remainingArgs就是”com.android.server.SystemServer” RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs); &#125; /* should never reach here */&#125; 这里进一步调用zygoteInit进行初始化工作 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678910public static final void zygoteInit(int targetSdkVersion, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); redirectLogStreams(); commonInit(); nativeZygoteInit();//zygote本地初始化 applicationInit(targetSdkVersion, argv);////应用层的初始化 &#125; 首先我们来看第一个方法nativeZygoteInit的调用，这个方法时在AndroidRuntime中定义的，具体是 /frameworks/base/core/jni/AndroidRuntime.cpp 12345static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; 这里的onZygoteInit是调用其子类AppRuntime的方法,zygote的启动就是通过这个类调用start方法来执行的。 frameworks/base/cmds/app_process/app_main.cpp 123456789virtual void onZygoteInit()&#123; // Re-enable tracing now that we're no longer in Zygote. atrace_set_tracing_enabled(true); sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool();&#125; ProcessState对于binder机制非常重要，这里主要是初始化SystemServer进程的的binder环境，这样在其进程中就可以通过binder同其他进程进行通信了。 下面我们来看看第二个方法applicationInit，这个方法第二个参数包含了调用了类的信息及相关方法的参数，这里就是“com.android.server.SystemServer”和main方法 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 123456private static void applicationInit(int targetSdkVersion, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; …… // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs); &#125; 这个方法内部会调用invokeStaticMain方法。 123456789101112131415161718192021222324//这个方法最终会抛出异常MethodAndArgsCaller触发其run方法的调用，具体见ZygoteInit的main方法private static void invokeStaticMain(String className, String[] argv) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className);//获取类信息 可能是SystemServer或者ActivityThread &#125; catch (ClassNotFoundException ex) &#123; &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;);//获取对应类的main方法 &#125; catch ()&#123;&#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ //抛出异常，通过MethodAndArgsCaller的run方法会去调用main方法 throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; MethodAndArgsCaller的定义如下,这里我们重点看看run方法,run方法的实现很简单只是对main方法进行调用。即调用SystemServer的main方法完成SystemServer进程的创建和启动。 1234567891011121314public static class MethodAndArgsCaller extends Exception implements Runnable &#123; /** method to call */ private final Method mMethod;//调用的方法，这里就是main方法了 /** argument array */ private final String[] mArgs;//参数…… public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125;catch()&#123;…&#125; &#125;&#125; 应用进程的创建启动过程 接下来我们分析应用进程创建和启动的过程，这个过程中需要AMS的介入，不过这里我们重点关注应用进程的创建和启动过程，而不需要关注整个流程的太多细节。熟悉AMS的应该知道，当我们点击Launcher启动应用程序后 最终会通过AMS的startProcessLocked方法来为我们的应用程序创建进程，而其内部会进一步调用startProcessLocked来完成，所以我们重点看那startProcessLocked方法。 frameworks/base/services/java/com/android/server/am/ActivityManagerService.java 12345678910private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); ……&#125; 这个方法会通过Process的start方法类完成进程的创建，这里我们传递ActivityThread的类名，再我们创建完应用进程后需要就是调用其内部的main方法完成启动过程。下面我们继续去看下进程是如何创建的。 frameworks/base/core/java/android/os/Process.java 1234567891011public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids,debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; &#125;&#125; Process的start方法很简单，调用startViaZygote，从其名称来看就是通过zygote来创建我们应用进程了。 这里的processClass就是我们的ActivityThread类，niceName是进程名称。startViaZygote通过将这一些参数打包到一个ArrayList变量中然后调用zygoteSendArgsAndGetResult，并将打包的参数传递给它。这个方法负责将这些参数通过socket传递给zygote. 123456789101112131415161718192021222324252627private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; openZygoteSocketIfNeeded(); try &#123; sZygoteWriter.write(Integer.toString(args.size())); sZygoteWriter.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx( \"embedded newlines not allowed\"); &#125; sZygoteWriter.write(arg); sZygoteWriter.newLine(); &#125; sZygoteWriter.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = sZygoteInputStream.readInt(); …… &#125; catch (IOException ex) &#123; &#125;&#125; 这个方法首先通过openZygoteSocketIfNeeded方法来打开同zygote通信的socket,并用该socket创建一个 BufferedWriter对象sZygoteWrite，随后通过sZygoteWrite将参数发送给zygote,同时创建一个ProcessStartResult对象，用来保存创建的进程信息。 对于zygote端我们知道，当zygote启动后会先注册一个LocalSocketServer服务，然后通过runSelectLoop等待来自AMS创建进程的请求。这里我们就需要看看runSelectLoop方法。 12345678910111213141516171819202122232425private static void runSelectLoop() throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); FileDescriptor[] fdArray = new FileDescriptor[4]; …… while (true) &#123; int index; …… if (index &lt; 0) &#123; throw new RuntimeException(\"Error in select()\"); &#125; else if (index == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done; done = peers.get(index).runOnce(); if (done) &#123; peers.remove(index); fds.remove(index); &#125; &#125; &#125;&#125; runSelectLoop方法主要负责处理客户端的连接请求和客户端的消息处理，当index==0是说明有新的客户端连接，index&gt;0则说明有消息到来，index指定了客户端的连接索引。同时会调用runOnce对消息机型处理。 1234567891011121314151617181920212223242526272829//zygote收到客户端AMS的信息进行处理boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; …… try &#123; args = readArgumentList();//读取客户端发送的消息 得到参数列表 descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; &#125; …… try &#123; parsedArgs = new Arguments(args); …… pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);//创建应用进程 &#125; catch () &#123;&#125; …… try &#123; if (pid == 0) &#123; …… //继续处理子进程 这里面最终会抛出ZygoteInit.MethodAndArgsCaller来触发其run方法的调用 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123;………&#125; &#125; finally &#123; &#125;&#125; 在这个方法中首先通过readArgumentList方法读取客户端发送的消息，得到参数列表，随后根据参数创建应用进程，随后进一步调用handleChildProc进一步完成子进程的创建。在这个方法中最终会抛出MethodAndArgsCaller异常来触发run方法的调用，就如SystemServer进程那样。 1234567891011121314151617private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; …… if (parsedArgs.invokeWith != null) &#123; WrapperInit.execStandalone(parsedArgs.invokeWith, parsedArgs.classpath, className, mainArgs); &#125; else &#123; …… try &#123; ZygoteInit.invokeStaticMain(cloader, className, mainArgs);//最终会调用invokeStaticMain方法抛出异常 &#125; catch (RuntimeException ex) &#123; logAndPrintError(newStderr, \"Error starting.\", ex); &#125; &#125;&#125; 这个方法会调用invokeStaticMain，这个方法我们在SystemServer启动时候分析过，这里就不再分析了。最终会调用ActivityThread的main方法完成应用进程的启动。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"GUI系统之SurfaceFlinger启动过程分析","slug":"aosp-gui-surfaceflinger-startup","date":"2017-09-22T13:32:09.000Z","updated":"2018-05-19T11:02:18.824Z","comments":true,"path":"2017/09/22/aosp-gui-surfaceflinger-startup/","link":"","permalink":"http://esligh.github.io/2017/09/22/aosp-gui-surfaceflinger-startup/","excerpt":"","text":"surfaceFlinger 在init.rc中是作为一个service存在的它声明如下 12345service surfaceflinger /system/bin/surfaceflinger class main user system group graphics drmrpc onrestart restart zygote 从上面的内容可以看出，surfaceflinger所属的class为main，这和zygote时同级的。但它的启动并不需要带任何参数。同时由于surfaceflinger是service,说明它是单独的可执行程序，程序路径为/system/bin/surfaceflinger 运行在单独的进程里，另外，从最后一行也能看出sf重启时要重启zygote。 Surfaceflinger主程序对应的文件是frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp 所以我们从这个文件入手。 1234567891011121314151617181920212223242526272829int main(int argc, char** argv) &#123; // When SF is launched in its own process, limit the number of // binder threads to 4. ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);//限制了binder线程的个数为4 // start the thread pool sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;startThreadPool();//启动binder线程 // instantiate surfaceflinger sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger();//创建SF对象#if defined(HAVE_PTHREADS) setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);#endif set_sched_policy(0, SP_FOREGROUND); // initialize before clients can connect flinger-&gt;init();//SF的初始化 // publish surface flinger sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);//添加到SM中 // run in this thread flinger-&gt;run();//sf运行起来 return 0;&#125; sf的主程序中做了以下事情： 1.初始binder的运行环境 2.创建Sf对象，并对其进行初始化 3.将Sf服务添加到ServiceManger中，以便向其他进程提供服务 4.SF在自己的线程中开始运行 SurfaceFlinger作为服务进程，必然需要通过Binder进行IPC通信，所以在一开始需要对Binder环境进行初始化。接着创建了SurfaceFlinger对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344frameworks/native/services/surfaceflinger/SurfaceFlinger.cppSurfaceFlinger::SurfaceFlinger() : BnSurfaceComposer(), mTransactionFlags(0), mTransactionPending(false), mAnimTransactionPending(false), mLayersRemoved(false), mRepaintEverything(0), mRenderEngine(NULL), mBootTime(systemTime()), mVisibleRegionsDirty(false), mHwWorkListDirty(false), mAnimCompositionPending(false), mDebugRegion(0), mDebugDDMS(0), mDebugDisableHWC(0), mDebugDisableTransformHint(0), mDebugInSwapBuffers(0), mLastSwapBufferTime(0), mDebugInTransaction(0), mLastTransactionTime(0), mBootFinished(false), mPrimaryHWVsyncEnabled(false), mHWVsyncAvailable(false), mDaltonize(false)&#123; // debugging stuff... char value[PROPERTY_VALUE_MAX]; property_get(\"ro.bq.gpu_to_cpu_unsupported\", value, \"0\"); mGpuToCpuSupported = !atoi(value); property_get(\"debug.sf.showupdates\", value, \"0\"); mDebugRegion = atoi(value); property_get(\"debug.sf.ddms\", value, \"0\"); mDebugDDMS = atoi(value); if (mDebugDDMS) &#123; if (!startDdmConnection()) &#123; // start failed, and DDMS debugging not enabled mDebugDDMS = 0; &#125; &#125;&#125; 构造方法很简单，只是都其成员进行初始化，读取一些配置信息，比如是否开启DDMS的调试。 接下来通过init方法对该对象进行初始化。这个初始化过程会做大量比较重要的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp//sf的初始化方法void SurfaceFlinger::init() &#123; status_t err; Mutex::Autolock _l(mStateLock); // initialize EGL for the default display mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);//获取默认的显示设备 eglInitialize(mEGLDisplay, NULL, NULL);//为默认的显示设备初始EGL环境 // Initialize the H/W composer object. There may or may not be an // actual hardware composer underneath. mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this));//创建合成对象 // First try to get an ES2 config err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES2_BIT, &amp;mEGLConfig); if (err != NO_ERROR) &#123; // If ES2 fails, try ES1 err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES_BIT, &amp;mEGLConfig); &#125; …… EGLint r,g,b,a; eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_RED_SIZE, &amp;r); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_GREEN_SIZE, &amp;g); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_BLUE_SIZE, &amp;b); eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_ALPHA_SIZE, &amp;a); // get a RenderEngine for the given display / config (can't fail) mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);//通过给定的设备创建渲染引擎 // retrieve the EGL context that was selected/created mEGLContext = mRenderEngine-&gt;getEGLContext();//获取EGL context // figure out which format we got eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_NATIVE_VISUAL_ID, &amp;mEGLNativeVisualId); LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT, \"couldn't create EGLContext\"); // initialize our non-virtual displays //初始化所有的非虚拟显示设备 for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i); // set-up the displays that are already connected if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123; // All non-virtual displays are currently considered secure. bool isSecure = true; createBuiltinDisplayLocked(type); wp&lt;IBinder&gt; token = mBuiltinDisplays[i]; //为显示设备创建BufferQueue用来管理其帧缓冲区 并通过FramebufferSurface进行管理 sp&lt;BufferQueue&gt; bq = new BufferQueue(new GraphicBufferAlloc()); sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i, bq); sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, type, allocateHwcDisplayId(type), isSecure, token, fbs, bq, mEGLConfig);//为每个实体设备创建显示设备对象 if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123; // FIXME: currently we don't get blank/unblank requests // for displays other than the main display, so we always // assume a connected display is unblanked. ALOGD(\"marking display %d as acquired/unblanked\", i); hw-&gt;acquireScreen(); &#125; mDisplays.add(token, hw); &#125; &#125; // make the GLContext current so that we can create textures when creating Layers // (which may happens before we render something) getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);//将EGL context和默认的显示设备关联 // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true);//创建绘图延时对象 mEventThread = new EventThread(vsyncSrc);//负责管理绘图延时Vsync信号 sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, false);//创建合成延时对象 mSFEventThread = new EventThread(sfVsyncSrc);//负责管理合成延时Vsync信号 mEventQueue.setEventThread(mSFEventThread); mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(\"EventControl\", PRIORITY_URGENT_DISPLAY); ……&#125; 在init方法中，sf做了以下的事： 1.为默认的显示设备初始EGL环境 2.创建合成对象 3.初始化所有的非虚拟显示设备 4.创建绘图延时Vysnc源 及 合成延时Vysnc源 12345678void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread)&#123; mEventThread = eventThread; mEvents = eventThread-&gt;createEventConnection(); mEventTube = mEvents-&gt;getDataChannel(); mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, ALOOPER_EVENT_INPUT, MessageQueue::cb_eventReceiver, this);//为sf的vsync信号注册事件回调&#125; 需要注意的是在main方法中创建的SurfaceFlinger是个强引用对象，所以在第一次调用同时也会会触发onFirstRef方法，这个方法会对SF的mEventQueue成员进行初始化。它是一个MessageQueue对象，负责SF的消息管理。 1234567891011void SurfaceFlinger::onFirstRef()&#123; mEventQueue.init(this);&#125;void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger)&#123; mFlinger = flinger;//持有sf的引用 mLooper = new Looper(true);//为其创建一个Looper对象 mHandler = new Handler(*this);//创建Handler&#125; 最后调用sf的run方法，这个方法会进入一个循环，不断等待消息的到来并进行处理 123456789101112131415161718192021222324252627282930313233343536void SurfaceFlinger::run() &#123; do &#123; waitForEvent(); &#125; while (true);&#125;void SurfaceFlinger::waitForEvent() &#123; mEventQueue.waitMessage();&#125;frameworks/native/services/surfaceflinger/MessageQueue.cppvoid MessageQueue::waitMessage() &#123; do &#123; IPCThreadState::self()-&gt;flushCommands(); int32_t ret = mLooper-&gt;pollOnce(-1);//内部会调用MessageQueue的handleMessage方法对消息进行处理 switch (ret) &#123; case ALOOPER_POLL_WAKE: case ALOOPER_POLL_CALLBACK: continue; case ALOOPER_POLL_ERROR: ALOGE(\"ALOOPER_POLL_ERROR\"); case ALOOPER_POLL_TIMEOUT: // timeout (should not happen) continue; default: // should not happen ALOGE(\"Looper::pollOnce() returned unknown status %d\", ret); continue; &#125; &#125; while (true);&#125;//通过消息的handler对消息进行处理void MessageBase::handleMessage(const Message&amp;) &#123; this-&gt;handler(); barrier.open();&#125;; SF的消息来源有两种，一个是Vsync信号，这是通过注册的cb_eventReceiver事件回调来处理的，另一种可能是应用进程或者说客户端的消息，比如创建Layer的请求，就是通过发送消息的方式来处理的。 12345678910111213141516171819202122232425262728293031323334353637383940frameworks/native/services/surfaceflinger/Client.cppstatus_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; class MessageCreateLayer : public MessageBase &#123;//继承子messagbase SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123;//实现了handler 这个方法用于接收方处理消息 result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();&#125;","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"ActivityManagerService-Launcher 启动应用流程","slug":"aosp-startactivity-1","date":"2017-09-19T07:30:20.000Z","updated":"2018-05-19T09:03:09.246Z","comments":true,"path":"2017/09/19/aosp-startactivity-1/","link":"","permalink":"http://esligh.github.io/2017/09/19/aosp-startactivity-1/","excerpt":"","text":"综述 ActivityManagerService 即活动管理服务，它负责管理我们应用的activity，service等与系统交互的组件，为了方便起见，我们简称为AMS。我们知道Activity在启动过程中会经历一系列的生命周期，这些生命周期反应了AMS创建和管理Activity的整个过程，并且在这之间又同时需要和WindowManagerService进行交互操作，这就导致activity的启动是个异常复杂的工作。本篇不打算对整个流程的细节做过多的分析，只涉及activity启动过程的关键部分。 Activity启动方式-Launcher 首先activity的启动方式有多种可能的情况，比如最典型的就是点击Launcher上的图标启动，或者在应用内部打开activity进行跳转，还有通过adb 来启动activity，但无论是哪种启动方式，最基本的流程都是类似的。这里我们以Launcher启动作为描述的标准场景来简单了解下在activity启动过程中都会发生什么事情以使activity能够展现在我们眼前。 Launcher是一个标准的系统桌面应用，它用来管理系统中的所有已安装的app，这些app都是以网格化的形式在Launcher中显示的。我们点击一个app图标就会开始启动整个app并启动它的主activity。 Launcher启动是会给Intent添加flag Intent.FLAG_ACTIVITY_NEW_TASK,这表示我们会为这个应用创建一个新的任务栈。紧接就是启动指定的activity，正式开始startActivity的启动。 1234567891011121314151617181920packages/apps/Launcher2/src/com/android/launcher2/Launcher.javaboolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); if (useLaunchAnimation) &#123; ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); startActivity(intent, opts.toBundle()); &#125; else &#123; startActivity(intent);//调用activity的startActivity启动 &#125; return true; &#125; catch (SecurityException e) &#123;&#125; return false;&#125; 从Launcher启动的activity默认添加了FLAG_ACTIVITY_NEW_TASK，表示为应用创建新的任务栈。 这里我们从Launcher启动传递给startActivityForResult的requestCode为-1，说明我们不接受activity的返回值。 1234567891011Activity: startActivity-&gt;startActivityForResult1. [Activity.startActivityForResult]===&gt;[Instrumention.execStartActivity]public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123; …… Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this,intent, requestCode, options); ……&#125; execStartActivity 参数说明,对于Launcher启动： who: 为Launcher应用 mMainThread.getApplicationThread(): 为Launcher的ApplicationThread它是一个Binder target: 为this 代表Launcher这个Activity requestCode: -1 intent: 为要启动应用的Activity的意图 options: null 这里通过Instrumention来调用execStartActivity 1234567891011121314151617181920212.[Instrumention.execStartActivity]===&gt;[AMS.startActivity]public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; …… try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //通过AMS启动Activity 这个是通过binder调用完成 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); //检查启动的结果 这里如果Activity在manifest中未注册就会报错 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123;&#125; …… return null;&#125; 在Instrumention中会通过ActivityManagerNative获取到AMS的代理，到这里就开始通过Binder进行IPC调用了。我们这里继续看AMS中startActivity的实现，AMS时SystemServer进程中的众多服务之一，关于它启动的细节请参见SystemServer.java. 1234567891011[AMS.startActivity]===&gt;[AMS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivity(IApplicationThread caller, StringcallingPackage,Intent intent, String resolvedType, IBinder resultTo,String resultWho, int requestCode, int startFlags,String profileFile, ParcelFileDescriptor profileFd, Bundle options)&#123;//启动流程在AMS的入口 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());&#125; 这里我们对传递的参数做个说明： caller：代表Launcher的ApplicationThread 它是个Binder对象 callingPackage: 调用者即Launcher的包名 Intent: 要启动的activity的意图 resolvedType: Intent中指定的MIME类型 一般不指定的为null resultTo : token 代表着Launcher的activityRecord的- appToken，实际上就是代表着Launcher. resultWho : null requestCode:-1 startFlags : 0 profileFile:-1 profileFd:null Options:null 123456789101112131415161718[AMS.startActivityAsUser]===&gt;[ASS.startActivityAsUser]frameworks/base/services/java/com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,false, true, \"startActivity\", null); // TODO: Switch to user app stacks here. //mStackSupervisor是一个ActivityStackSupervisor ，从名字上看是对ActivityStack进行操作的 //这里callingUid为-1 profileFile为null profileFd为null return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profileFile, profileFd, null, null, options, userId);&#125; AMS作为activity的管理者，它很懒，不做什么事情，几乎大部分Service都类似，他们不会真正的做事情，而是交给其他的&quot;代理&quot;对象去做事情。这里的&quot;代理&quot;对象就是ActivityStackSupervisor从名称上来看它负责监控和管理ActivityStack。 12345678910111213141516171819202122232425262728293031frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, String profileFile, ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config, Bundle options, int userId) &#123; …… // Collect information about the target of the Intent. ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profileFile, profileFd, userId);//收集参数Intent的相关信息到aInfo中 synchronized (mService) &#123; int callingPid;//Launcher:默认传递进来的为-1 if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = Binder.getCallingPid(); callingUid = Binder.getCallingUid(); &#125; else &#123; callingPid = callingUid = -1;//Launcher:D &#125; ……… //继续调用startActivityLocked进行启动流程 int res = startActivityLocked(caller, intent, resolvedType, aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, startFlags, options, componentSpecified, null); ……&#125; startActivityMayWait方法中会从待启动的activity的intent中获取ActivityInfo，随后再去设置callingPid 和 callingUid为-1.在进一步调用startActivityLocked。 1234567891011121314151617181920212223242526272829303132333435frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options, boolean componentSpecified, ActivityRecord[] outActivity) &#123; ProcessRecord callerApp = null; if (caller != null) &#123;//校验调用者进程对于Launcher来说 即Launcher所在的应用进程 callerApp = mService.getRecordForAppLocked(caller);//查找调用者在AMS中的ProcessRecord信息 if (callerApp != null) &#123; callingPid = callerApp.pid;//调用者的进程id callingUid = callerApp.info.uid;//调用者的用户id &#125;…… &#125; /做一些权限检测工作 final int startAnyPerm = mService.checkPermission( START_ANY_ACTIVITY, callingPid, callingUid); final int componentPerm = mService.checkComponentPermission(aInfo.permission, callingPid, callingUid, aInfo.applicationInfo.uid, aInfo.exported); //为新的Activity创建ActivityRecord AMS中AcitivtyRecord用来描述Activity ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, this); //继续调用启动流程 //Launcher:sourceRecord保存着Launcher Activity的实体信息 需要注意的是这里doResume参数默认位true err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options); &#125; 这个方法主要做的事情包括： 1.初始化调用者的进程id和用户id,这是通过查找它的ProcessRecord来进行的。 2.做一些权限检查，比如调用者的权限和启动组件的权限等 3.为待启动的activity创建AtivityRecord，同时会创建appToken，用来代表这个ActivityRecord，间接代表要启动的activity. 4.进一步调用startActivityUncheckedLocked来进一步启动，这里的sourceRecord为Launcher的ActivityRecord。r就是我们要启动的activity的activityRecord 123456789101112131415161718192021222324252627282930313233343536373839404142final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord, int startFlags, boolean doResume, Bundle options) &#123; …… if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; if (r.resultTo == null) &#123; //Launcher:这里调用findTaskLocked找到是否存在r的实例，这里查找的结果应该是null，因为是从Launcher加载 ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(r) : findActivityLocked(intent, r.info); &#125; &#125; …… if (r.resultTo == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;//Launcher：true 需要一个新的task targetStack = adjustStackFocus(r); moveHomeStack(targetStack.isHomeStack()); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, true), null, true);//创建TaskRecord 并保存在r的task成员中 &#125; else &#123; r.setTask(reuseTask, reuseTask, true); &#125; newTask = true; …… &#125; …… mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,intent, r.getUriPermissionsLocked()); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); mService.setFocusedActivityLocked(r); &#125; 这一步会首先为要启动的activity找到一个task,然而由Launcher启动的时候activity的task还并未创建，这时候需要为其创建一个task并通过setTask设置到r中去。紧接着这里调用startActivityLocked进一步处理，同时将mLastPausedActivity置null,表示当前没有被暂停的activity。将mFocusedActivity设置为当前的activity，表示为焦点activity.对于Launcher启动这里newTask为true。 12345678910111213141516171819202122232425final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task;//ActivityRecord中存储的TaskRecord final int taskId = rTask.taskId; if (taskForIdLocked(taskId) == null || newTask) &#123; insertTaskAtTop(rTask); mWindowManager.moveTaskToTop(taskId); &#125; …… task.addActivityToTop(r);//将ActivityRecord放到task栈的顶部 task.setFrontOfTask();//将task栈设置为前台栈 r.putInHistory(); if (!isHomeStack() || numActivities() &gt; 0) &#123; …… &#125;else&#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0, r.userId,r.info.configChanges); &#125; if (doResume) &#123; mStackSupervisor.resumeTopActivitiesLocked();//又回到ActivityStackSupervisor &#125;&#125; 这一步首先将要启动的activity对应的ActivityRecord 即r放到其对应TaskRecord的顶部，然后将其Task设置为前台栈.随后为该Activity添加AppWindowToken，这个token时WMS用来标记AMS端的Activity对应的window的。最后调用resumeTopActivitiesLocked进一步处理栈顶activity. 12345678910111213141516171819202122boolean resumeTopActivitiesLocked() &#123; return resumeTopActivitiesLocked(null, null, null); &#125; boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = getFocusedStack(); &#125; boolean result = false; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (isFrontStack(stack)) &#123; if (stack == targetStack) &#123; result = stack.resumeTopActivityLocked(target, targetOptions); &#125; else &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result; &#125; 1234567891011121314151617181920212223242526272829303132333435final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; ActivityRecord next = topRunningActivityLocked(null); …… mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); …… //暂停当前执行的activity 为栈顶activity启动坐准备 boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving); if (mResumedActivity != null) &#123;//当前正在执行的activity pausing = true; startPausingLocked(userLeaving, false);//暂定activity &#125; …… if (prev != null) &#123; &#125;else&#123; if (mNoAnimActivities.contains(next)) &#123;//如果next不包含入场动画 anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); if (next.app != null &amp;&amp; next.app.thread != null) &#123; …… &#125;else&#123; …… mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125; 这组方法用来恢复启动task栈顶的activity，其中next即我们要执行的activity，它已经被放在了task栈顶，这里如果next已经在相关的休眠或者停止队列中需要将其从中移除，并重置sleeping状态，这些都是为next的启动做准备。这里最重要的一步就是需要将当前正在执行的mResumedActivity 暂停，这样才能执行task栈顶的activity .这是通过startSpercificActivityLocked来执行的。 12345678910111213 void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; …… &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); &#125; 这个方法用来启动我们具体的activity，首先获取activity对应的进程信息ProcessRecord，由于Launcher启动，activity的进程还未创建，所以这里需要为activity创建进程。 123456789private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; …… //为服务或者activity创建新的进程 通过zygote进程执行 创建完成后回调ActivityThread并执行其main方法 Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\", app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, null); ……&#125; 到这里会通过zygote为activity创建进程，这是通过和zygote进程通过socket通信来完成的，zygote为Activity创建进程后，会调用ActivityThread的main方法。 我们看看ActivityThread的main方法 12345678910111213141516public static void main(String[] args) &#123; …… Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 进程启动后需要创建要给ActivityThread对象，并调用其attach方法。在attach方法中会做许多初始工作。从main方法可以看到进程的主线程是作为ui线程的。 12345678910111213private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; …… IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;else&#123;……&#125;&#125; 在attach方法中会调用AMS的attachApplicaton，这里的mAppThread是我们的ApplicationThread对象，它是一个binder服务,在ActivityThread对象创建的时候生成，它在这里传递给AMS，这样AMS就可以使用其代理binder来和应用程序进行通信。比如activity众多的生命周期事件是通过这个binder对象通知应用端的。 123456789 @Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//进一步调用 Binder.restoreCallingIdentity(origId); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; app.makeActive(thread, mProcessStats); …… thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profileFile, profileFd, profileAutoStop, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(), mCoreSettingsObserver.getCoreSettingsLocked()); …… if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app, mHeadless)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ……&#125; 这里AMS做一些初始化工作后 又会调用到应用端的bindApplication。应用端会在这个时机为应用创建Application对象，随后AMS分别调用mStackSupervisor和mServices的attachApplicationLocked，这里会将等待启动的acitivty或者service启动起来。后面我们继续分析 12345678910111213public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; …… sendMessage(H.BIND_APPLICATION, data); &#125; 这里会通过H对象 其实是个handler 来发送BIND_APPLICATION消息，这会调用handleBindApplication方法来处理该消息。 12345678private void handleBindApplication(AppBindData data) &#123; …… Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; …… mInstrumentation.callApplicationOnCreate(app); ……&#125; 在应用端的handleBindApplication时会为应用创建application对象，同时调用onCreate回调。 12345678910111213141516171819202122232425262728293031boolean attachApplicationLocked(ProcessRecord app, boolean headless) throws Exception &#123; boolean didSomething = false; final String processName = app.processName; for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = mStacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (headless) &#123; &#125; else if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception in new application when starting activity \" + hr.intent.getComponent().flattenToShortString(), e); throw e; &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething; &#125; AMS回调完成应用端的application初始化后，会进一步调用attachApplicationLocked来继续执行activity的任务。在这个方法中首先取到前台的ActivityStack，然后找到task栈顶的activity，最后通过realStartActivityLocked来真正的启动hr所代表的activity. 1234567891011121314151617181920frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; …… mWindowManager.setAppVisibility(r.appToken, true); …… r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); …… app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, app.repProcState, r.icicle, results, newIntents, !andResume, mService.isNextTransitionForward(), profileFile, profileFd, profileAutoStop); ……&#125; 到这一步，WMS会将app的设置为可见，这里是将r.appToken作为key的，这个appToken是我们在为activity创建ActivityRecord时创建的，它作为一个Binder用来在WMS端标记我们的activity,同时也可以和WMS通信。随后通知应用端开始加载Activity,App.thread就是我们的ApplicationThread，它是在进程创建后，应用端的binder server，主要被AMS使用和应用端的通信。 12345678910111213141516171819202122232425262728293031public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token;//token? 这个token实际上就是ActivityRecord的appToken 代表了待启动的Activity r.ident = ident; r.intent = intent; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profileFile = profileName; r.profileFd = profileFd; r.autoStopProfiler = autoStopProfiler; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在scheduleLaunchActivity中构造了一个 ActivityClientRecord对象，随后发送H_LAUNCH_ACTIVITY，然后调用handleLaunchActivity。 123456789101112private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //紧接着执行resume activity的流程 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); …… &#125; ……&#125; 到这里就开始加载activity，首先是调用performLaunchActivity，这里面会去调用onCreate和onStart等回调，而handleResumeActivity中会将activity显示出来，并调用onResume回调。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; …… java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建activi的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); …… if (activity != null) &#123; //为activity创建context 实际上为contextImpl Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); //调用activity的attach进行初始化 activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //回调onCreate mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart();//onStart回调 r.stopped = false; &#125; …… &#125; r.paused = true; mActivities.put(r.token, r);&#125; 这个方法主要创建activity对象，并为其创建context，实际上为contextImpl，通过attach方法将context设置到activity中。同时为activity设置window，即PhoneWindow. 随后回调onCreate，onStart等方法。 123456789101112131415161718192021final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ActivityClientRecord r = performResumeActivity(token, clearHide); …… if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView();//取到decorView decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager();//取到WindowManager实际为WindowManagerImpl WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;//window类型 测量Z序会用到 l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l);//这里会添加window到WMS中 &#125; &#125; ……&#125; 到这里就真正的将activity相应的window添加到了WMS中，activity被显示在桌面上。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"Vsync信号图形绘制-Choreographer源码分析","slug":"aosp-choreographer","date":"2017-09-10T12:30:20.000Z","updated":"2018-05-19T10:14:31.597Z","comments":true,"path":"2017/09/10/aosp-choreographer/","link":"","permalink":"http://esligh.github.io/2017/09/10/aosp-choreographer/","excerpt":"","text":"Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。 Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vsync信号。垂直信号到来后就要开始准备绘制下一帧的数据。Choreographer主要是在ViewRootImpl中使用的，ViewRootImpl是view树的管理者，负责view树的逻辑处理及事件事件输入。 所有的绘制流程是从ViewRootImpl.java的scheduleTraversals开始的，这个方法会去请求vsync信号，并在信号到来时去绘制更新ui。 12345678910void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //请求vsync信号，当vsync信号到达后开始mTraversalRunnable任务,垂直信号的接受由ChoreoGrpaher负责 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); …… &#125;&#125; 这里我们不关心具体的绘制过程，主要是看Choreographer如何通过vysnc信号来协调界面的绘制。 这里首先是通过Choreographer对象mChoreographer对象post了一个回调，告诉Choreographer当vsync信号到达时帮我调用mTraversalRunable回调。这个回调的定义如下： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal();//vsync信号到达后执行绘制流程 &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); doTraversal()内部会调用performTraversals()方法，从而开启view绘制的三大流程。 下面我们看看Choreographer是如何将vsync接受信号并告之ViewRoomImpl的刷新回调的。我们就从这个postCallback入手分析。 12345678910111213141516171819202122232425262728public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; …… postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;//post一个延时回调private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //将请求的回调按照相应的类型添加到回调队列中，这里会根据一个失效时间来构造 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123;//延时为0时调用 ，对于scheduleTraversals走这里 scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; postCallback最终会调用postCallbackDelayedInternal，参数delayMillis为0，所以会调用scheduleFrameLocked进一步进行操作。这里需要注意的是每次请求都会添加到其类型对应的回调队列中， 这里的mCallbackQueues是一个根据类型区分的回调队列，有四种类型，分别是输入回调，动画回调和绘制回调以及Choreographer.CALLBACK_COMMIT。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123;//使用vsync信号更新 if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame on vsync.\"); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123;//通过ui线程发送请求等待一个vsync信号 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125;``` 这个USE_VSYNC代表我们系统使用vsync信号进行屏幕信号的同步，这个方法是在我们的ui线程操作的，所以会发送MSG_DO_SCHEDULE_VSYNC请求vsync信号。这里的mHandler是一个FrameHandler```javaprivate final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync();//请求vsync信号 break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 接着调用doScheduleVsync 1234567void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125; 123private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();//请求vsync信号&#125; 这里的mDisplayEventReceiver是一个FrameDisplayEventReceiver对象，它继承了DisplayEventReceiver，其中实现了其方法onVsync，这个方法就是当onVsync信号到达时的回调方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//垂直信号到达@Overridepublic void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won't send us vsyncs for secondary displays // but that could change in the future so let's log a message to help us remember // that we need to fix this. //并不是sf内置的display if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, \"Received vsync from secondary display, but we don't support \" + \"this case yet. Choreographer needs a way to explicitly request \" + \"vsync for a specific display to ensure it doesn't lose track \" + \"of its scheduled vsync.\"); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, \"Frame time is \" + ((timestampNanos - now) * 0.000001f) + \" ms in the future! Check that graphics HAL is generating vsync \" + \"timestamps using the correct timebase.\"); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, \"Already have a pending vsync event. There should only be \" + \"one at a time.\"); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125;@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);//垂直信号到来触发&#125;&#125; 垂直信号vsync到来后会触发doFrame，在这个方法里面会进行我们的回调，即mTraversalRunnable。 12345678910111213141516171819202122void doFrame(long frameTimeNanos, int frame) &#123; …… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);//回调输入事件的相关回调 mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);//回调动画相关的回调 mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);//回调绘制相关的回调 doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ……&#125; 123456789101112131415161718192021222324void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS);//获取相关类型的回调 if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true;…… try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"RunCallback: type=\" + callbackType + \", action=\" + c.action + \", token=\" + c.token + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos);//调用回调 &#125; &#125; ……&#125; 这里会根据类型从队列中取出相应的回调进行调用。这个就是上层对于vsync的处理。接下来我们看看底层的vsync信号是如何传递给Choreographer的。这就需要看看FrameDisplayEventReceiver的父类DisplayEventReceiver，这个DisplayEventReceiver会通过native层进行初始化，native层通过它的成员方法dispatchVsync将vsync信号报告给上层，即调用onVsync。我们先看其构造方法: 1234567891011public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException(\"looper must not be null\"); &#125; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource);//初始化接收器 mCloseGuard.open(\"dispose\");&#125; 其构造方法是调用nativeInit进行初始化的，并将当前对象this作为一个接收器传递给底层。我们看看这个方法 123456789101112131415161718192021222324frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp//注册显示事件接收器 receiverWeak即DisplayEventReceiverstatic jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj, jint vsyncSource) &#123; //这个messageQueue是通过ui线程的Looper构造的 sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, \"MessageQueue is not initialized.\"); return 0; &#125; sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue, vsyncSource);//创建本地接收器 status_t status = receiver-&gt;initialize();//初始化native的接受器 if (status) &#123; String8 message; message.appendFormat(\"Failed to initialize display event receiver. status=%d\", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 在初始化方法中会创建本地的接受器对象，它同时是用我们传递的java层的接受器对象构造的，构造完成后即进行初始化。这个NativeDisplayEventReceiver的定义如下 12345678910111213141516171819//native的显示事件接受器class NativeDisplayEventReceiver : public DisplayEventDispatcher &#123;public: NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource); void dispose();protected: virtual ~NativeDisplayEventReceiver();private: jobject mReceiverWeakGlobal;//java层的接收器对象 sp&lt;MessageQueue&gt; mMessageQueue; DisplayEventReceiver mReceiver; virtual void dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count); virtual void dispatchHotplug(nsecs_t timestamp, int32_t id, bool connected);&#125;; NativeDisplayEventReceiver继承自DisplayEventDispatcher，而DisplayEventDispatcher又实现了LooperCallback的接口handleEvent，这个方法是Looper的事件回调，也就是当Looper接受到消息后会对其进行调用，那么这个DisplayEventDispatcher就是负责进行消息事件的转发的。后面我们看看它是如何将vsync信号转发的。 12345678910111213141516//初始化receiverstatus_t DisplayEventDispatcher::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(\"Failed to initialize display event receiver, status=%d\", result); return result; &#125; int rc = mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL);//添加事件侦听,这里的this代表注册的是一个LooperCallback, //当事件到达后会调用其handleEvent方法,这个可以具体参见Looper的实现 if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 这里的addFd将其注册到为Looper的事件回调，注意这里第四个参数this，因为DisplayEventDispatcher是继承LooperCallback的。这样当事件到来后会调用handleEvent。 还有，在NativeDisplayEventReceiver的内部持有一个DisplayEventReceiver对象，这个对象比较重要，它是负责和Sf打交道的。 1234567891011DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != NULL) &#123; //通过sf建立连接，这里就应该很熟悉了，这个连接创建好后在第一次引用时会去注册到EventThread中 mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource); if (mEventConnection != NULL) &#123; mDataChannel = std::make_unique&lt;gui::BitTube&gt;(); mEventConnection-&gt;stealReceiveChannel(mDataChannel.get()); &#125; &#125;&#125; 12345678sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection( ISurfaceComposer::VsyncSource vsyncSource) &#123; if (vsyncSource == eVsyncSourceSurfaceFlinger) &#123; return mSFEventThread-&gt;createEventConnection(); &#125; else &#123;//如果时app端的就走这里 return mEventThread-&gt;createEventConnection(); &#125;&#125; 刚刚说到DisplayEventReceiver是和Sf打交道的， 它和NativeDisplayEventReceiver是同时创建的。在其构造方法中首先通过sf的createDisplayEventConnection创建一个连接对象即Connection对象，mEventThread是管理绘图延时对象的vsync信号处理，它是一个EventThread。Connection就是由它创建的。 123sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));//创建一个新的连接，这个连接在第一个被引用时会去进行注册&#125; 这个connection在第一次被引用时会进行注册，即将其添加到mEventThread的连接队列，在vsync消息到来时调用其postEvent方法对事件进行转发。 1234567891011121314151617181920212223242526272829303132333435void EventThread::Connection::onFirstRef() &#123; // NOTE: mEventThread doesn't hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125;//注册创建的连接，实际上时将创建的连接添加到监听队列，并通知等待的线程status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; Mutex::Autolock _l(mLock); mDisplayEventConnections.add(connection);//添加到连接队列中 mCondition.broadcast();//唤醒等待的线程 return NO_ERROR;&#125;bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event);//post事件 …… &#125; return true;&#125;status_t EventThread::Connection::postEvent( const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; postEvent实际上会调用DisplayEventReceiver的setEvents方法，这样会触发getEvents的回调从而通过DisplayEventDispatcher的handleEvent回调方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel, Event const* events, size_t count)&#123; return gui::BitTube::sendObjects(dataChannel, events, count);//发送接受到的事件&#125;int DisplayEventDispatcher::handleEvent(int, int events, void*)&#123; …… // Drain all pending events, keep the last vsync. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;//丢弃所有的等待事件，只保留上次的vsync信号事件 ALOGV(\"dispatcher %p ~ Vsync pulse: timestamp=%\" PRId64 \", id=%d, count=%d\", this, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount); mWaitingForVsync = false; dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);//分派vsync信号 &#125; return 1; // keep the callback&#125;bool DisplayEventDispatcher::processPendingEvents( nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123;//等待事件到来 ALOGV(\"dispatcher %p ~ Read %d events.\", this, int(n)); for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // Later vsync events will just overwrite the info from earlier // ones. That's fine, we only care about the most recent. gotVsync = true; *outTimestamp = ev.header.timestamp;//timestamp *outId = ev.header.id;//id *outCount = ev.vsync.count;//count break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; &#125; &#125; return gotVsync;&#125;&#125;void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal)); if (receiverObj.get()) &#123; ALOGV(\"receiver %p ~ Invoking vsync handler.\", this); env-&gt;CallVoidMethod(receiverObj.get(), gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); ALOGV(\"receiver %p ~ Returned from vsync handler.\", this); &#125; mMessageQueue-&gt;raiseAndClearException(env, \"dispatchVsync\");&#125; 最终调用NativeDisplayEventReceiver的dispatchVsync回调给java层的dispatchVsync，这样vsync信号就传递给上层应用了。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://esligh.github.io/categories/AOSP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"SparseArray源码分析","slug":"android-libray-sparsearray-src","date":"2017-07-19T11:23:50.000Z","updated":"2018-05-19T11:53:20.674Z","comments":true,"path":"2017/07/19/android-libray-sparsearray-src/","link":"","permalink":"http://esligh.github.io/2017/07/19/android-libray-sparsearray-src/","excerpt":"","text":"SparseArray，SparseIntArray,SparseBooleanArray等是Android官方提倡使用的高效数据结构。它同java中的HashMap类似属于存储键值对的集合。但同HashMap相比它更加轻量，执行效率更高。下面我们就对SparseArray的源码进行解读，了解它内部的执行原理。 构造方法 在KitKat中的源码位置： frameworks/base/core/java/android/util/SparseArray.java 首先我们从其构造函数入手 1234567891011121314151617181920212223242526public class SparseArray&lt;E&gt; implements Cloneable &#123; private static final Object DELETED = new Object(); private boolean mGarbage = false; private int[] mKeys; private Object[] mValues; private int mSize; public SparseArray() &#123; this(10); &#125; public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = ContainerHelpers.EMPTY_INTS; mValues = ContainerHelpers.EMPTY_OBJECTS; &#125; else &#123; initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity); mKeys = new int[initialCapacity]; mValues = new Object[initialCapacity]; &#125; mSize = 0; &#125; ……&#125; 初始化时传递的initialCapacity大小为10，但这个只是一个参考值，随后又通过ArrayUtils.idealIntArraySize对初始值进行了调整，从函数名字上看这个方法会根据参考值返回一个比较理想容量大小。我们看看它是如何计算的 1234567891011public static int idealIntArraySize(int need) &#123; return idealByteArraySize(need * 4) / 4;&#125;public static int idealByteArraySize(int need) &#123; for (int i = 4; i &lt; 32; i++) if (need &lt;= (1 &lt;&lt; i) - 12) return (1 &lt;&lt; i) - 12; return need;&#125; 计算的结果是一个2的幂次方的数减去12，对于SparseArray还需要再除以4作为结果返回，这里返回的值为 (1&lt;&lt;6-12)/4 = 13 。 这里有个疑惑就是为什么需要对初始值进行重新计算得到SparseArray的容量大小？ 获取元素 可以看出SparseArray内部是通过数组来实现的，相比hashMap的hash表和链表要轻量一些。我们先看看它的get方法如何实现 12345678910111213public E get(int key) &#123; return get(key, null);&#125;public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125;&#125; 内部逻辑非常简单，通过key来进行二分查找，这么说键值在mKeys中的存储是有序的。 这就要求在添加元素中做保证。这里二分搜索的结果是key值所在的索引值i，这个索引在mValues中对应的数据就是key对应的值，可见mKeys和mValues是一一对应的，只是分别存储在两个数组中罢了。这里如果查找到会返回索引值i，如果i小于0说明没有找到，同时如果i所在的value已经失效即为DELETE，则也算没有找到value值，返回默认的valueIfKeyNotFound，否则返回mValues[i]作为结果。 frameworks/base/core/java/android/util/ContainerHelpers.java 123456789101112131415161718static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; final int mid = (lo + hi) &gt;&gt;&gt; 1; final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present&#125; 二分搜索，这里就不需要做解释了，需要注意的是如果找到了key值，则返回其在array中的索引mid，否则返回~lo，lo代表了所查找key值所应该存在的位置，这里取反是为了说明key值不存在该位置，但如果需要添加key值对应的value就可以将其放在lo处。 添加元素 我们知道二分搜索是基于有序序列进行的操作，那么在我们添加元素也就是put时需要保证数组的有序性，我们接下来看看put的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; if (mSize &gt;= mKeys.length) &#123; int n = ArrayUtils.idealIntArraySize(mSize + 1); int[] nkeys = new int[n]; Object[] nvalues = new Object[n]; // Log.e(\"SparseArray\", \"grow \" + mKeys.length + \" to \" + n); System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length); System.arraycopy(mValues, 0, nvalues, 0, mValues.length); mKeys = nkeys; mValues = nvalues; &#125; if (mSize - i != 0) &#123; // Log.e(\"SparseArray\", \"move \" + (mSize - i)); System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i); System.arraycopy(mValues, i, mValues, i + 1, mSize - i); &#125; mKeys[i] = key; mValues[i] = value; mSize++; &#125;&#125; put同样一开始先binarySearch查找key值是否已经存在，如果存在，只需更新索引i处的value。 否则我们对i进行取反，这里取反后的i值我们知道就是key值应该存放的位置。 随后判断i是否小于mSize 且 mValues对应i处的值已经失效，如果失效了就直接替换该处的值即可。否则看是否需要进行gc(看mGarbage是否置为true且当前的数组已经满了)，这里的gc是指对失效元素进行回收，并重新计算大小。gc完后会再次计算key值索引，因为数组大小可能发生了变化。 如果gc后数组依旧时满的，这就需要我们再开辟空间了，同样调用ArrayUtils.idealIntArraySize重新计算容量，然后创建数组，并将mKeys和mValues拷贝到新的数组中。 如果mSize-i！=0 说明要在数组间插入key值，这个需要将索引i后的元素统一向后挪动一个位置为key值腾出一个位置。 将key值对应的value分别放在mKeys和mValues中并递增mSize。 gc的回收策略 1234567891011121314151617181920212223private void gc() &#123; int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o;&#125; gc负责将已经清理失效的value(即等于DELETED)，并重新计算mSize。 在SparseArray的众多方法中都有可能调用gc方法比如size,keyAt,valueAt等等，以此来分摊可能进行的gc的执行时间。 在SparseArray中还有一个比put更加高效的方法append,它首先判断key值是否比数组末尾的key值还要大，如果是的话就只需将其添加到末尾就行了，因为它保证了有序性。否则就调用put来添加该key-value。 1234567891011121314151617181920212223242526272829public void append(int key, E value) &#123; if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) &#123; put(key, value); return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); &#125; int pos = mSize; if (pos &gt;= mKeys.length) &#123; int n = ArrayUtils.idealIntArraySize(pos + 1); int[] nkeys = new int[n]; Object[] nvalues = new Object[n]; // Log.e(\"SparseArray\", \"grow \" + mKeys.length + \" to \" + n); System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length); System.arraycopy(mValues, 0, nvalues, 0, mValues.length); mKeys = nkeys; mValues = nvalues; &#125; mKeys[pos] = key; mValues[pos] = value; mSize = pos + 1;&#125; SparseArray的delete方法同样是它高效的体现，它并不真正的将key-value从数组中移除，而仅仅是将value标记为失效，同时把mGarbage置为true代表需要进行gc,这样做原因是，随后可能存在key值又加入进来的情况，这样我们就仅需将已经失效的元素换成我们添加的value值即可，可以参见Put方法的第二步说明。这样避免了数组的频繁抖动引起的性能问题。 123456789public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125;&#125;","categories":[{"name":"Android library","slug":"Android-library","permalink":"http://esligh.github.io/categories/Android-library/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]},{"title":"ArrayList源码分析","slug":"jdk-arraylist-src","date":"2017-07-19T11:23:50.000Z","updated":"2018-05-19T11:43:53.454Z","comments":true,"path":"2017/07/19/jdk-arraylist-src/","link":"","permalink":"http://esligh.github.io/2017/07/19/jdk-arraylist-src/","excerpt":"","text":"继承关系 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList是开发者广泛使用的java集合，它继承自AbstractList 实现了List接口，支持随机访问以及拷贝，持久化。 本篇主要对ArrayList的实现进行分析，首先我们看它的构造方法 1234567891011121314151617181920public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; ArrayList的构造方法很简单，主要是初始化elementData值，它是一个Object数组用来存储我们的元素。根据参数的不同实现也不同。 元素添加 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 首先调用ensureCapacityInternal来确保有足够的容量来存储e,随后将e保存在elementData数组中并增加size值 默认返回true。 在指定索引处添加元素 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 这个方法将元素element添加到数组中指定的index位置，所以效率上比add要慢，因为可能需要对数组元素进行挪动。同样这里需要保证足够的空间，并在添加完成后增加size计数。 我们看看ensureCapacityInternal是如何保证容量大小的 1234567891011121314151617181920212223242526private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; DEFAULT_CAPACITY默认为10，也就是说第一次添加到ArrayList的时候会开辟大小为10的数组。如果需要的大小大于当先数组的大小需要调用grow来完成容量的增加。 grow的resize逻辑如下： 计算新的容量大小为 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) 这个新的容量为原来的3倍。 如果新的容量小于我们需要的 则以我们需要的为准开辟空间 如果新的容量大于最大可以开辟的容量值(Integer.MAX_VALUE - 8)，那么需要hugeCapacity进行大容量的分配 使用Arrays的copyOf将原数组resize到指定大小","categories":[{"name":"JDK源码分析","slug":"JDK源码分析","permalink":"http://esligh.github.io/categories/JDK源码分析/"}],"tags":[{"name":"java","slug":"java","permalink":"http://esligh.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"http://esligh.github.io/tags/jdk/"}]},{"title":"AQS同步机制源码分析","slug":"jdk-aqs-src","date":"2016-08-25T13:00:07.000Z","updated":"2018-05-19T11:32:53.183Z","comments":true,"path":"2016/08/25/jdk-aqs-src/","link":"","permalink":"http://esligh.github.io/2016/08/25/jdk-aqs-src/","excerpt":"","text":"本篇我们主要分析AQS独占模式的源码，关于AQS的独占模式我们上一篇有所介绍。主要这里我们介绍acquire和release部分的代码。这会涉及到AQS的阻塞唤醒机制，还有其维护的FIFO队列。 阻塞过程 独占模式下的阻塞过程 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire返回boolean值，true代表状态更新成功线程继续，否则当前线程需要阻塞，并添加到队列中。这里addWaiter会为当前线程创建Node并添加到队列中。因为是独占模式节点模式为Node.EXCLUSIVE。 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; addWaiter中首先创建线程节点node,如果tail不为null说明队列不为空，通过CAS将node添加到队尾，然后返回，否则需要调用enq创建队列。 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; enq会创建队列，通过CAS创建头尾节点，然后将node添加进去返回。 我们看看AQS中队列的节点信息 12345678910111213/** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; AQS队列是通过head和tail节点来维护的，其中Node节点分别有前驱和后继节点。 它是一个简单的队列结构，而保证线程节点能够正确添加到队列中正是基于CAS，这使得它是一个非阻塞式的队列。 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg)&#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 添加Node到队列中后，有可能会阻塞当前线程，这里获取当前node的前驱，如果前驱是head表示当前线程已经变成队列中的第一个元素，并再次尝试tryAcquire，如果返回true表示同步状态更新成功则返回。如果不是第一个元素，则通过shouldParkAfterFailedAcquire判断是否应该park当前线程，返回true表示应该阻塞线程。 123456789101112131415161718192021222324252627private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 这里只有当node的前驱节点的waitStatus为Node.SIGNAL时才会返回true，此时表示前驱节点会unPark node节点的线程，所以可以park这个线程。如果前驱节点不满足这个条件，就需要查找一个不为CANCELED的节点作为node的前驱，并更新它的waitStatus为SIGNAL。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 线程的阻塞是在parkAndCheckInterrupt中进行的，阻塞使用了LockSupport的park。这样当前线程就阻塞在acquireQueued的for循环中等待被唤醒。 共享模式下的阻塞过程 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 在共享模式下的逻辑类似于独占模式，tryAcquireShared返回负值代表未获取到同步状态需要阻塞，这里是通过doAcquireShared来完成的。 123456789101112131415161718192021222324252627282930313233343536373839404142private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;``` 不同于独占模式下的阻塞模式，这里首先针对当前线程创建Node.SHARED节点，使用addWaiter添加到阻塞队列中，随后的逻辑基本和独占模式类似，即通过一个循环来判断当前节点是否满足唤醒的条件:1 当前节点是阻塞队列的第一个节点，且再次通过tryAcqurireShared获取到了同步状态，对于共享模式来说即满足 r&gt;=0，随后将本节点node设置为头结点根据需要设置中断返回。阻塞的逻辑同独占模式下，这里就不再赘述。## 唤醒操作```javapublic final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 当子类的实现tryRelease返回true表示释放了同步状态，这时候就可以唤醒当前node节点所代表线程的后继节点了。这一步是通过unparkSuccessor实现的。 1234567891011121314151617181920212223242526private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 这里取到当前队列的下一个node节点，并通过LockSupport.unpark解除相应线程的阻塞状态。","categories":[{"name":"JDK源码分析","slug":"JDK源码分析","permalink":"http://esligh.github.io/categories/JDK源码分析/"}],"tags":[{"name":"java","slug":"java","permalink":"http://esligh.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"http://esligh.github.io/tags/jdk/"}]},{"title":"Volley网络库源码分析","slug":"android-libray-volley-src","date":"2015-11-19T13:32:18.000Z","updated":"2018-05-19T14:42:33.077Z","comments":true,"path":"2015/11/19/android-libray-volley-src/","link":"","permalink":"http://esligh.github.io/2015/11/19/android-libray-volley-src/","excerpt":"","text":"综述 volley有三个层次的线程，分别为main thread、cache thread 以及network thrads。RequestQueue会维护一个缓存调度线程和一个网络调度线程，当一个Request被加入到队列中时，cache线程会对其进行筛选，如果这个请求的内容可以在缓存中找到，cache线程会亲自解析相应内容，并分发到UI线程。如果缓存中没有，这个请求就会被加入到NetWorkQueue中，所有真正准备进行网络通信的Request都在这里，第一个可用的net线程会从Queue中取出一个请求发送给服务器。当响应数据到的时候，这个net线程会解析原始响应数据并缓存，随后将解析的结果发送给主线程。 基本使用 首先在使用中，我们会在应用中创建一个请求队列 1mRequestQueue = Volley.newRequestQueue(this); newRequestQueue的实现如下： 123456789101112131415161718192021//volley.javapublic static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = \"volley/0\"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + \"/\" + info.versionCode; &#125; catch (NameNotFoundException e) &#123;&#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue;&#125; 在创建请求队列中，我们还会创建一个BasicNetWork 这是volley使用的网络请求库，通过一个httpstack 对象来初始化，HttpStack是一个网络请求的接口。可以看到，在SDK版本小于9时默认使用的是HttpClient ，否则就用HttpUrlConnection当做其请求库。随后创建完queue后就启动该请求队列。在看start之前我们先看看RequestQueue类 1234567891011121314151617181920212223242526272829303132333435363738394041public class RequestQueue &#123; /** Used for generating monotonically-increasing sequence numbers for requests. */ private AtomicInteger mSequenceGenerator = new AtomicInteger(); /** * Staging area for requests that already have a duplicate request in flight. * * &lt;ul&gt; * &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache * key.&lt;/li&gt; * &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request * is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt; * &lt;/ul&gt; */ private final Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&gt;&gt;(); /** * The set of all requests currently being processed by this RequestQueue. A Request * will be in this set if it is waiting in any queue or currently being processed by * any dispatcher. */ private final Set&lt;Request&gt; mCurrentRequests = new HashSet&lt;Request&gt;();//请求队列 /** The cache triage queue. */ private final PriorityBlockingQueue&lt;Request&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&gt;(); //缓存阻塞队列 /** The queue of requests that are actually going out to the network. */ private final PriorityBlockingQueue&lt;Request&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&gt;(); //网络请求阻塞队列 /** Number of network request dispatcher threads to start. */ private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4; //默认线程池大小 /** Cache interface for retrieving and storing respones. */ private final Cache mCache; //使用的缓存对象 /** Network interface for performing requests. */ private final Network mNetwork; //使用的网络请求对象 /** Response delivery mechanism. */ private final ResponseDelivery mDelivery;//转发器 /** The network dispatchers. */ private NetworkDispatcher[] mDispatchers; //网络调度线程 /** The cache dispatcher. */ private CacheDispatcher mCacheDispatcher; //缓存调度线程 ...&#125; RequestQueue包含了多个队列和调度器以及一个ResponseDelivery转发器，这里NetworkDispatcher和CacheDispatcher都是继承自Thread类。 构造方法 123456789101112public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123; mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery;&#125;public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 再来看start方法： 1234567891011121314 //RequestQueue.javapublic void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; 在start中，创建了缓存调度线程（一个）和网络调度线程（四个）,并启动它们。也就是说，在我们创建了请求队列后，就有5个线程在后台运行，不断等待网络请求的到来。 我们创建好请求队列后，我们一般会add到该队列，所以看下add的源码 12345678910111213141516171819202122232425262728293031323334353637public Request add(Request request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this);//设置请求所属队列 synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request);//添加该请求 &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber());//得到该请求序列 request.addMarker(\"add-to-queue\"); // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) &#123; //判断是否可缓存 mNetworkQueue.add(request);//不可缓存的话就直接添加到网络请求队列中 return request; &#125; // Insert request into stage if there's already a request with the same cache key in flight. synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey();//得到请求的key，实际上就是请求的url if (mWaitingRequests.containsKey(cacheKey)) &#123; //等待请求map表中已经存在该请求了 // There is already a request in flight. Queue up. Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);//获取该请求对应的等待队列 if (stagedRequests == null) &#123; stagedRequests = new LinkedList&lt;Request&gt;(); &#125; stagedRequests.add(request); //添加请求进来 mWaitingRequests.put(cacheKey, stagedRequests);//重置请求的map if (VolleyLog.DEBUG) &#123; VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey); &#125; &#125; else &#123; //请求目前还未添加进缓存队列 // Insert 'null' queue for this cacheKey, indicating there is now a request in // flight. mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); //添加到缓存队列 &#125; return request; &#125;&#125; 这里主要针对需要缓存的request说下，volley默认的request是需要缓存的，在需要缓存是，主要针对mWaitingRequests这个map表进行操作。这map表主要用来记录对应每个请求目前的请求队列，因为volley在网络出现问题后会对再次request进行重试，而重试的次数是可以设置的，重试一旦超过设置值就会超时。这里用mWaitingRequests就是来记录重试队列的。 在应用层添加完request后，缓存调度线程就可以处理这个request了，所以看看CacheDispatcher的run方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//CacheDispatcher @Overridepublic void run() &#123; if (DEBUG) VolleyLog.v(\"start new dispatcher\"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. mCache.initialize(); //缓存初始化 while (true) &#123; try &#123; // Get a request from the cache triage queue, blocking until // at least one is available. final Request request = mCacheQueue.take(); //取一个请求出来 request.addMarker(\"cache-queue-take\"); // If the request has been canceled, don't bother dispatching it. if (request.isCanceled()) &#123; //如果被取消了就continue request.finish(\"cache-discard-canceled\"); continue; &#125; // Attempt to retrieve this item from cache. Cache.Entry entry = mCache.get(request.getCacheKey()); //取该request对应的缓存 if (entry == null) &#123; request.addMarker(\"cache-miss\"); // Cache miss; send off to the network dispatcher. mNetworkQueue.put(request); //没有缓存就直接添加到网络请求队列中，然后continue continue; &#125; // If it is completely expired, just send it to the network. if (entry.isExpired()) &#123; //缓存是否过期 request.addMarker(\"cache-hit-expired\"); request.setCacheEntry(entry); mNetworkQueue.put(request); //如果过期，同样需要添加到网络请求队列中 continue; &#125; // We have a cache hit; parse its data for delivery back to the request. request.addMarker(\"cache-hit\"); //这里就算缓冲命中了 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(\"cache-hit-parsed\"); if (!entry.refreshNeeded()) &#123; // Completely unexpired cache hit. Just deliver the response. mDelivery.postResponse(request, response); //通过转发器递交响应给Main Thread &#125; else &#123; //缓存命中了，但是需要刷新的情况 // Soft-expired cache hit. We can deliver the cached response, // but we need to also send the request to the network for // refreshing. request.addMarker(\"cache-hit-refresh-needed\"); request.setCacheEntry(entry); // Mark the response as intermediate. response.intermediate = true; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. //先递交响应给main thread 随后在将该请求添加到网络请求队列以刷新缓存 mDelivery.postResponse(request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Not much we can do about this. &#125; &#125; &#125;); &#125; &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; &#125; &#125; 总体来说CacheDispatcher的处理流程很简单 ，主要的内容在注释我做了说明。在取到一个request后，需要该请求是否存在缓存，该缓存是否过期，是否需要刷新等问题。 接下来在看看NetworkDispatcher这个网络调度线程，它的任务就是从网络请求队列中取出request进行网络请求了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 @Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Request request; while (true) &#123; try &#123; // Take a request from the queue. request = mQueue.take(); //取出一个请求 &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker(\"network-queue-take\"); // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; //如果被取消了continue request.finish(\"network-discard-cancelled\"); continue; &#125; // Tag the request (if API &gt;= 14) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; TrafficStats.setThreadStatsTag(request.getTrafficStatsTag()); &#125; // Perform the network request. //通过网络请求库向服务器请求数据，响应保存在networkResponse中 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); // If the server returned 304 AND we delivered a response already, // we're done -- don't deliver a second identical response. //响应请求的内容为被修改，服务器会返回304的响应码 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); continue; &#125; // Parse the response here on the worker thread. //对相应进行解析，这里调用的parseNetworkResponse在request子类中实现 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; //需要缓存 mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; // Post the response back. request.markDelivered(); mDelivery.postResponse(request, response); //转发器投递响应到主线程 &#125; catch (VolleyError volleyError) &#123; parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, \"Unhandled exception %s\", e.toString()); mDelivery.postError(request, new VolleyError(e)); &#125; &#125; &#125; 可以看到网络请求线程的处理更加简单，主要就是从网络请求队列中取出reqeust进行网络请求，并根据设置将响应保存在缓存中，最后转发响应到主线程中。 我们看到在缓存调度线程和网络调度线程中都使用到了ResponseDelivery对象将结果投递到主线程，这里我们看看这个Delivery 。事实上，ResponseDelivery只是一个接口，我们在创建RequestQueue时使用的ExecutorDelivery它实现了该接口。 1234public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 这里使用通过一个Handler来构造 123456789101112131415161718192021public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;;&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null);&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(\"post-response\"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; Dlivery的有两个重载的PostResponse，在缓存调度线程和网络调度线程都使用了两个参数的，三个参数的用在了缓存需要刷新时的情况，这时我们不仅要将结果投递给主线程而且要刷新缓存（其实只是将请求添加到了网络请求队列中），刷新缓存的操作就是通过第三个参数Runable实现的。 我们看看这个ResponseDeliveryRunnable 123456789101112131415161718192021222324252627282930313233343536private class ResponseDeliveryRunnable implements Runnable &#123; private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123; mRequest = request; mResponse = response; mRunnable = runnable; &#125; @SuppressWarnings(\"unchecked\") @Override public void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish(\"canceled-at-delivery\"); return; &#125; // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); //同样调用两个参数的将响应投递给主线程 &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we're done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker(\"intermediate-response\"); &#125; else &#123; mRequest.finish(\"done\"); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); //调用run方法 &#125; &#125;&#125; 下面我们看看Request类，这个请求类在我们的主线程中使用，是个抽象类，其子类需要实现 12abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);abstract protected void deliverResponse(T response); 分别用来解析响应和转发响应 在Request中，有个RetryPolicy成员通过DefaultRetryPolicy构造，这是个重试策略，主要在用在请求需要重新请求时，我们看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class DefaultRetryPolicy implements RetryPolicy &#123; /** The current timeout in milliseconds. */ private int mCurrentTimeoutMs; /** The current retry count. */ private int mCurrentRetryCount; //当前重试次数 /** The maximum number of attempts. */ private final int mMaxNumRetries; //最大重试次数 /** The backoff multiplier for for the policy. */ private final float mBackoffMultiplier; //备值因子 /** The default socket timeout in milliseconds */ public static final int DEFAULT_TIMEOUT_MS = 2500; /** The default number of retries */ public static final int DEFAULT_MAX_RETRIES = 1; /** The default backoff multiplier */ public static final float DEFAULT_BACKOFF_MULT = 1f; /** * Constructs a new retry policy using the default timeouts. */ public DefaultRetryPolicy() &#123; this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT); &#125; /** * Constructs a new retry policy. * @param initialTimeoutMs The initial timeout for the policy. * @param maxNumRetries The maximum number of retries. * @param backoffMultiplier Backoff multiplier for the policy. */ public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123; mCurrentTimeoutMs = initialTimeoutMs; mMaxNumRetries = maxNumRetries; mBackoffMultiplier = backoffMultiplier; &#125; .... /** * Prepares for the next retry by applying a backoff to the timeout. * @param error The error code of the last attempt. */ @Override public void retry(VolleyError error) throws VolleyError &#123; mCurrentRetryCount++; //重试次数加1 mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);//计算当前超时时间 if (!hasAttemptRemaining()) &#123; throw error; &#125; &#125; /** * Returns true if this policy has attempts remaining, false otherwise. */ protected boolean hasAttemptRemaining() &#123; return mCurrentRetryCount &lt;= mMaxNumRetries; &#125;&#125; 最后我们看看这个RetryPolicy的使用，它主要用在了网络请求类BasicNetWork中，主要看看接口方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = new HashMap&lt;String, String&gt;(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); addCacheHeaders(headers, request.getCacheEntry()); httpResponse = mHttpStack.performRequest(request, headers); //请求数据，获取响应 StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); //获取状态码 responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // Handle cache validation. if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, request.getCacheEntry().data, responseHeaders, true); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusLine); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false); &#125; catch (SocketTimeoutException e) &#123;//socket 超时 attemptRetryOnException(\"socket\", request, new TimeoutError()); &#125; catch (ConnectTimeoutException e) &#123; //连接超时 attemptRetryOnException(\"connection\", request, new TimeoutError()); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException(\"Bad URL \" + request.getUrl(), e); &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; if (httpResponse != null) &#123; statusCode = httpResponse.getStatusLine().getStatusCode(); &#125; else &#123; throw new NoConnectionError(e); &#125; VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl()); if (responseContents != null) &#123; networkResponse = new NetworkResponse(statusCode, responseContents, responseHeaders, false); if (statusCode == HttpStatus.SC_UNAUTHORIZED || statusCode == HttpStatus.SC_FORBIDDEN) &#123;//未认证异常 attemptRetryOnException(\"auth\", request, new AuthFailureError(networkResponse)); &#125; else &#123; // TODO: Only throw ServerError for 5xx status codes. throw new ServerError(networkResponse); &#125; &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; 我们看到performRequest是通过一个while循环来实现的，这是为了在发生请求出错是再次进行重试。在request超时、或者认证失败后都会调用attemptRetryOnException，这里就会进行重试 12345678910111213private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request, VolleyError exception) throws VolleyError &#123; RetryPolicy retryPolicy = request.getRetryPolicy();//获取重试策略 int oldTimeout = request.getTimeoutMs(); //获取超时值 try &#123; retryPolicy.retry(exception);//重试 &#125; catch (VolleyError e) &#123; request.addMarker( String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout)); throw e; &#125; request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout));&#125; 注意这里退出重试循环是通过retry抛出VolleyError异常来结束的 volley的缓存策略 volley的缓存是通过服务端进行控制的，这样的方式比本地存储更加灵活，同服务端进行交互缓存能降低通信量，同时减轻本地缓存的压力。比如之前我们看到了服务端如何通过304的响应码通知内容未修改，这时就不需要再进行请求了。 volley的缓存类是在创建RequestQueue时指定的，这个缓存类以流的方式实现了Cach Entry的存取。所以我们看看这个Entry 12345678910111213141516171819202122public static class Entry &#123; /** The data returned from cache. */ public byte[] data; //缓存的字节流 /** ETag for cache coherency. */ public String etag; /** Date of this response as reported by the server. */ public long serverDate; /** TTL for this record. */ public long ttl; /** Soft TTL for this record. */ public long softTtl; /** Immutable response headers as received from server; must be non-null. */ public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); /** True if the entry is expired. */ public boolean isExpired() &#123; return this.ttl &lt; System.currentTimeMillis(); &#125; /** True if a refresh is needed from the original data source. */ public boolean refreshNeeded() &#123; return this.softTtl &lt; System.currentTimeMillis(); &#125;&#125; 需要说明的是，这个Entry对应我们一个请求的缓存条目，这个是在Request子类根据响应解析出来的。解析类为HttpHeaderParser，当然我们也可以根据需求自己定义类来解析响应得到想要的缓存。下面我们看看这个解析的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//HttpHeaderParser.javapublic static Cache.Entry parseCacheHeaders(NetworkResponse response) &#123; long now = System.currentTimeMillis(); Map&lt;String, String&gt; headers = response.headers; long serverDate = 0; long serverExpires = 0; long softExpire = 0; long maxAge = 0; boolean hasCacheControl = false; String serverEtag = null; String headerValue; headerValue = headers.get(\"Date\"); //得到date if (headerValue != null) &#123; serverDate = parseDateAsEpoch(headerValue); &#125; headerValue = headers.get(\"Cache-Control\"); //获取Cache-Control值，服务端需要设置这个值来标记缓存 if (headerValue != null) &#123; hasCacheControl = true; String[] tokens = headerValue.split(\",\"); for (int i = 0; i &lt; tokens.length; i++) &#123; String token = tokens[i].trim(); if (token.equals(\"no-cache\") || token.equals(\"no-store\")) &#123; //对应的值no-cache、no-store return null; &#125; else if (token.startsWith(\"max-age=\")) &#123; //对应的值为max-age,这个值标记了缓存的生存时间 try &#123; maxAge = Long.parseLong(token.substring(8)); &#125; catch (Exception e) &#123; &#125; &#125; else if (token.equals(\"must-revalidate\") || token.equals(\"proxy-revalidate\")) &#123; maxAge = 0; &#125; &#125; &#125; headerValue = headers.get(\"Expires\"); //过期时间 if (headerValue != null) &#123; serverExpires = parseDateAsEpoch(headerValue); &#125; serverEtag = headers.get(\"ETag\"); // Cache-Control takes precedence over an Expires header, even if both exist and Expires // is more restrictive. if (hasCacheControl) &#123; softExpire = now + maxAge * 1000;//计算过期时间 这里以毫秒为单位 &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123; // Default semantic for Expire header in HTTP specification is softExpire. softExpire = now + (serverExpires - serverDate);//通过过期日期来计算过期时间 &#125; Cache.Entry entry = new Cache.Entry(); entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; entry.ttl = entry.softTtl;//其实就是我们的过期时间 entry.serverDate = serverDate; entry.responseHeaders = headers; return entry; &#125; 我们在缓存调度线程中判断缓存条目失效的方法为 123public boolean isExpired() &#123; return this.ttl &lt; System.currentTimeMillis();&#125; 即当前ttl的值小于当前系统时间就算过期了。所以我们需要服务端设置头部Cache-Control的max-age或者expires来控制缓存的生命时间已达到本地缓存的目的。 总结 volley使用场景 数据量不大但通信频繁的场景 相关链接 Volley主页 Volley仓库","categories":[{"name":"Android library","slug":"Android-library","permalink":"http://esligh.github.io/categories/Android-library/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://esligh.github.io/tags/Android/"}]}]}