<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>esli&#39;s Blog</title>
  
  <subtitle>day day up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://esligh.github.io/"/>
  <updated>2018-05-19T15:01:55.702Z</updated>
  <id>http://esligh.github.io/</id>
  
  <author>
    <name>esli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InputMangerService之Input事件分发流程</title>
    <link href="http://esligh.github.io/2017/09/29/aosp-inputmanager-input-dispatch-src/"/>
    <id>http://esligh.github.io/2017/09/29/aosp-inputmanager-input-dispatch-src/</id>
    <published>2017-09-29T11:45:56.000Z</published>
    <updated>2018-05-19T15:01:55.702Z</updated>
    
    <content type="html"><![CDATA[<p>InputManagerService负责Android输入设备的事件管理，输入事件是Android应用程序最重要的组成部分，因此我们有必要对整个事件的流程进行分析。我们知道输入事件如触摸事件的分发流程是从view树的根部开始向下传递的，但本篇不对此进行分析，而是从事件发生的源头到该步所做的工作进行梳理。那么既然IMS最终要将事件投递到view树中，即DecorView对象上，那么可以想到IMS必然和WMS有不可分割的关系，其实，也可以想到，输入事件要被应用进行处理，必然投递到某一个前台窗口，后面我们会看到他们之间的紧密关系。</p><h3 id="事件输入的流程启动"><a class="markdownIt-Anchor" href="#事件输入的流程启动"></a> 事件输入的流程启动</h3><p>我们知道SystemServer在启动的时候会启动众多的系统服务，这些服务中就包括了WMS和IMS。下面我们看看他们分别是如何启动的。</p><blockquote><p>frameworks/base/services/java/com/android/server/SystemServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAndLoop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ……</span><br><span class="line"><span class="comment">// Create a handler thread just for the window manager to enjoy.</span></span><br><span class="line">    HandlerThread wmHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"WindowManager"</span>);</span><br><span class="line">    wmHandlerThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为WMS单独创建的HandlerThread</span></span><br><span class="line">    Handler wmHandler = <span class="keyword">new</span> Handler(wmHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//创建输入管理服务</span></span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, <span class="string">"Window Manager"</span>);</span><br><span class="line">    wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">            wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">            !firstBoot, onlyCore);<span class="comment">//创建WMS 同时这里将输入管理服务和其关联在一起</span></span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//为输入管理服务设置回调 这个回调来自WMS    </span></span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">    inputManager.start();<span class="comment">//启动输入管理的流程</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemServer进程在启动时会调用其Main方法进行一些初始化工作，initAndLoop就是在整个时候进行的，它会注册多个系统服务到Sm中去，这里我们关注WMS和IMS即可。<br>首先创建IMS的实例，并将其作为参数传递给WMS，随后将这两个服务的实例都加入到SM中</p><p>这里我们先看IMS的实例创建过程，它需要一个context和一个Handler作为参数来构造。这个Handler时为WMS创建的，这里传给IMS，说明他们之间共享这个Handler.</p><p>SystemServer中通过该构造方法创建IMS 注意这个handler是供WMS使用的，它里传过来说明它想和WMS共享handler</p><blockquote><p>frameworks/base/services/java/com/android/server/input/InputManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(handler.getLooper());</span><br><span class="line"></span><br><span class="line">    mUseDevInputEventForAudioJack =</span><br><span class="line">            context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line">    mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line">    <span class="comment">//创建native层的InputManager对象，结果保存在mPtr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMS的构造很简单，它实际上调用natvieInit来创建native层的InputManger对象，对应于java层的IMS，结果返回给mPtr，注意这里的第三个参数为handler的MessageQueue.</p><blockquote><p>frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Native层的InputManager对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());<span class="comment">//直接看NativeInputManager的实现</span></span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们得到java层传进来的MessageQueue对象，然后通过它构造一个NativeInputManager对象，并返回给上层。我们接着看其构造</p><blockquote><p>frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Native层的InputManger构造方法</span></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要创建两个对象，一个EventHub对象，它是用来监听输入事件，也就是输入设备产生的Input事件。另一个对象为InputManager，它以eventHub对象作为其参数构造，这个InputMangager才是真正c++层的IMS服务，NativeInputManager只能算是一个壳，它持有InputMangaer的引用罢了，真正的事情应该是在InputManager中进行的。</p><blockquote><p>frameworks/base/services/input/InputManager.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++层真正的IMS服务类</span></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    <span class="comment">//创建分派对象，用来分派Input事件 例如KeyEvent，MotionEvent</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    <span class="comment">//创建事件reader，这个是InputManger中的Input事件源，实际上它是通过eventHub得到事件的。</span></span><br><span class="line">    <span class="comment">//同时，它和mDispatcher关联是因为需要将事件交给它来分派</span></span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputManager的构造方法做了三件事：</p><ol><li>创建InputDispatcher对象，这个对象使用来分派Input事件的</li><li>创建InputReader对象，它的主要任务从EventHub读取事件并交给InputDispatcher处理，所里在其构造中我们可以看到eventHub和mDispatcher</li><li>初始化InputManger，分别为InputReader和InputDispatcher创建线程，InputManager的主要工作就是在这两个线程中完成的。</li></ol><p>到这里InputManager就创建完成了，但它并没有开始工作，因为线程还未跑起来，其实在我们之前SystemServer可以看到，IMS在创建好实例后还需要关联上WMS，然后设置一个Window回调后才调用start启动工作。这个start流程会调用nativeStart进行native层的InputManager来启动真正的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputDispatcher thread due to error %d."</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not start InputReader thread due to error %d."</span>, result);</span><br><span class="line"></span><br><span class="line">        mDispatcherThread-&gt;requestExit();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在InputManager的start中我们会启动初始化中创建的两个线程，分别用来处理读取Input事件和分派Input事件。接下来我们就从这两个线程的工作入手分析Input事件从下到上的整个流程。</p><h3 id="输入事件在ims中的分派"><a class="markdownIt-Anchor" href="#输入事件在ims中的分派"></a> 输入事件在IMS中的分派</h3><p>我们先看Reader线程的工作，它就是不断的通过mReader的loopOnce读取事件。所以具体的工作还是InputReader进行的，我们接下来就看InputReader的实现。</p><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool InputReaderThread::threadLoop() &#123;</span><br><span class="line">    mReader-&gt;loopOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="function">AutoMutex <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在InputReader的构造中我们传递了EventHub作为事件传递的源，还有InputDispatcher作为事件的分派者的listener，其中通过该listener构造了QueueInputListener对象，这个对象的用途后面我们再介绍。</p><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mReaderIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            processEventsLocked(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">// Flush queued events out to the listener.</span></span><br><span class="line">    <span class="comment">// This must happen outside of the lock because the listener could potentially call</span></span><br><span class="line">    <span class="comment">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></span><br><span class="line">    <span class="comment">// on another thread similarly waiting to acquire the InputReader lock thereby</span></span><br><span class="line">    <span class="comment">// resulting in a deadlock.  This situation is actually quite plausible because the</span></span><br><span class="line">    <span class="comment">// listener is actually the input dispatcher, which calls into the window manager,</span></span><br><span class="line">    <span class="comment">// which occasionally calls into the input reader.</span></span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputReader的线程的主要工作就是调用loopOnce，在这个方法中会通过我们在构造方法中传递的mEventHub对象来获取Input事件，结果保存在mEventBuffer,并返回count代表我们读取的事件数目，接着通过processEventsLocked进行处理，实际上这里会将读取的事件保存在一个缓冲队列中，最后调用mQueueListener的flush将事件发送出去。下面我们接着看着个流程。</p><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsLocked(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> type = rawEvent-&gt;type;</span><br><span class="line">        <span class="keyword">size_t</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">            <span class="keyword">while</span> (batchSize &lt; count) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT</span><br><span class="line">                        || rawEvent[batchSize].deviceId != deviceId) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                batchSize += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_RAW_EVENTS</span></span><br><span class="line">            ALOGD(<span class="string">"BatchSize: %d Count: %d"</span>, batchSize, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_ADDED:</span><br><span class="line">                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_REMOVED:</span><br><span class="line">                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:</span><br><span class="line">                handleConfigurationChangedLocked(rawEvent-&gt;when);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOG_ASSERT(<span class="literal">false</span>); <span class="comment">// can't happen</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= batchSize;</span><br><span class="line">        rawEvent += batchSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到事件消息一开始是作为一个RawEvent对象来根据其类型分别进行处理的，最基本的设备添加移除都通过专门的方法处理，其他事件都通过processEventsForDeviceLocked进行处理。至于addDeviceLocked，它是在添加输入设备时调用，用来添加输入设备的，在里面会对设备创建相应的InputDevice对象，同时创建会创建一些InputMapper，比如KeyboardInputMapper，TouchInputMapper等，这些InputMapper都保存在mMappers的列表中，后面我们会看到输入事件会交给这些mapper来进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsForDeviceLocked(<span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        <span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Discarding event for unknown deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        <span class="comment">//ALOGD("Discarding event for ignored deviceId %d.", deviceId);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步我们通过mDevices取到对应的InputDevice,然后调用process进一步处理输入事件。</p><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDevice::process(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span>()&#123;</span><br><span class="line">      ……</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;</span><br><span class="line">                InputMapper* mapper = mMappers[i];</span><br><span class="line">                mapper-&gt;process(rawEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，input事件就交给Device，这里我们看看KeyboardInputMapper对键盘输入事件的处理。</p><blockquote><p>frameworks/base/services/input/InputReader.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode = rawEvent-&gt;code;</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> keyCode;</span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line">            <span class="keyword">if</span> (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123;</span><br><span class="line">                keyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">                flags = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, keyCode, scanCode, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在process进一步调用processKey，表示处理按键事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::processKey(<span class="keyword">nsecs_t</span> when, <span class="keyword">bool</span> down, <span class="keyword">int32_t</span> keyCode,</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode, <span class="keyword">uint32_t</span> policyFlags) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">        <span class="comment">// Rotate key codes according to orientation if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mParameters.orientationAware &amp;&amp; mParameters.hasAssociatedDisplay) &#123;</span><br><span class="line">            keyCode = rotateKeyCode(keyCode, mOrientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key repeat, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key down</span></span><br><span class="line">            <span class="keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL)</span><br><span class="line">                    &amp;&amp; mContext-&gt;shouldDropVirtualKey(when,</span><br><span class="line">                            getDevice(), keyCode, scanCode)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mKeyDowns.push();</span><br><span class="line">            KeyDown&amp; keyDown = mKeyDowns.editTop();</span><br><span class="line">            keyDown.keyCode = keyCode;</span><br><span class="line">            keyDown.scanCode = scanCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDownTime = when;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove key down.</span></span><br><span class="line">        <span class="keyword">ssize_t</span> keyDownIndex = findKeyDown(scanCode);</span><br><span class="line">        <span class="keyword">if</span> (keyDownIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// key up, be sure to use same keycode as before in case of rotation</span></span><br><span class="line">            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;</span><br><span class="line">            mKeyDowns.removeAt(<span class="keyword">size_t</span>(keyDownIndex));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key was not actually down</span></span><br><span class="line">            ALOGI(<span class="string">"Dropping key up from device %s because the key was not down.  "</span></span><br><span class="line">                    <span class="string">"keyCode=%d, scanCode=%d"</span>,</span><br><span class="line">                    getDeviceName().<span class="built_in">string</span>(), keyCode, scanCode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line">    NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span><br><span class="line">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span><br><span class="line">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);</span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先对按键进行适当的处理，比如按键按下时，需要根据屏幕方向对按键的code进行旋转，这么做的原因可能是因为不同屏幕方向的key code表示的意义是不同的。还有如果对按下事件，如果以及存在了，就会发送持续的发送前一次的key code，否则就是按下事件，最后需要将key事件封装为一个NotifyKeyArgs参数，这些被封装的对象都是继承自NotifyArgs通过mQueuedListener,即QueuedInputListener的notifyKey分发这次Input消息。</p><blockquote><p>frameworks/base/services/input/InputListener.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个NotifyKey只是将封装的事件参数添加到一个参数队列mArgsQueue中，真正的发送是在flush中进行,它是在loopOnce中的最后调用的表示要将事件派发出去了。</p><blockquote><p>frameworks/base/services/input/InputListener.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在flush中实际上调用的是NotifyArgs的notify方法。在其方法中调用了Listener的notifyKey这个listener即 QueuedInputListener的mInnerListener，这个mInnerListener即是在创建QueuedInputListener时传递的参数InputDispatcher，这个就是我们的派发者对象。因为InputReader的主要任务就是将读取的Input事件交给InputDispatcher进行处理。</p><blockquote><p>frameworks/base/services/input/InputDispatcher.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, args-&gt;keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputDipatcher通过notifyKey来处理InputReader交给的事件，这里通过事件参数args来构造一个KeyEntry对象，并通过enqueuInboundEventLocked将其加入到一个队列中去，等待进行处理，并根据needWake来决定唤醒Looper。</p><blockquote><p>frameworks/base/services/input/InputDispatcher.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        <span class="comment">// Optimize app switch latency.</span></span><br><span class="line">        <span class="comment">// If the application takes too long to catch up then we drop all events preceding</span></span><br><span class="line">        <span class="comment">// the app switch key.</span></span><br><span class="line">        KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(entry);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchKeyEventLocked(keyEntry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;</span><br><span class="line">                mAppSwitchSawKeyDown = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAppSwitchSawKeyDown) &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_APP_SWITCH</span><br><span class="line">                    ALOGD(<span class="string">"App switch is pending!"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT;</span><br><span class="line">                    mAppSwitchSawKeyDown = <span class="literal">false</span>;</span><br><span class="line">                    needWake = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueInboundEventLocked将新的keyEvent加入到mInboundQueue中去，如果一开始这个队列是空的，就需要唤醒Looper了表示有新的事件需要处理。当事件到来后就会触发InputDipatcher的dispatchOnce，还记得？这个方法是在InputDipatcherThread的threadloop中循环调用进行事件处理的。我们看看它的具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">        <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里事件的真正处理是在dispatchOnceInnerLocked中进行处理的。它会负责处理队列中的输入事件。然后通过pollOnce将事件发送出去，这是InputDispatcher的职责。下面我们看看dispatchOnceInnerLocked的具体实现。</p><blockquote><p>frameworks/base/services/input/InputDispatcher.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">   ……</span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();<span class="comment">//重置ANR</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        ……</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先判断mInboundQueue队列是否有事件要处理，有的话就先取出队头的事件放到mPendingEvent中，根据事件类型分别进行处理，这里我们看类型为TYPE_KEY的输入事件。然后调用dispatchKeyLocked进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">   ……</span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出待处理的事件后通过dispatchKeyLocked进行处理，这个方法首先根据<br>findFocusedWindowTargetsLocked找到需要派发的目标对象inputTargets，然后通过<br>dispatchEventLocked进一步处理。</p><blockquote><p>frameworks/base/services/input/InputDispatcher.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">   ……</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchEventLocked方法主要是将待发送的输入事件发送给目标对象，这个目标对象是实际上为一个Connection，内部通过InputChannel构造，它是通过registerInputChannel中添加到一个mConnectionByFd的map中维护的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareDispatchCycleLocked进一步调用enqueueDispatchEntriesLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,</span><br><span class="line">        const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123;</span><br><span class="line">    bool wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    // Enqueue dispatch entries for the requested modes.</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    // If the outbound queue was previously empty, start the dispatch cycle going.</span><br><span class="line">    if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再接着调用startDispatchCycleLocked</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line">   ……</span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     ……</span><br><span class="line">        &#125;</span><br><span class="line">     ……</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里其实InputDispatcher的任务基本结束了，它已经将任务转给了具体的Connection进行处理，这个Connection即是再Dispatcher中注册的客户。下面我们分析这些Connection是如何注册到InputDispatcher的。这里我们从底层到上层追上去进行回顾整个流程<br>首先registerInputChannel是再NativeInputManager的registerInputChannel中调用的，而后者也应该是再Java层的InputManagerService中调用的，那么谁回去调用IMS的registerInputChannel呢？</p><h3 id="inputchannel的注册"><a class="markdownIt-Anchor" href="#inputchannel的注册"></a> InputChannel的注册</h3><p>回顾我们之前再SystemServer中所做的事情，再IMS创建后会关联到WMS上，因为输入事件最终是要交给WMS负责分发给客户端的应用程序的。所以注册channel应该是再WMS上进行的。我们下来就看看这个注册的流程以及最终的事件是如何发布到上层的。首先我们去看那WMS的main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> PowerManagerService pm, <span class="keyword">final</span> DisplayManagerService dm,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> InputManagerService im, <span class="keyword">final</span> Handler wmHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManagerService[] holder = <span class="keyword">new</span> WindowManagerService[<span class="number">1</span>];</span><br><span class="line">    wmHandler.runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            holder[<span class="number">0</span>] = <span class="keyword">new</span> WindowManagerService(context, pm, dm, im,</span><br><span class="line">                    haveInputMethods, showBootMsgs, onlyCore);<span class="comment">//创建WMS实例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> holder[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">Main主要负责创建WMS实例，所以我们看看其构造方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, PowerManagerService pm,</span></span></span><br><span class="line"><span class="function"><span class="params">            DisplayManagerService displayManager, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">       …… </span><br><span class="line">       <span class="comment">//WMS内部持有IMS的引用</span></span><br><span class="line">        mInputManager = inputManager; <span class="comment">// Must be before createDisplayContentLocked.</span></span><br><span class="line">      …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中实际上只是将IMS的实例保存在mInputManager中罢了，并没有任何注册的线索。那么注册的流程是在哪里呢？其实可以想象的到，当应用启动后，只有当界面显示出来的时候才能够接受输入事件，而且只有当前有焦点的窗口才可以对事件进行处理，而那些在任务栈中处于停止状态的窗口不对其进行处理。那么当窗口加入到WMS中时应该回去注册相应的channel用来接收事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要看看ViewRootImpl的setView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//这次layout是为接受输入事件做准备，最重要的工作就是设置当前窗口为WMS中具 有焦点的窗口</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//为窗口创建一个Client端的InputChannel,它是用来监听Input事件的。</span></span><br><span class="line">        mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">            collectViewAttributes();</span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                    mAttachInfo.mContentInsets, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">        mView = <span class="keyword">null</span>;</span><br><span class="line">        mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">        mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">        mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleTraversals();</span><br><span class="line">        setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">            attrs.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;<span class="comment">//前面为该window创建了InputChannel所以不为null</span></span><br><span class="line">        <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputQueue = <span class="keyword">new</span> InputQueue();<span class="comment">//创建一个InputQueue</span></span><br><span class="line">            mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setView中会去创建InputChannel，在这之前会调用一次requestLayout，这里的主要工作就是设置当前窗口为WMS中具有焦点的窗口，为接受输入事件做准备。那么这个InputChannel会去注册到InputDispatcher中？实际上不是的，注意这个方法还在我们的应用端。而接受InputDispather也就是IMS的输入事件的是WMS，那么事件的流程应该是IMS到WMS然后再到应用端程序。下面我们追踪mInputChannel来看看具体是怎么样的。</p><p>我们先看到mInputChannel，它的创建过程，它的构造方法是个空方法，这么说InputChannel现在在java层只是一个空壳，而真正的初始化是在native层的。接着我们看到mInputChannel被传递给了addToDisplay,这个方法将当前窗口添加到WMS中，它会通过Binder调用WMS的addWindow方法。所以我们去WMS中看看addWindow的实现</p><blockquote><p>frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">                &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line"></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的outInputChannel就是我们客户端传递的mInputChannel，这里我们看到首先我们调用InputChannel的openInputChannelPair方法打开了一对InputChannel，这一对InputChannel分别是为Client和Server端的channel,用来负责应用端以及WMS的输入事件的接受通道。其中索引为0的为服务端的，而索引为1的为客户端的。我们看到inputChannels[0]先被保存在win中，也即是WindowState中，WindowState表示当前窗口，随后通过mInputManager调用registerInputChannel注册到InputDispatcher中。<br>而inputchanel[1]被转换为outInputChannel作为出参传递给应用端。这里我们先分析注册到InputDispatcher的这个InputChannel，随后再分析传递到客户端的inputchannel。</p><p>首先我们分析openInputChannelPair流程。</p><blockquote><p>frameworks/base/core/java/android/view/InputChannel.java</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == null) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Opening input channel pair '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法直接调用了native层的nativeOpenInputChannelPair方法</p><blockquote><p>frameworks/base/core/jni/android_view_InputChannel.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobjectArray <span class="title">android_view_InputChannel_nativeOpenInputChannelPair</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jclass clazz, jstring nameObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nameChars = env-&gt;GetStringUTFChars(nameObj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="function">String8 <span class="title">name</span><span class="params">(nameChars)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(nameObj, nameChars);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    sp&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="keyword">status_t</span> result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Could not open input channel pair.  status=%d"</span>, result);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobjectArray channelPair = env-&gt;NewObjectArray(<span class="number">2</span>, gInputChannelClassInfo.clazz, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject serverChannelObj = android_view_InputChannel_createInputChannel(env,</span><br><span class="line">            <span class="keyword">new</span> NativeInputChannel(serverChannel));</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject clientChannelObj = android_view_InputChannel_createInputChannel(env,</span><br><span class="line">            <span class="keyword">new</span> NativeInputChannel(clientChannel));</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetObjectArrayElement(channelPair, <span class="number">0</span>, serverChannelObj);</span><br><span class="line">    env-&gt;SetObjectArrayElement(channelPair, <span class="number">1</span>, clientChannelObj);</span><br><span class="line">    <span class="keyword">return</span> channelPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用c++层的InputChannle(定义在InputTransport中)打开一对InputChannel对象，serverChannel和clientChannel，随后通过这两个对象调用android_view_input_channel_createInputChannel构造java层的InputChannel对象。</p><blockquote><p>frameworks/native/libs/input/InputTransport.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"channel '%s' ~ Could not create socket pair.  errno=%d"</span>,</span><br><span class="line">                name.<span class="built_in">string</span>(), errno);</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = <span class="keyword">new</span> InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = <span class="keyword">new</span> InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过socketpair创建一对相互连接的unnamed socket，这两个socket都可以互相进行读写，相比以前的管道通信，它是全双工的通信，即一端的socket既可以读又可以写。<br>创建好后，通过这两个socket分别去构造两个InputChannel作为服务端和客户端的读写通道。传递好后就可以将他们传递给java层使用了，这是通过android_view_input_channel_createInputChannel实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_view_InputChannel_createInputChannel</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeInputChannel* nativeInputChannel)</span> </span>&#123;</span><br><span class="line">    jobject inputChannelObj = env-&gt;NewObject(gInputChannelClassInfo.clazz,</span><br><span class="line">            gInputChannelClassInfo.ctor);</span><br><span class="line">    <span class="keyword">if</span> (inputChannelObj) &#123;</span><br><span class="line">        android_view_InputChannel_setNativeInputChannel(env, inputChannelObj, nativeInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inputChannelObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_InputChannel_setNativeInputChannel</span><span class="params">(JNIEnv* env, jobject inputChannelObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeInputChannel* nativeInputChannel)</span> </span>&#123;</span><br><span class="line">    env-&gt;SetIntField(inputChannelObj, gInputChannelClassInfo.mPtr,</span><br><span class="line">             <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(nativeInputChannel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java层持有的其实是NativeInputChannel，它内部持有我们之前构造的InputChannel。<br>这个对象的地址会保存在java层的InputChannel的mPtr中。</p><p>创建好channel后接下来我们看看IMS是如何注册我们的服务端的InputChannel的<br>在之前addWindow中我们看到创建好Channel pair后就会调用IMS的registerInputChannel来注册服务端的Channel.</p><blockquote><p>frameworks/base/services/java/com/android/server/input/InputManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInputChannel</span><span class="params">(InputChannel inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">            InputWindowHandle inputWindowHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"inputChannel must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> NativeInputManager::registerInputChannel(JNIEnv* env,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个mINputManager就是我们c++层的InputMnager，通过getDispatcher获取到的InputDispatcher对象就是我们在创建InputManger对象时创建的mDispatcher。</p><blockquote><p>frameworks/base/services/input/InputDispatcher.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Attempted to register already registered input channel '%s'"</span>,</span><br><span class="line">                    inputChannel-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = <span class="keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过传递进来的InputChannel先创建一个Connection对象，随后添加到一个mConnectionsByFd这个Map中去。需要注意的是在注册完成之后会去为这个描述符注册回调handleReceiveCallBack中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::Connection::Connection(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) :</span><br><span class="line">        status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle),</span><br><span class="line">        monitor(monitor),</span><br><span class="line">        inputPublisher(inputChannel), inputPublisherBlocked(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到通过InputChannel构造一个InputPublisher对象，这个InputChannel是我们服务端的Channel,它最终是给WMS使用的。还记得？在InputDispater中正是通过它的publishKeyEvent方法来发布输入事件到WMS的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputPublisher::publishKeyEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,</span><br><span class="line">        <span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        <span class="keyword">int32_t</span> source,</span><br><span class="line">        <span class="keyword">int32_t</span> action,</span><br><span class="line">        <span class="keyword">int32_t</span> flags,</span><br><span class="line">        <span class="keyword">int32_t</span> keyCode,</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode,</span><br><span class="line">        <span class="keyword">int32_t</span> metaState,</span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount,</span><br><span class="line">        <span class="keyword">nsecs_t</span> downTime,</span><br><span class="line">        <span class="keyword">nsecs_t</span> eventTime) &#123;</span><br><span class="line"></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_KEY;</span><br><span class="line">    msg.body.key.seq = seq;</span><br><span class="line">    msg.body.key.deviceId = deviceId;</span><br><span class="line">    msg.body.key.source = source;</span><br><span class="line">    msg.body.key.action = action;</span><br><span class="line">    msg.body.key.flags = flags;</span><br><span class="line">    msg.body.key.keyCode = keyCode;</span><br><span class="line">    msg.body.key.scanCode = scanCode;</span><br><span class="line">    msg.body.key.metaState = metaState;</span><br><span class="line">    msg.body.key.repeatCount = repeatCount;</span><br><span class="line">    msg.body.key.downTime = downTime;</span><br><span class="line">    msg.body.key.eventTime = eventTime;</span><br><span class="line">    <span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在publishKeyEvent中我们通过调用InputChannel的sendMessage将事件发送出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">   ……  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sendMessage中实际上我们使用的是为WMS注册InputChannel来发送的事件消息，它的接收端位于我们应用程序的另一个InputChannel。接下来我们就需要看看应用程序是如何接受这个输入事件的。</p><h3 id="应用端输入事件的接受"><a class="markdownIt-Anchor" href="#应用端输入事件的接受"></a> 应用端输入事件的接受</h3><p>在WMS的addView中我们构造了一对InputChannel，其中一个作为服务端注册到了InputDispatcher中，另一个作为结果返回给了应用端，应用端正是使用这个InputChannel来监听输入事件的。</p><p>在ViewRootImpl的setView中调用了addToDisplay后就得到了这个InputChannel,随后又使用该InputChannel构造了一个一个WindowInputEvetnReceiver对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;<span class="comment">//前面为该window创建了InputChannel所以不为null</span></span><br><span class="line">    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputQueue = <span class="keyword">new</span> InputQueue();<span class="comment">//创建一个InputQueue</span></span><br><span class="line">        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">            Looper.myLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个WindowInputEventReceiver的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBatchedInputEventPending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleConsumeBatchedInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unscheduleConsumeBatchedInput();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从其实现来看它继承自InputEventReceiver，是用来接受输入事件的，其中onInputEvent重载了接受事件的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"inputChannel must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的inputChannel是客户端使用的，它会通过nativeInit进行初始化，同时这个Looper是我们的主线程的Looper。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"InputChannel is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to initialize input event receiver.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nativeInit在native层创建对应的NativeInputEventReceiver对象，并调用了initialize进行初始化,同时将该native对象作为结果返回给java层的InputEventReceiver的mReceiverPtr成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)),</span><br><span class="line">        mInputConsumer(inputChannel), mMessageQueue(messageQueue),</span><br><span class="line">        mBatchedInputEventPending(<span class="literal">false</span>), mFdEvents(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> NativeInputEventReceiver::initialize() &#123;</span><br><span class="line">    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeInputEventReceiver的构造方法很简单，会通过inputchannel构造一个InputConsumer mInputConsumer，从名字来看它是一个输入事件的消费者，也就是我们客户端程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeInputEventReceiver::setFdEvents(<span class="keyword">int</span> events) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将InputChannel的描述符fd取出来，然后通过主线程的Looper进行监听，当需要读取输入事件时会触发handleEVent回调。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NativeInputEventReceiver::handleEvent(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) &#123;</span><br><span class="line">   ……</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">        <span class="keyword">status_t</span> status = consumeEvents(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"handleReceiveCallback"</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后调用consumeEvents进一步对事件进行消费</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> NativeInputEventReceiver::consumeEvents(JNIEnv* env,</span><br><span class="line">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">bool</span>* outConsumedBatch) &#123;</span><br><span class="line">   ……</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> skipCallbacks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">               env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">               env-&gt;DeleteLocalRef(inputEventObj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Failed to obtain event object."</span>, getInputChannelName());</span><br><span class="line">                skipCallbacks = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先调用InputConsumer的consume方法进行事件的读取，随后通过gInputReceiverClassInfo的dispatchInputEvent方法发布到java层的InputEventReceiver</p><blockquote><p>frameworks/native/libs/input/InputTransport.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputConsumer::consume(InputEventFactoryInterface* factory,</span><br><span class="line">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">uint32_t</span>* outSeq, InputEvent** outEvent) &#123;</span><br><span class="line"></span><br><span class="line">    *outSeq = <span class="number">0</span>;</span><br><span class="line">    *outEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch the next input message.</span></span><br><span class="line">    <span class="comment">// Loop until an event can be returned or no additional events are received.</span></span><br><span class="line">    <span class="keyword">while</span> (!*outEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMsgDeferred) &#123;</span><br><span class="line">            <span class="comment">// mMsg contains a valid input message from the previous call to consume</span></span><br><span class="line">            <span class="comment">// that has not yet been processed.</span></span><br><span class="line">            mMsgDeferred = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Receive a fresh message.</span></span><br><span class="line">            <span class="keyword">status_t</span> result = mChannel-&gt;receiveMessage(&amp;mMsg);</span><br><span class="line">          …… </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> InputMessage::TYPE_KEY: &#123;</span><br><span class="line">            KeyEvent* keyEvent = factory-&gt;createKeyEvent();</span><br><span class="line">            <span class="keyword">if</span> (!keyEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">            initializeKeyEvent(keyEvent, &amp;mMsg);</span><br><span class="line">            *outSeq = mMsg.body.key.seq;</span><br><span class="line">            *outEvent = keyEvent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先通过Client端的InputChannel来读取服务发送的输入事件，然后将结果保存在outEvent中</p><blockquote><p>frameworks/native/libs/input/InputTransport.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> InputChannel::receiveMessage(InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nRead = ::recv(mFd, msg, <span class="keyword">sizeof</span>(InputMessage), MSG_DONTWAIT);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">   ……</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就到java层看看我们如何接受输入事件的，刚才说过，输入事件最终是通过InputEventReceiver的dispatchInputEvent接受的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dispatchInputEvent中是通过onInputEvent处理的，它真正的工作是它的子类WindowInputEventReceiver中进行处理的，它是在ViewRootImpl中定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBatchedInputEventPending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleConsumeBatchedInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unscheduleConsumeBatchedInput();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line"></span><br><span class="line">    QueuedInputEvent last = mPendingInputEventTail;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingInputEventHead = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.mNext = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingInputEventCount += <span class="number">1</span>;</span><br><span class="line">    Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">            mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        doProcessInputEvents();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先将待处理的事件入队，并调用doProcessInputEvents进一步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">    <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">        mPendingInputEventHead = q.mNext;</span><br><span class="line">        <span class="keyword">if</span> (mPendingInputEventHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingInputEventTail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.mNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        mPendingInputEventCount -= <span class="number">1</span>;</span><br><span class="line">        Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">                mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line">        deliverInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are done processing all input events that we can process right now</span></span><br><span class="line">    <span class="comment">// so we can clear the pending flag immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (mProcessInputEventsScheduled) &#123;</span><br><span class="line">        mProcessInputEventsScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doProcessInputEvents的处理逻辑很简单，如果队列中有待处理的事件就循环调用deliverInputEvent进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"deliverInputEvent"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InputStage stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">        <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stage.deliver(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finishInputEvent(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != <span class="number">0</span>) &#123;</span><br><span class="line">                forward(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">                finish(q, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                apply(q, onProcess(q));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在deliverInputEvent中，事件被交给一个InputStage进行处理，这个InputState实际上是一个职责链，事件沿着职责链进行传递，当某个Stage需要处理的话就调用apply来调用onProcess进行事件的消费。这个职责链是在ViewRootImpl的setview中创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up the input pipeline.</span></span><br><span class="line">CharSequence counterSuffix = attrs.getTitle();</span><br><span class="line">InputStage syntheticInputStage = <span class="keyword">new</span> SyntheticInputStage();</span><br><span class="line">InputStage viewPostImeStage = <span class="keyword">new</span> ViewPostImeInputStage(syntheticInputStage);</span><br><span class="line">InputStage nativePostImeStage = <span class="keyword">new</span> NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">                <span class="string">"aq:native-post-ime:"</span> + counterSuffix);</span><br><span class="line">InputStage earlyPostImeStage = <span class="keyword">new</span> EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">InputStage imeStage = <span class="keyword">new</span> ImeInputStage(earlyPostImeStage,</span><br><span class="line">                <span class="string">"aq:ime:"</span> + counterSuffix);</span><br><span class="line">InputStage viewPreImeStage = <span class="keyword">new</span> ViewPreImeInputStage(imeStage);</span><br><span class="line">InputStage nativePreImeStage = <span class="keyword">new</span> NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">                <span class="string">"aq:native-pre-ime:"</span> + counterSuffix);</span><br><span class="line"></span><br><span class="line">mFirstInputStage = nativePreImeStage;</span><br><span class="line">mFirstPostImeInputStage = earlyPostImeStage;</span><br></pre></td></tr></table></figure><p>对于处理键盘输入事件，我们会交给viewPostImeStage进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPostImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPostImeInputStage</span><span class="params">(InputStage next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">            <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If delivering a new non-key event, make sure the window is</span></span><br><span class="line">            <span class="comment">// now allowed to start updating.</span></span><br><span class="line">            handleDispatchDoneAnimating();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">            <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> processTrackballEvent(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理触摸事件</span></span><br><span class="line">                <span class="keyword">return</span> processGenericMotionEvent(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> KeyEvent event = (KeyEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.getAction() != KeyEvent.ACTION_UP) &#123;</span><br><span class="line">            <span class="comment">// If delivering a new key event, make sure the window is</span></span><br><span class="line">            <span class="comment">// now allowed to start updating.</span></span><br><span class="line">            handleDispatchDoneAnimating();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver the key to the view hierarchy.</span></span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchPointerEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processGenericMotionEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver the event to the view.</span></span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchGenericMotionEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onProcess中如果事件类型为keyevent会交给processKeyEvent进行处理，后者会将事件投递给mView，即我们的DecorView，这样输入事件就可以view树上进行传递了。关于在view树中的处理流程，我们在另一篇中再做介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InputManagerService负责Android输入设备的事件管理，输入事件是Android应用程序最重要的组成部分，因此我们有必要对整个事件的流程进行分析。我们知道输入事件如触摸事件的分发流程是从view树的根部开始向下传递的，但本篇不对此进行分析，而是从事件发生
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Zygote进程启动过程分析</title>
    <link href="http://esligh.github.io/2017/09/25/aosp-system-zygote-startup/"/>
    <id>http://esligh.github.io/2017/09/25/aosp-system-zygote-startup/</id>
    <published>2017-09-25T12:03:05.000Z</published>
    <updated>2018-05-19T11:47:54.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="zygote进程定义"><a class="markdownIt-Anchor" href="#zygote进程定义"></a> zygote进程定义</h3><p>Init进程是Android系统中用户空间的第一个进程， 它最重要的工作就是创建zygote进程。而在Android系统中，所有应用程序的进程以及系统服务进程SystemServer都是由Zygote进程孕育出来的。所有Zygote的地位非同小可，本文就分析它的启动过程。</p><p>Android系统启动后运行的第一个进程是init进程，它的目录在system/core/init/init.cpp 在这里会进行启动属性服务以及解析init.rc文件，init.rc文件是android系统的配置文件，它如下格式所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">system/core/rootdir/init.rc</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br></pre></td></tr></table></figure><p>每一个service命令都会促使init进程调用fork函数来创建一个新的进程，这里service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process，后面的则是要传给app_process的参数。class main指的是zygote的class name为main。</p><p>zygote要执行的程序是system/bin/app_process这样会进入main函数。在main中会执行AppRuntime的start来进一步启动zygote。</p><blockquote><p>frameworks/base/cmds/app_process/app_main.cpp</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的runtime是AppRuntime的实例，AppRuntime是继承自AndroidRuntime，这里的start方法就是在AndroidRuntime里定义的。</p><p>//启动android运行时 这包括了启动虚拟机和调用callName所定义的静态main方法 这里时指com.android.internal.os.ZygoteInit</p><blockquote><p>frameworks/base/core/jni/AndroidRuntime.cpp</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> <span class="keyword">char</span>* options)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">   JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class="number">0</span>) &#123;<span class="comment">//启动虚拟机</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;<span class="comment">//在虚拟机中注册function</span></span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);<span class="comment">//找到ZygoteInit类</span></span><br><span class="line">    <span class="keyword">if</span> (startClass == NULL) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);<span class="comment">//调用静态main方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zygote进程在启动时会创建JavaVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个JavaVM的实例拷贝.在启动zygote时传递进来的类为com.android.internal.os.ZygoteInit，这里通过反射的方式来调用其main方法进一步完成启动初始化的过程。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AndroidRuntime的start方法通过反射调用的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Start profiling the zygote initialization.</span></span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        registerZygoteSocket();<span class="comment">//注册zygote本地Socket服务 监听来自AMS的创建应用进程请求</span></span><br><span class="line">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">        preload();<span class="comment">//预加载 一些资源，类等</span></span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">"start-system-server"</span>)) &#123;</span><br><span class="line">            startSystemServer();<span class="comment">//启动SystemServer进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!argv[<span class="number">1</span>].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(argv[<span class="number">0</span>] + USAGE_STRING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        runSelectLoop();<span class="comment">//等待客户端请求</span></span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();<span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在zygote的初始化中，做了以下几件事件：</p><ol><li>通过registerServerSocket创建zygote的socket服务，它是一个LocalSocketServer用来等待AMS请求zygote创建应用进程的请求。</li><li>监听socket服务，等待AMS创建应用程序的请求</li><li>创建SystemServer进程</li></ol><p>值得注意的是，无论是创建systemServer进程还是创建应用进程，最终都会通过捕获MethodAndArgsCaller异常来执行参数指定的class的main方法，后面我们分析SystemServer启动及应用进程的启动时就会看到。</p><p>这里我们接着看看注册socket服务的代码，它仅仅是创建了LocalServerSocket的本地socket对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String env = System.getenv(ANDROID_SOCKET_ENV);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    ANDROID_SOCKET_ENV + <span class="string">" unset or invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sServerSocket = <span class="keyword">new</span> LocalServerSocket(</span><br><span class="line">                    createFileDescriptor(fileDesc));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Error binding to local socket '"</span> + fileDesc + <span class="string">"'"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="systemserver进程的创建流程"><a class="markdownIt-Anchor" href="#systemserver进程的创建流程"></a> SystemServer进程的创建流程</h3><p>这里我们重点关注SystemServer的创建流程，继续关注startSystemServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--runtime-init"</span>,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);<span class="comment">//fork 出systemServer进程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        handleSystemServerProcess(parsedArgs);<span class="comment">//在子进程中调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在startSystemServer中仅仅fork出进程后随后进一步在handleSystemServerProcess中进一步对SystemServer进行初始化</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(//进一步处理SystemServer进程的相关工作</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    closeServerSocket();<span class="comment">//关闭从父进程继承来的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set umask to 0077 so new files and directories will default to owner-only permissions.</span></span><br><span class="line">    Libcore.os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                <span class="keyword">null</span>, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//此时的remainingArgs就是”com.android.server.SystemServer”</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进一步调用zygoteInit进行初始化工作</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();<span class="comment">//zygote本地初始化 </span></span><br><span class="line">    applicationInit(targetSdkVersion, argv);<span class="comment">////应用层的初始化 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们来看第一个方法nativeZygoteInit的调用，这个方法时在AndroidRuntime中定义的，具体是</p><blockquote><p>/frameworks/base/core/jni/AndroidRuntime.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"> com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的onZygoteInit是调用其子类AppRuntime的方法,zygote的启动就是通过这个类调用start方法来执行的。</p><blockquote><p>frameworks/base/cmds/app_process/app_main.cpp</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Re-enable tracing now that we're no longer in Zygote.</span></span><br><span class="line">    atrace_set_tracing_enabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState对于binder机制非常重要，这里主要是初始化SystemServer进程的的binder环境，这样在其进程中就可以通过binder同其他进程进行通信了。</p><p>下面我们来看看第二个方法applicationInit，这个方法第二个参数包含了调用了类的信息及相关方法的参数，这里就是“com.android.server.SystemServer”和main方法</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">        invokeStaticMain(args.startClass, args.startArgs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法内部会调用invokeStaticMain方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法最终会抛出异常MethodAndArgsCaller触发其run方法的调用，具体见ZygoteInit的main方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className);<span class="comment">//获取类信息 可能是SystemServer或者ActivityThread</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);<span class="comment">//获取对应类的main方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> ()&#123;&#125; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//抛出异常，通过MethodAndArgsCaller的run方法会去调用main方法</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodAndArgsCaller的定义如下,这里我们重点看看run方法,run方法的实现很简单只是对main方法进行调用。即调用SystemServer的main方法完成SystemServer进程的创建和启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;<span class="comment">//调用的方法，这里就是main方法了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;<span class="comment">//参数</span></span><br><span class="line">……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span>()&#123;…&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用进程的创建启动过程"><a class="markdownIt-Anchor" href="#应用进程的创建启动过程"></a> 应用进程的创建启动过程</h3><p>接下来我们分析应用进程创建和启动的过程，这个过程中需要AMS的介入，不过这里我们重点关注应用进程的创建和启动过程，而不需要关注整个流程的太多细节。熟悉AMS的应该知道，当我们点击Launcher启动应用程序后 最终会通过AMS的startProcessLocked方法来为我们的应用程序创建进程，而其内部会进一步调用startProcessLocked来完成，所以我们重点看那startProcessLocked方法。</p><blockquote><p>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">            <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">    Process.ProcessStartResult startResult = Process.start(<span class="string">"android.app.ActivityThread"</span>,</span><br><span class="line">            app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, app.info.seinfo, <span class="keyword">null</span>);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会通过Process的start方法类完成进程的创建，这里我们传递ActivityThread的类名，再我们创建完应用进程后需要就是调用其内部的main方法完成启动过程。下面我们继续去看下进程是如何创建的。</p><blockquote><p>frameworks/base/core/java/android/os/Process.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Process的start方法很简单，调用startViaZygote，从其名称来看就是通过zygote来创建我们应用进程了。<br>这里的processClass就是我们的ActivityThread类，niceName是进程名称。startViaZygote通过将这一些参数打包到一个ArrayList变量中然后调用zygoteSendArgsAndGetResult，并将打包的参数传递给它。这个方法负责将这些参数通过socket传递给zygote.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    openZygoteSocketIfNeeded();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sZygoteWriter.write(Integer.toString(args.size()));</span><br><span class="line">        sZygoteWriter.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            <span class="keyword">if</span> (arg.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(</span><br><span class="line">                        <span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sZygoteWriter.write(arg);</span><br><span class="line">            sZygoteWriter.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sZygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line">        result.pid = sZygoteInputStream.readInt();</span><br><span class="line">        ……</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先通过openZygoteSocketIfNeeded方法来打开同zygote通信的socket,并用该socket创建一个<br>BufferedWriter对象sZygoteWrite，随后通过sZygoteWrite将参数发送给zygote,同时创建一个ProcessStartResult对象，用来保存创建的进程信息。</p><p>对于zygote端我们知道，当zygote启动后会先注册一个LocalSocketServer服务，然后通过runSelectLoop等待来自AMS创建进程的请求。这里我们就需要看看runSelectLoop方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">()</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    FileDescriptor[] fdArray = <span class="keyword">new</span> FileDescriptor[<span class="number">4</span>];</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error in select()"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            ZygoteConnection newPeer = acceptCommandPeer();</span><br><span class="line">            peers.add(newPeer);</span><br><span class="line">            fds.add(newPeer.getFileDesciptor());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> done;</span><br><span class="line">            done = peers.get(index).runOnce();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                peers.remove(index);</span><br><span class="line">                fds.remove(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runSelectLoop方法主要负责处理客户端的连接请求和客户端的消息处理，当index==0是说明有新的客户端连接，index&gt;0则说明有消息到来，index指定了客户端的连接索引。同时会调用runOnce对消息机型处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zygote收到客户端AMS的信息进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = readArgumentList();<span class="comment">//读取客户端发送的消息 得到参数列表</span></span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;  &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">        ……</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName);<span class="comment">//创建应用进程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> () &#123;&#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//继续处理子进程 这里面最终会抛出ZygoteInit.MethodAndArgsCaller来触发其run方法的调用</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;………&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中首先通过readArgumentList方法读取客户端发送的消息，得到参数列表，随后根据参数创建应用进程，随后进一步调用handleChildProc进一步完成子进程的创建。在这个方法中最终会抛出MethodAndArgsCaller异常来触发run方法的调用，就如SystemServer进程那样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execStandalone(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.classpath, className, mainArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZygoteInit.invokeStaticMain(cloader, className, mainArgs);<span class="comment">//最终会调用invokeStaticMain方法抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            logAndPrintError(newStderr, <span class="string">"Error starting."</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会调用invokeStaticMain，这个方法我们在SystemServer启动时候分析过，这里就不再分析了。最终会调用ActivityThread的main方法完成应用进程的启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;zygote进程定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#zygote进程定义&quot;&gt;&lt;/a&gt; zygote进程定义&lt;/h3&gt;
&lt;p&gt;Init进程是Android系统中用户空间的第一个进程， 它最重要的工作就是创建zygote进程
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GUI系统之SurfaceFlinger启动过程分析</title>
    <link href="http://esligh.github.io/2017/09/22/aosp-gui-surfaceflinger-startup/"/>
    <id>http://esligh.github.io/2017/09/22/aosp-gui-surfaceflinger-startup/</id>
    <published>2017-09-22T13:32:09.000Z</published>
    <updated>2018-05-19T11:02:18.824Z</updated>
    
    <content type="html"><![CDATA[<p>surfaceFlinger 在init.rc中是作为一个service存在的它声明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">graphics</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br></pre></td></tr></table></figure><p>从上面的内容可以看出，surfaceflinger所属的class为main，这和zygote时同级的。但它的启动并不需要带任何参数。同时由于surfaceflinger是service,说明它是单独的可执行程序，程序路径为/system/bin/surfaceflinger 运行在单独的进程里，另外，从最后一行也能看出sf重启时要重启zygote。</p><p>Surfaceflinger主程序对应的文件是frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp 所以我们从这个文件入手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></span><br><span class="line">    <span class="comment">// binder threads to 4.</span></span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);<span class="comment">//限制了binder线程的个数为4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();<span class="comment">//启动binder线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();<span class="comment">//创建SF对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();<span class="comment">//SF的初始化 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>);<span class="comment">//添加到SM中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run in this thread</span></span><br><span class="line">    flinger-&gt;run();<span class="comment">//sf运行起来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sf的主程序中做了以下事情：<br>1.初始binder的运行环境<br>2.创建Sf对象，并对其进行初始化<br>3.将Sf服务添加到ServiceManger中，以便向其他进程提供服务<br>4.SF在自己的线程中开始运行</p><p>SurfaceFlinger作为服务进程，必然需要通过Binder进行IPC通信，所以在一开始需要对Binder环境进行初始化。接着创建了SurfaceFlinger对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line">SurfaceFlinger::SurfaceFlinger()</span><br><span class="line">    :   BnSurfaceComposer(),</span><br><span class="line">        mTransactionFlags(<span class="number">0</span>),</span><br><span class="line">        mTransactionPending(<span class="literal">false</span>),</span><br><span class="line">        mAnimTransactionPending(<span class="literal">false</span>),</span><br><span class="line">        mLayersRemoved(<span class="literal">false</span>),</span><br><span class="line">        mRepaintEverything(<span class="number">0</span>),</span><br><span class="line">        mRenderEngine(<span class="literal">NULL</span>),</span><br><span class="line">        mBootTime(systemTime()),</span><br><span class="line">        mVisibleRegionsDirty(<span class="literal">false</span>),</span><br><span class="line">        mHwWorkListDirty(<span class="literal">false</span>),</span><br><span class="line">        mAnimCompositionPending(<span class="literal">false</span>),</span><br><span class="line">        mDebugRegion(<span class="number">0</span>),</span><br><span class="line">        mDebugDDMS(<span class="number">0</span>),</span><br><span class="line">        mDebugDisableHWC(<span class="number">0</span>),</span><br><span class="line">        mDebugDisableTransformHint(<span class="number">0</span>),</span><br><span class="line">        mDebugInSwapBuffers(<span class="number">0</span>),</span><br><span class="line">        mLastSwapBufferTime(<span class="number">0</span>),</span><br><span class="line">        mDebugInTransaction(<span class="number">0</span>),</span><br><span class="line">        mLastTransactionTime(<span class="number">0</span>),</span><br><span class="line">        mBootFinished(<span class="literal">false</span>),</span><br><span class="line">        mPrimaryHWVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">        mHWVsyncAvailable(<span class="literal">false</span>),</span><br><span class="line">        mDaltonize(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// debugging stuff...</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"ro.bq.gpu_to_cpu_unsupported"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mGpuToCpuSupported = !atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"debug.sf.showupdates"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mDebugRegion = atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"debug.sf.ddms"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mDebugDDMS = atoi(value);</span><br><span class="line">    <span class="keyword">if</span> (mDebugDDMS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!startDdmConnection()) &#123;</span><br><span class="line">            <span class="comment">// start failed, and DDMS debugging not enabled</span></span><br><span class="line">            mDebugDDMS = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法很简单，只是都其成员进行初始化，读取一些配置信息，比如是否开启DDMS的调试。<br>接下来通过init方法对该对象进行初始化。这个初始化过程会做大量比较重要的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"><span class="comment">//sf的初始化方法</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize EGL for the default display</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);<span class="comment">//获取默认的显示设备</span></span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//为默认的显示设备初始EGL环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the H/W composer object.  There may or may not be an</span></span><br><span class="line">    <span class="comment">// actual hardware composer underneath.</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">            *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));<span class="comment">//创建合成对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// First try to get an ES2 config</span></span><br><span class="line">    err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES2_BIT,</span><br><span class="line">            &amp;mEGLConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// If ES2 fails, try ES1</span></span><br><span class="line">        err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(),</span><br><span class="line">                EGL_OPENGL_ES_BIT, &amp;mEGLConfig);</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line">    EGLint r,g,b,a;</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_RED_SIZE,   &amp;r);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_GREEN_SIZE, &amp;g);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_BLUE_SIZE,  &amp;b);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_ALPHA_SIZE, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a RenderEngine for the given display / config (can't fail)</span></span><br><span class="line">    mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);<span class="comment">//通过给定的设备创建渲染引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// retrieve the EGL context that was selected/created</span></span><br><span class="line">    mEGLContext = mRenderEngine-&gt;getEGLContext();<span class="comment">//获取EGL context</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out which format we got</span></span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig,</span><br><span class="line">            EGL_NATIVE_VISUAL_ID, &amp;mEGLNativeVisualId);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT,</span><br><span class="line">            <span class="string">"couldn't create EGLContext"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize our non-virtual displays</span></span><br><span class="line">  <span class="comment">//初始化所有的非虚拟显示设备</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        <span class="comment">// set-up the displays that are already connected</span></span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            <span class="comment">// All non-virtual displays are currently considered secure.</span></span><br><span class="line">            <span class="keyword">bool</span> isSecure = <span class="literal">true</span>;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line">          <span class="comment">//为显示设备创建BufferQueue用来管理其帧缓冲区 并通过FramebufferSurface进行管理</span></span><br><span class="line">            sp&lt;BufferQueue&gt; bq = <span class="keyword">new</span> BufferQueue(<span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs = <span class="keyword">new</span> FramebufferSurface(*mHwc, i, bq);</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                    type, allocateHwcDisplayId(type), isSecure, token,</span><br><span class="line">                    fbs, bq,</span><br><span class="line">                    mEGLConfig);<span class="comment">//为每个实体设备创建显示设备对象</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> currently we don't get blank/unblank requests</span></span><br><span class="line">                <span class="comment">// for displays other than the main display, so we always</span></span><br><span class="line">                <span class="comment">// assume a connected display is unblanked.</span></span><br><span class="line">                ALOGD(<span class="string">"marking display %d as acquired/unblanked"</span>, i);</span><br><span class="line">                hw-&gt;acquireScreen();</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make the GLContext current so that we can create textures when creating Layers</span></span><br><span class="line">    <span class="comment">// (which may happens before we render something)</span></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<span class="comment">//将EGL context和默认的显示设备关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>);<span class="comment">//创建绘图延时对象</span></span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);<span class="comment">//负责管理绘图延时Vsync信号</span></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">false</span>);<span class="comment">//创建合成延时对象</span></span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);<span class="comment">//负责管理合成延时Vsync信号</span></span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line"></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">     ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在init方法中，sf做了以下的事：<br>1.为默认的显示设备初始EGL环境<br>2.创建合成对象<br>3.初始化所有的非虚拟显示设备<br>4.创建绘图延时Vysnc源 及 合成延时Vysnc源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);<span class="comment">//为sf的vsync信号注册事件回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是在main方法中创建的SurfaceFlinger是个强引用对象，所以在第一次调用同时也会会触发onFirstRef方法，这个方法会对SF的mEventQueue成员进行初始化。它是一个MessageQueue对象，负责SF的消息管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    mEventQueue.init(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::init(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">&#123;</span><br><span class="line">    mFlinger = flinger;<span class="comment">//持有sf的引用</span></span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">true</span>);<span class="comment">//为其创建一个Looper对象</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(*<span class="keyword">this</span>);<span class="comment">//创建Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用sf的run方法，这个方法会进入一个循环，不断等待消息的到来并进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::run() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::waitForEvent() &#123;</span><br><span class="line">    mEventQueue.waitMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="line"><span class="keyword">void</span> MessageQueue::waitMessage() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        <span class="keyword">int32_t</span> ret = mLooper-&gt;pollOnce(<span class="number">-1</span>);<span class="comment">//内部会调用MessageQueue的handleMessage方法对消息进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                ALOGE(<span class="string">"ALOOPER_POLL_ERROR"</span>);</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="comment">// timeout (should not happen)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// should not happen</span></span><br><span class="line">                ALOGE(<span class="string">"Looper::pollOnce() returned unknown status %d"</span>, ret);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过消息的handler对消息进行处理</span></span><br><span class="line"><span class="keyword">void</span> MessageBase::handleMessage(<span class="keyword">const</span> Message&amp;) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handler();</span><br><span class="line">    barrier.open();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SF的消息来源有两种，一个是Vsync信号，这是通过注册的cb_eventReceiver事件回调来处理的，另一种可能是应用进程或者说客户端的消息，比如创建Layer的请求，就是通过发送消息的方式来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"><span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;<span class="comment">//继承子messagbase</span></span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;<span class="comment">//实现了handler 这个方法用于接收方处理消息</span></span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;surfaceFlinger 在init.rc中是作为一个service存在的它声明如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ActivityManagerService-Launcher 启动应用流程</title>
    <link href="http://esligh.github.io/2017/09/19/aosp-startactivity-1/"/>
    <id>http://esligh.github.io/2017/09/19/aosp-startactivity-1/</id>
    <published>2017-09-19T07:30:20.000Z</published>
    <updated>2018-05-19T09:03:09.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h2><p>ActivityManagerService 即活动管理服务，它负责管理我们应用的activity，service等与系统交互的组件，为了方便起见，我们简称为AMS。我们知道Activity在启动过程中会经历一系列的生命周期，这些生命周期反应了AMS创建和管理Activity的整个过程，并且在这之间又同时需要和WindowManagerService进行交互操作，这就导致activity的启动是个异常复杂的工作。本篇不打算对整个流程的细节做过多的分析，只涉及activity启动过程的关键部分。</p><h1 id="activity启动方式-launcher"><a class="markdownIt-Anchor" href="#activity启动方式-launcher"></a> Activity启动方式-Launcher</h1><p>首先activity的启动方式有多种可能的情况，比如最典型的就是点击Launcher上的图标启动，或者在应用内部打开activity进行跳转，还有通过adb 来启动activity，但无论是哪种启动方式，最基本的流程都是类似的。这里我们以Launcher启动作为描述的标准场景来简单了解下在activity启动过程中都会发生什么事情以使activity能够展现在我们眼前。</p><p>Launcher是一个标准的系统桌面应用，它用来管理系统中的所有已安装的app，这些app都是以网格化的形式在Launcher中显示的。我们点击一个app图标就会开始启动整个app并启动它的主activity。</p><p>Launcher启动是会给Intent添加flag Intent.FLAG_ACTIVITY_NEW_TASK,这表示我们会为这个应用创建一个新的任务栈。紧接就是启动指定的activity，正式开始startActivity的启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Only launch using the new animation if the shortcut has not opted out (this is a</span></span><br><span class="line">        <span class="comment">// private contract between launcher and may be ignored in the future).</span></span><br><span class="line">        <span class="keyword">boolean</span> useLaunchAnimation = (v != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);</span><br><span class="line">        <span class="keyword">if</span> (useLaunchAnimation) &#123;</span><br><span class="line">            ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    v.getMeasuredWidth(), v.getMeasuredHeight());</span><br><span class="line">            startActivity(intent, opts.toBundle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startActivity(intent);<span class="comment">//调用activity的startActivity启动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Launcher启动的activity默认添加了<strong>FLAG_ACTIVITY_NEW_TASK</strong>，表示为应用创建新的任务栈。</p><p>这里我们从Launcher启动传递给startActivityForResult的requestCode为-1，说明我们不接受activity的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Activity:   startActivity-&gt;startActivityForResult</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. [Activity.startActivityForResult]===&gt;[Instrumention.execStartActivity]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    Instrumentation.ActivityResult ar =</span><br><span class="line">        mInstrumentation.execStartActivity(</span><br><span class="line">            <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,intent, requestCode, options);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execStartActivity 参数说明,对于Launcher启动：</p><ul><li>who: 为Launcher应用</li><li>mMainThread.getApplicationThread(): 为Launcher的ApplicationThread它是一个Binder</li><li>target: 为this 代表Launcher这个Activity</li><li>requestCode: -1</li><li>intent: 为要启动应用的Activity的意图</li><li>options: null</li></ul><hr><p>这里通过Instrumention来调用execStartActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>.[Instrumention.execStartActivity]===&gt;[AMS.startActivity]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">          IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ……       </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="comment">//通过AMS启动Activity 这个是通过binder调用完成</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            <span class="comment">//检查启动的结果 这里如果Activity在manifest中未注册就会报错</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;&#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Instrumention中会通过ActivityManagerNative获取到AMS的代理，到这里就开始通过Binder进行IPC调用了。我们这里继续看AMS中startActivity的实现，AMS时SystemServer进程中的众多服务之一，关于它启动的细节请参见SystemServer.java.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[AMS.startActivity]===&gt;[AMS.startActivityAsUser]</span><br><span class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String</span></span></span><br><span class="line"><span class="function"><span class="params">callingPackage,Intent intent, String resolvedType, IBinder resultTo,String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">String profileFile, ParcelFileDescriptor profileFd, Bundle options)</span></span>&#123;<span class="comment">//启动流程在AMS的入口</span></span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode,</span><br><span class="line">            startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们对传递的参数做个说明：</p><ul><li>caller：代表Launcher的ApplicationThread 它是个Binder对象</li><li>callingPackage: 调用者即Launcher的包名</li><li>Intent: 要启动的activity的意图</li><li>resolvedType: Intent中指定的MIME类型 一般不指定的为null</li><li>resultTo : token 代表着Launcher的activityRecord的- appToken，实际上就是代表着Launcher.</li><li>resultWho : null</li><li>requestCode:-1</li><li>startFlags : 0</li><li>profileFile:-1</li><li>profileFd:null</li><li>Options:null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[AMS.startActivityAsUser]===&gt;[ASS.startActivityAsUser]</span><br><span class="line">frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String profileFile, ParcelFileDescriptor profileFd, Bundle options, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="comment">//mStackSupervisor是一个ActivityStackSupervisor ，从名字上看是对ActivityStack进行操作的</span></span><br><span class="line">    <span class="comment">//这里callingUid为-1 profileFile为null profileFd为null</span></span><br><span class="line">    <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profileFile, profileFd,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS作为activity的管理者，它很懒，不做什么事情，几乎大部分Service都类似，他们不会真正的做事情，而是交给其他的&quot;代理&quot;对象去做事情。这里的&quot;代理&quot;对象就是ActivityStackSupervisor从名称上来看它负责监控和管理ActivityStack。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callingPackage, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, String profileFile,</span></span></span><br><span class="line"><span class="function"><span class="params">            ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle options, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line"> <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,</span><br><span class="line">            profileFile, profileFd, userId);<span class="comment">//收集参数Intent的相关信息到aInfo中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">    <span class="keyword">int</span> callingPid;<span class="comment">//Launcher:默认传递进来的为-1</span></span><br><span class="line">    <span class="keyword">if</span> (callingUid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        callingPid = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callingPid = Binder.getCallingPid();</span><br><span class="line">        callingUid = Binder.getCallingUid();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callingPid = callingUid = -<span class="number">1</span>;<span class="comment">//Launcher:D</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">………</span><br><span class="line"> <span class="comment">//继续调用startActivityLocked进行启动流程</span></span><br><span class="line">    <span class="keyword">int</span> res = startActivityLocked(caller, intent, resolvedType,</span><br><span class="line">            aInfo, resultTo, resultWho, requestCode, callingPid, callingUid,</span><br><span class="line">            callingPackage, startFlags, options, componentSpecified, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startActivityMayWait方法中会从待启动的activity的intent中获取ActivityInfo，随后再去设置callingPid 和 callingUid为-1.在进一步调用startActivityLocked。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> startFlags, Bundle options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;<span class="comment">//校验调用者进程对于Launcher来说 即Launcher所在的应用进程</span></span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);<span class="comment">//查找调用者在AMS中的ProcessRecord信息</span></span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.pid;<span class="comment">//调用者的进程id</span></span><br><span class="line">            callingUid = callerApp.info.uid;<span class="comment">//调用者的用户id</span></span><br><span class="line">        &#125;……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/做一些权限检测工作</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startAnyPerm = mService.checkPermission(</span><br><span class="line">            START_ANY_ACTIVITY, callingPid, callingUid);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> componentPerm = mService.checkComponentPermission(aInfo.permission, callingPid,</span><br><span class="line">            callingUid, aInfo.applicationInfo.uid, aInfo.exported);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为新的Activity创建ActivityRecord  AMS中AcitivtyRecord用来描述Activity</span></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration,</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//继续调用启动流程 </span></span><br><span class="line">    <span class="comment">//Launcher:sourceRecord保存着Launcher Activity的实体信息 需要注意的是这里doResume参数默认位true</span></span><br><span class="line">    err = startActivityUncheckedLocked(r, sourceRecord, startFlags, <span class="keyword">true</span>, options);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做的事情包括：<br>1.初始化调用者的进程id和用户id,这是通过查找它的ProcessRecord来进行的。<br>2.做一些权限检查，比如调用者的权限和启动组件的权限等<br>3.为待启动的activity创建AtivityRecord，同时会创建appToken，用来代表这个ActivityRecord，间接代表要启动的activity.<br>4.进一步调用startActivityUncheckedLocked来进一步启动，这里的sourceRecord为Launcher的ActivityRecord。r就是我们要启动的activity的activityRecord</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityUncheckedLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord sourceRecord, <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle options)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == <span class="number">0</span>)</span><br><span class="line">                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK</span><br><span class="line">                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Launcher:这里调用findTaskLocked找到是否存在r的实例，这里查找的结果应该是null，因为是从Launcher加载       </span></span><br><span class="line">                ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE</span><br><span class="line">                                    ? findTaskLocked(r)</span><br><span class="line">                                    : findActivityLocked(intent, r.info);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">                &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;<span class="comment">//Launcher：true 需要一个新的task</span></span><br><span class="line">        targetStack = adjustStackFocus(r);</span><br><span class="line">        moveHomeStack(targetStack.isHomeStack());</span><br><span class="line">        <span class="keyword">if</span> (reuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                    newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                    newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                    <span class="keyword">true</span>), <span class="keyword">null</span>, <span class="keyword">true</span>);<span class="comment">//创建TaskRecord 并保存在r的task成员中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.setTask(reuseTask, reuseTask, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        ……</span><br><span class="line">    &#125; </span><br><span class="line">……</span><br><span class="line">mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,intent, r.getUriPermissionsLocked());</span><br><span class="line"></span><br><span class="line">targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">mService.setFocusedActivityLocked(r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步会首先为要启动的activity找到一个task,然而由Launcher启动的时候activity的task还并未创建，这时候需要为其创建一个task并通过setTask设置到r中去。紧接着这里调用startActivityLocked进一步处理，同时将mLastPausedActivity置null,表示当前没有被暂停的activity。将mFocusedActivity设置为当前的activity，表示为焦点activity.对于Launcher启动这里newTask为true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> doResume, <span class="keyword">boolean</span> keepCurTransition, Bundle options)</span> </span>&#123;</span><br><span class="line">TaskRecord rTask = r.task;<span class="comment">//ActivityRecord中存储的TaskRecord</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> taskId = rTask.taskId;</span><br><span class="line"><span class="keyword">if</span> (taskForIdLocked(taskId) == <span class="keyword">null</span> || newTask) &#123;</span><br><span class="line">            insertTaskAtTop(rTask);</span><br><span class="line">            mWindowManager.moveTaskToTop(taskId);</span><br><span class="line"> &#125;</span><br><span class="line">……</span><br><span class="line">task.addActivityToTop(r);<span class="comment">//将ActivityRecord放到task栈的顶部 </span></span><br><span class="line">task.setFrontOfTask();<span class="comment">//将task栈设置为前台栈</span></span><br><span class="line"></span><br><span class="line">r.putInHistory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">                    r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                    (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != <span class="number">0</span>,          r.userId,r.info.configChanges);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked();<span class="comment">//又回到ActivityStackSupervisor</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步首先将要启动的activity对应的ActivityRecord 即r放到其对应TaskRecord的顶部，然后将其Task设置为前台栈.随后为该Activity添加AppWindowToken，这个token时WMS用来标记AMS端的Activity对应的window的。最后调用resumeTopActivitiesLocked进一步处理栈顶activity.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivitiesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resumeTopActivitiesLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivitiesLocked</span><span class="params">(ActivityStack targetStack, ActivityRecord target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle targetOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetStack = getFocusedStack();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = mStacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = mStacks.get(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (isFrontStack(stack)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack == targetStack) &#123;</span><br><span class="line">                    result = stack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityLocked</span><span class="params">(ActivityRecord prev, Bundle options)</span> </span>&#123;</span><br><span class="line"> ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">……</span><br><span class="line">mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">mStackSupervisor.mWaitingVisibleActivities.remove(next);</span><br><span class="line">……</span><br><span class="line"><span class="comment">//暂停当前执行的activity 为栈顶activity启动坐准备</span></span><br><span class="line"><span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving);</span><br><span class="line">          <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;<span class="comment">//当前正在执行的activity</span></span><br><span class="line">               pausing = <span class="keyword">true</span>;</span><br><span class="line">               startPausingLocked(userLeaving, <span class="keyword">false</span>);<span class="comment">//暂定activity</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mNoAnimActivities.contains(next)) &#123;<span class="comment">//如果next不包含入场动画</span></span><br><span class="line">                anim = <span class="keyword">false</span>;</span><br><span class="line">                mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line"><span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">……</span><br><span class="line">mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组方法用来恢复启动task栈顶的activity，其中next即我们要执行的activity，它已经被放在了task栈顶，这里如果next已经在相关的休眠或者停止队列中需要将其从中移除，并重置sleeping状态，这些都是为next的启动做准备。这里最重要的一步就是需要将当前正在执行的mResumedActivity 暂停，这样才能执行task栈顶的activity .这是通过startSpercificActivityLocked来执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来启动我们具体的activity，首先获取activity对应的进程信息ProcessRecord，由于Launcher启动，activity的进程还未创建，所以这里需要为activity创建进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line"> <span class="comment">//为服务或者activity创建新的进程 通过zygote进程执行 创建完成后回调ActivityThread并执行其main方法</span></span><br><span class="line">    Process.ProcessStartResult startResult = Process.start(<span class="string">"android.app.ActivityThread"</span>,</span><br><span class="line">            app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, app.info.seinfo, <span class="keyword">null</span>);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里会通过zygote为activity创建进程，这是通过和zygote进程通过socket通信来完成的，zygote为Activity创建进程后，会调用ActivityThread的main方法。</p><p>我们看看ActivityThread的main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AsyncTask.init();</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程启动后需要创建要给ActivityThread对象，并调用其attach方法。在attach方法中会做许多初始工作。从main方法可以看到进程的主线程是作为ui线程的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ……</span><br><span class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;……&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在attach方法中会调用AMS的attachApplicaton，这里的mAppThread是我们的ApplicationThread对象，它是一个binder服务,在ActivityThread对象创建的时候生成，它在这里传递给AMS，这样AMS就可以使用其代理binder来和应用程序进行通信。比如activity众多的生命周期事件是通过这个binder对象通知应用端的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid);<span class="comment">//进一步调用</span></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">app.makeActive(thread, mProcessStats);</span><br><span class="line">……</span><br><span class="line">thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    app.instrumentationClass, profileFile, profileFd, profileAutoStop,</span><br><span class="line">                    app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(mConfiguration), app.compat, getCommonServicesLocked(),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app, mHeadless)) &#123;</span><br><span class="line">                    didSomething = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                badApp = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">        <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                badApp = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里AMS做一些初始化工作后 又会调用到应用端的bindApplication。应用端会在这个时机为应用创建Application对象，随后AMS分别调用mStackSupervisor和mServices的attachApplicationLocked，这里会将等待启动的acitivty或者service启动起来。后面我们继续分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">                ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers,</span></span></span><br><span class="line"><span class="function"><span class="params">                ComponentName instrumentationName, String profileFile,</span></span></span><br><span class="line"><span class="function"><span class="params">                ParcelFileDescriptor profileFd, <span class="keyword">boolean</span> autoStopProfiler,</span></span></span><br><span class="line"><span class="function"><span class="params">                Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> enableOpenGlTrace, <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent,</span></span></span><br><span class="line"><span class="function"><span class="params">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span></span></span><br><span class="line"><span class="function"><span class="params">                Bundle coreSettings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里会通过H对象 其实是个handler 来发送BIND_APPLICATION消息，这会调用handleBindApplication方法来处理该消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line"> Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">            mInitialApplication = app;</span><br><span class="line">……</span><br><span class="line">mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用端的handleBindApplication时会为应用创建application对象，同时调用onCreate回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> headless)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = mStacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">           <span class="keyword">final</span> ActivityStack stack = mStacks.get(stackNdx);</span><br><span class="line">           <span class="keyword">if</span> (!isFrontStack(stack)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ActivityRecord hr = stack.topRunningActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (hr != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (hr.app == <span class="keyword">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                       &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (headless) &#123;</span><br><span class="line"></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realStartActivityLocked(hr, app, <span class="keyword">true</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                           didSomething = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       Slog.w(TAG, <span class="string">"Exception in new application when starting activity "</span></span><br><span class="line">                             + hr.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                       <span class="keyword">throw</span> e;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">           ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>AMS回调完成应用端的application初始化后，会进一步调用attachApplicationLocked来继续执行activity的任务。在这个方法中首先取到前台的ActivityStack，然后找到task栈顶的activity，最后通过realStartActivityLocked来真正的启动hr所代表的activity.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">……</span><br><span class="line">mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line">……</span><br><span class="line">        r.app = app;</span><br><span class="line">          app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">          r.launchCount++;</span><br><span class="line">          r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line">……</span><br><span class="line">app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(mService.mConfiguration), r.compat,</span><br><span class="line">                    app.repProcState, r.icicle, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profileFile, profileFd,</span><br><span class="line">                    profileAutoStop);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，WMS会将app的设置为可见，这里是将r.appToken作为key的，这个appToken是我们在为activity创建ActivityRecord时创建的，它作为一个Binder用来在WMS端标记我们的activity,同时也可以和WMS通信。随后通知应用端开始加载Activity,App.thread就是我们的ApplicationThread，它是在进程创建后，应用端的binder server，主要被AMS使用和应用端的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent,            IBinder token, <span class="keyword">int</span> ident,ActivityInfo info, </span></span></span><br><span class="line"><span class="function"><span class="params">    Configuration curConfig, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> procState, Bundle state, List&lt;ResultInfo&gt; pendingResults,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Intent&gt; pendingNewIntents, <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward,String profileName, ParcelFileDescriptor profileFd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoStopProfiler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;<span class="comment">//token? 这个token实际上就是ActivityRecord的appToken 代表了待启动的Activity</span></span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line"></span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">    r.profileFile = profileName;</span><br><span class="line">    r.profileFd = profileFd;</span><br><span class="line">    r.autoStopProfiler = autoStopProfiler;</span><br><span class="line"></span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在scheduleLaunchActivity中构造了一个 ActivityClientRecord对象，随后发送H_LAUNCH_ACTIVITY，然后调用handleLaunchActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        <span class="comment">//紧接着执行resume activity的流程</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就开始加载activity，首先是调用performLaunchActivity，这里面会去调用onCreate和onStart等回调，而handleResumeActivity中会将activity显示出来，并调用onResume回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            <span class="comment">//创建activi的实例</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//为activity创建context 实际上为contextImpl</span></span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">        Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">        <span class="comment">//调用activity的attach进行初始化 </span></span><br><span class="line">        </span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.mIntent = customIntent;</span><br><span class="line">        &#125;</span><br><span class="line">        r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">        activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">        <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">            activity.setTheme(theme);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//回调onCreate</span></span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.activity = activity;</span><br><span class="line">        r.stopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">            activity.performStart();<span class="comment">//onStart回调</span></span><br><span class="line">            r.stopped = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    r.paused = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    mActivities.put(r.token, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要创建activity对象，并为其创建context，实际上为contextImpl，通过attach方法将context设置到activity中。同时为activity设置window，即PhoneWindow.<br>随后回调onCreate，onStart等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();<span class="comment">//取到decorView</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();<span class="comment">//取到WindowManager实际为WindowManagerImpl</span></span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;<span class="comment">//window类型 测量Z序会用到</span></span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            wm.addView(decor, l);<span class="comment">//这里会添加window到WMS中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就真正的将activity相应的window添加到了WMS中，activity被显示在桌面上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#综述&quot;&gt;&lt;/a&gt; 综述&lt;/h2&gt;
&lt;p&gt;ActivityManagerService 即活动管理服务，它负责管理我们应用的activity，service等与系统交互的组件，为了方便起
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Vsync信号图形绘制-Choreographer源码分析</title>
    <link href="http://esligh.github.io/2017/09/10/aosp-choreographer/"/>
    <id>http://esligh.github.io/2017/09/10/aosp-choreographer/</id>
    <published>2017-09-10T12:30:20.000Z</published>
    <updated>2018-05-19T10:14:31.597Z</updated>
    
    <content type="html"><![CDATA[<p>Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。</p><p>Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vsync信号。垂直信号到来后就要开始准备绘制下一帧的数据。Choreographer主要是在ViewRootImpl中使用的，ViewRootImpl是view树的管理者，负责view树的逻辑处理及事件事件输入。</p><p>所有的绘制流程是从ViewRootImpl.java的scheduleTraversals开始的，这个方法会去请求vsync信号，并在信号到来时去绘制更新ui。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//请求vsync信号，当vsync信号到达后开始mTraversalRunnable任务,垂直信号的接受由ChoreoGrpaher负责</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们不关心具体的绘制过程，主要是看Choreographer如何通过vysnc信号来协调界面的绘制。<br>这里首先是通过Choreographer对象mChoreographer对象post了一个回调，告诉Choreographer当vsync信号到达时帮我调用mTraversalRunable回调。这个回调的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();<span class="comment">//vsync信号到达后执行绘制流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure><p>doTraversal()内部会调用performTraversals()方法，从而开启view绘制的三大流程。</p><p>下面我们看看Choreographer是如何将vsync接受信号并告之ViewRoomImpl的刷新回调的。我们就从这个postCallback入手分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">        postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//post一个延时回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将请求的回调按照相应的类型添加到回调队列中，这里会根据一个失效时间来构造</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;<span class="comment">//延时为0时调用 ，对于scheduleTraversals走这里</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postCallback最终会调用postCallbackDelayedInternal，参数delayMillis为0，所以会调用scheduleFrameLocked进一步进行操作。这里需要注意的是每次请求都会添加到其类型对应的回调队列中， 这里的mCallbackQueues是一个根据类型区分的回调队列，有四种类型，分别是输入回调，动画回调和绘制回调以及Choreographer.CALLBACK_COMMIT。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;<span class="comment">//使用vsync信号更新</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">            <span class="comment">// as soon as possible.</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//通过ui线程发送请求等待一个vsync信号 </span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">这个USE_VSYNC代表我们系统使用vsync信号进行屏幕信号的同步，这个方法是在我们的ui线程操作的，所以会发送MSG_DO_SCHEDULE_VSYNC请求vsync信号。这里的mHandler是一个FrameHandler</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();<span class="comment">//请求vsync信号</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用doScheduleVsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();<span class="comment">//请求vsync信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mDisplayEventReceiver是一个FrameDisplayEventReceiver对象，它继承了DisplayEventReceiver，其中实现了其方法onVsync，这个方法就是当onVsync信号到达时的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//垂直信号到达</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore vsync from secondary display.</span></span><br><span class="line">    <span class="comment">// This can be problematic because the call to scheduleVsync() is a one-shot.</span></span><br><span class="line">    <span class="comment">// We need to ensure that we will still receive the vsync from the primary</span></span><br><span class="line">    <span class="comment">// display which is the one we really care about.  Ideally we should schedule</span></span><br><span class="line">    <span class="comment">// vsync for a particular display.</span></span><br><span class="line">    <span class="comment">// At this time Surface Flinger won't send us vsyncs for secondary displays</span></span><br><span class="line">    <span class="comment">// but that could change in the future so let's log a message to help us remember</span></span><br><span class="line">    <span class="comment">// that we need to fix this.</span></span><br><span class="line">    <span class="comment">//并不是sf内置的display</span></span><br><span class="line">    <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Received vsync from secondary display, but we don't support "</span></span><br><span class="line">                + <span class="string">"this case yet.  Choreographer needs a way to explicitly request "</span></span><br><span class="line">                + <span class="string">"vsync for a specific display to ensure it doesn't lose track "</span></span><br><span class="line">                + <span class="string">"of its scheduled vsync."</span>);</span><br><span class="line">        scheduleVsync();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></span><br><span class="line">                + <span class="string">"timestamps using the correct timebase."</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);<span class="comment">//垂直信号到来触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直信号vsync到来后会触发doFrame，在这个方法里面会进行我们的回调，即mTraversalRunnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    …… </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);<span class="comment">//回调输入事件的相关回调</span></span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);<span class="comment">//回调动画相关的回调</span></span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);<span class="comment">//回调绘制相关的回调</span></span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);<span class="comment">//获取相关类型的回调</span></span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"RunCallback: type="</span> + callbackType</span><br><span class="line">                        + <span class="string">", action="</span> + c.action + <span class="string">", token="</span> + c.token</span><br><span class="line">                        + <span class="string">", latencyMillis="</span> + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">            &#125;</span><br><span class="line">            c.run(frameTimeNanos);<span class="comment">//调用回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据类型从队列中取出相应的回调进行调用。这个就是上层对于vsync的处理。接下来我们看看底层的vsync信号是如何传递给Choreographer的。这就需要看看FrameDisplayEventReceiver的父类DisplayEventReceiver，这个DisplayEventReceiver会通过native层进行初始化，native层通过它的成员方法dispatchVsync将vsync信号报告给上层，即调用onVsync。我们先看其构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="keyword">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);<span class="comment">//初始化接收器</span></span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其构造方法是调用nativeInit进行初始化的，并将当前对象this作为一个接收器传递给底层。我们看看这个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span><br><span class="line"><span class="comment">//注册显示事件接收器 receiverWeak即DisplayEventReceiver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个messageQueue是通过ui线程的Looper构造的</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);<span class="comment">//创建本地接收器</span></span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();<span class="comment">//初始化native的接受器</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to initialize display event receiver.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化方法中会创建本地的接受器对象，它同时是用我们传递的java层的接受器对象构造的，构造完成后即进行初始化。这个NativeDisplayEventReceiver的定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native的显示事件接受器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeDisplayEventReceiver</span> :</span> <span class="keyword">public</span> DisplayEventDispatcher &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">            jobject receiverWeak, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NativeDisplayEventReceiver();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jobject mReceiverWeakGlobal;<span class="comment">//java层的接收器对象</span></span><br><span class="line">    sp&lt;MessageQueue&gt; mMessageQueue;</span><br><span class="line">    DisplayEventReceiver mReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dispatchHotplug</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">bool</span> connected)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NativeDisplayEventReceiver继承自DisplayEventDispatcher，而DisplayEventDispatcher又实现了LooperCallback的接口handleEvent，这个方法是Looper的事件回调，也就是当Looper接受到消息后会对其进行调用，那么这个DisplayEventDispatcher就是负责进行消息事件的转发的。后面我们看看它是如何将vsync信号转发的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化receiver</span></span><br><span class="line"><span class="keyword">status_t</span> DisplayEventDispatcher::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);<span class="comment">//添加事件侦听,这里的this代表注册的是一个LooperCallback,</span></span><br><span class="line">                        <span class="comment">//当事件到达后会调用其handleEvent方法,这个可以具体参见Looper的实现</span></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的addFd将其注册到为Looper的事件回调，注意这里第四个参数this，因为DisplayEventDispatcher是继承LooperCallback的。这样当事件到来后会调用handleEvent。</p><p>还有，在NativeDisplayEventReceiver的内部持有一个DisplayEventReceiver对象，这个对象比较重要，它是负责和Sf打交道的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//通过sf建立连接，这里就应该很熟悉了，这个连接创建好后在第一次引用时会去注册到EventThread中</span></span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = <span class="built_in">std</span>::make_unique&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;stealReceiveChannel(mDataChannel.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection(</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vsyncSource == eVsyncSourceSurfaceFlinger) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSFEventThread-&gt;createEventConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果时app端的就走这里</span></span><br><span class="line">        <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚说到DisplayEventReceiver是和Sf打交道的， 它和NativeDisplayEventReceiver是同时创建的。在其构造方法中首先通过sf的createDisplayEventConnection创建一个连接对象即Connection对象，mEventThread是管理绘图延时对象的vsync信号处理，它是一个EventThread。Connection就是由它创建的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));<span class="comment">//创建一个新的连接，这个连接在第一个被引用时会去进行注册</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个connection在第一次被引用时会进行注册，即将其添加到mEventThread的连接队列，在vsync消息到来时调用其postEvent方法对事件进行转发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册创建的连接，实际上时将创建的连接添加到监听队列，并通知等待的线程</span></span><br><span class="line"><span class="keyword">status_t</span> EventThread::registerDisplayEventConnection(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mDisplayEventConnections.add(connection);<span class="comment">//添加到连接队列中</span></span><br><span class="line">    mCondition.broadcast();<span class="comment">//唤醒等待的线程</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);<span class="comment">//post事件</span></span><br><span class="line">……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(</span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postEvent实际上会调用DisplayEventReceiver的setEvents方法，这样会触发getEvents的回调从而通过DisplayEventDispatcher的handleEvent回调方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel,</span><br><span class="line">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);<span class="comment">//发送接受到的事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DisplayEventDispatcher::handleEvent(<span class="keyword">int</span>, <span class="keyword">int</span> events, <span class="keyword">void</span>*)&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;<span class="comment">//丢弃所有的等待事件，只保留上次的vsync信号事件</span></span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Vsync pulse: timestamp=%"</span> PRId64 <span class="string">", id=%d, count=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);<span class="comment">//分派vsync信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DisplayEventDispatcher::processPendingEvents(</span><br><span class="line">        <span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount) &#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;<span class="comment">//等待事件到来</span></span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Read %d events."</span>, <span class="keyword">this</span>, <span class="keyword">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That's fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;<span class="comment">//timestamp</span></span><br><span class="line">                *outId = ev.header.id;<span class="comment">//id</span></span><br><span class="line">                *outCount = ev.vsync.count;<span class="comment">//count</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line"></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.get()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Invoking vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Returned from vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"dispatchVsync"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用NativeDisplayEventReceiver的dispatchVsync回调给java层的dispatchVsync，这样vsync信号就传递给上层应用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。&lt;/p&gt;
&lt;p&gt;Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vs
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SparseArray源码分析</title>
    <link href="http://esligh.github.io/2017/07/19/android-libray-sparsearray-src/"/>
    <id>http://esligh.github.io/2017/07/19/android-libray-sparsearray-src/</id>
    <published>2017-07-19T11:23:50.000Z</published>
    <updated>2018-05-19T11:53:20.674Z</updated>
    
    <content type="html"><![CDATA[<p>SparseArray，SparseIntArray,SparseBooleanArray等是Android官方提倡使用的高效数据结构。它同java中的HashMap类似属于存储键值对的集合。但同HashMap相比它更加轻量，执行效率更高。下面我们就对SparseArray的源码进行解读，了解它内部的执行原理。</p><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><p>在KitKat中的源码位置：</p><blockquote><p>frameworks/base/core/java/android/util/SparseArray.java</p></blockquote><p>首先我们从其构造函数入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line"> <span class="keyword">private</span> Object[] mValues;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> mSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SparseArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SparseArray</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            mKeys = ContainerHelpers.EMPTY_INTS;</span><br><span class="line">            mValues = ContainerHelpers.EMPTY_OBJECTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);</span><br><span class="line">            mKeys = <span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">            mValues = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化时传递的initialCapacity大小为10，但这个只是一个参考值，随后又通过ArrayUtils.idealIntArraySize对初始值进行了调整，从函数名字上看这个方法会根据参考值返回一个比较理想容量大小。我们看看它是如何计算的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idealIntArraySize</span><span class="params">(<span class="keyword">int</span> need)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idealByteArraySize(need * <span class="number">4</span>) / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idealByteArraySize</span><span class="params">(<span class="keyword">int</span> need)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (need &lt;= (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>)</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算的结果是一个2的幂次方的数减去12，对于SparseArray还需要再除以4作为结果返回，这里返回的值为     (1&lt;&lt;6-12)/4 = 13 。</p><p>这里有个疑惑就是为什么需要对初始值进行重新计算得到SparseArray的容量大小？</p><h3 id="获取元素"><a class="markdownIt-Anchor" href="#获取元素"></a> 获取元素</h3><p>可以看出SparseArray内部是通过数组来实现的，相比hashMap的hash表和链表要轻量一些。我们先看看它的get方法如何实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || mValues[i] == DELETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> valueIfKeyNotFound;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部逻辑非常简单，通过key来进行二分查找，这么说键值在mKeys中的存储是有序的。<br>这就要求在添加元素中做保证。这里二分搜索的结果是key值所在的索引值i，这个索引在mValues中对应的数据就是key对应的值，可见mKeys和mValues是一一对应的，只是分别存储在两个数组中罢了。这里如果查找到会返回索引值i，如果i小于0说明没有找到，同时如果i所在的value已经失效即为DELETE，则也算没有找到value值，返回默认的valueIfKeyNotFound，否则返回mValues[i]作为结果。</p><blockquote><p>frameworks/base/core/java/android/util/ContainerHelpers.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分搜索，这里就不需要做解释了，需要注意的是如果找到了key值，则返回其在array中的索引mid，否则返回~lo，lo代表了所查找key值所应该存在的位置，这里取反是为了说明key值不存在该位置，但如果需要添加key值对应的value就可以将其放在lo处。</p><h3 id="添加元素"><a class="markdownIt-Anchor" href="#添加元素"></a> 添加元素</h3><p>我们知道二分搜索是基于有序序列进行的操作，那么在我们添加元素也就是put时需要保证数组的有序性，我们接下来看看put的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ArrayUtils.idealIntArraySize(mSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] nkeys = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            Object[] nvalues = <span class="keyword">new</span> Object[n];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Log.e("SparseArray", "grow " + mKeys.length + " to " + n);</span></span><br><span class="line">            System.arraycopy(mKeys, <span class="number">0</span>, nkeys, <span class="number">0</span>, mKeys.length);</span><br><span class="line">            System.arraycopy(mValues, <span class="number">0</span>, nvalues, <span class="number">0</span>, mValues.length);</span><br><span class="line"></span><br><span class="line">            mKeys = nkeys;</span><br><span class="line">            mValues = nvalues;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSize - i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Log.e("SparseArray", "move " + (mSize - i));</span></span><br><span class="line">            System.arraycopy(mKeys, i, mKeys, i + <span class="number">1</span>, mSize - i);</span><br><span class="line">            System.arraycopy(mValues, i, mValues, i + <span class="number">1</span>, mSize - i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys[i] = key;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>put同样一开始先binarySearch查找key值是否已经存在，如果存在，只需更新索引i处的value。</p></li><li><p>否则我们对i进行取反，这里取反后的i值我们知道就是key值应该存放的位置。<br>随后判断i是否小于mSize 且 mValues对应i处的值已经失效，如果失效了就直接替换该处的值即可。否则看是否需要进行gc(看mGarbage是否置为true且当前的数组已经满了)，这里的gc是指对失效元素进行回收，并重新计算大小。gc完后会再次计算key值索引，因为数组大小可能发生了变化。</p></li><li><p>如果gc后数组依旧时满的，这就需要我们再开辟空间了，同样调用ArrayUtils.idealIntArraySize重新计算容量，然后创建数组，并将mKeys和mValues拷贝到新的数组中。</p></li><li><p>如果mSize-i！=0 说明要在数组间插入key值，这个需要将索引i后的元素统一向后挪动一个位置为key值腾出一个位置。</p></li><li><p>将key值对应的value分别放在mKeys和mValues中并递增mSize。</p></li></ol><h3 id="gc的回收策略"><a class="markdownIt-Anchor" href="#gc的回收策略"></a> gc的回收策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gc负责将已经清理失效的value(即等于DELETED)，并重新计算mSize。</p><p>在SparseArray的众多方法中都有可能调用gc方法比如size,keyAt,valueAt等等，以此来分摊可能进行的gc的执行时间。</p><p>在SparseArray中还有一个比put更加高效的方法append,它首先判断key值是否比数组末尾的key值还要大，如果是的话就只需将其添加到末尾就行了，因为它保证了有序性。否则就调用put来添加该key-value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSize != <span class="number">0</span> &amp;&amp; key &lt;= mKeys[mSize - <span class="number">1</span>]) &#123;</span><br><span class="line">        put(key, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = mSize;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= mKeys.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = ArrayUtils.idealIntArraySize(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nkeys = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Object[] nvalues = <span class="keyword">new</span> Object[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Log.e("SparseArray", "grow " + mKeys.length + " to " + n);</span></span><br><span class="line">        System.arraycopy(mKeys, <span class="number">0</span>, nkeys, <span class="number">0</span>, mKeys.length);</span><br><span class="line">        System.arraycopy(mValues, <span class="number">0</span>, nvalues, <span class="number">0</span>, mValues.length);</span><br><span class="line"></span><br><span class="line">        mKeys = nkeys;</span><br><span class="line">        mValues = nvalues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mKeys[pos] = key;</span><br><span class="line">    mValues[pos] = value;</span><br><span class="line">    mSize = pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SparseArray的delete方法同样是它高效的体现，它并不真正的将key-value从数组中移除，而仅仅是将value标记为失效，同时把mGarbage置为true代表需要进行gc,这样做原因是，随后可能存在key值又加入进来的情况，这样我们就仅需将已经失效的元素换成我们添加的value值即可，可以参见Put方法的第二步说明。这样避免了数组的频繁抖动引起的性能问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SparseArray，SparseIntArray,SparseBooleanArray等是Android官方提倡使用的高效数据结构。它同java中的HashMap类似属于存储键值对的集合。但同HashMap相比它更加轻量，执行效率更高。下面我们就对SparseArray
      
    
    </summary>
    
      <category term="Android library" scheme="http://esligh.github.io/categories/Android-library/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="http://esligh.github.io/2017/07/19/jdk-arraylist-src/"/>
    <id>http://esligh.github.io/2017/07/19/jdk-arraylist-src/</id>
    <published>2017-07-19T11:23:50.000Z</published>
    <updated>2018-05-19T11:43:53.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承关系"><a class="markdownIt-Anchor" href="#继承关系"></a> 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ArrayList是开发者广泛使用的java集合，它继承自AbstractList 实现了List接口，支持随机访问以及拷贝，持久化。</p><p>本篇主要对ArrayList的实现进行分析，首先我们看它的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        size = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList的构造方法很简单，主要是初始化elementData值，它是一个Object数组用来存储我们的元素。根据参数的不同实现也不同。</p><h3 id="元素添加"><a class="markdownIt-Anchor" href="#元素添加"></a> 元素添加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用ensureCapacityInternal来确保有足够的容量来存储e,随后将e保存在elementData数组中并增加size值 默认返回true。</p><p>在指定索引处添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将元素element添加到数组中指定的index位置，所以效率上比add要慢，因为可能需要对数组元素进行挪动。同样这里需要保证足够的空间，并在添加完成后增加size计数。</p><p>我们看看ensureCapacityInternal是如何保证容量大小的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DEFAULT_CAPACITY默认为10，也就是说第一次添加到ArrayList的时候会开辟大小为10的数组。如果需要的大小大于当先数组的大小需要调用grow来完成容量的增加。</p><p>grow的resize逻辑如下：</p><ol><li>计算新的容量大小为  int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)<br>这个新的容量为原来的3倍。</li><li>如果新的容量小于我们需要的 则以我们需要的为准开辟空间</li><li>如果新的容量大于最大可以开辟的容量值(Integer.MAX_VALUE - 8)，那么需要hugeCapacity进行大容量的分配</li><li>使用Arrays的copyOf将原数组resize到指定大小</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;继承关系&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承关系&quot;&gt;&lt;/a&gt; 继承关系&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://esligh.github.io/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="java" scheme="http://esligh.github.io/tags/java/"/>
    
      <category term="jdk" scheme="http://esligh.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步机制源码分析</title>
    <link href="http://esligh.github.io/2016/08/25/jdk-aqs-src/"/>
    <id>http://esligh.github.io/2016/08/25/jdk-aqs-src/</id>
    <published>2016-08-25T13:00:07.000Z</published>
    <updated>2018-05-19T11:32:53.183Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们主要分析AQS独占模式的源码，关于AQS的独占模式我们上一篇有所介绍。主要这里我们介绍acquire和release部分的代码。这会涉及到AQS的阻塞唤醒机制，还有其维护的FIFO队列。</p><h2 id="阻塞过程"><a class="markdownIt-Anchor" href="#阻塞过程"></a> 阻塞过程</h2><h3 id="独占模式下的阻塞过程"><a class="markdownIt-Anchor" href="#独占模式下的阻塞过程"></a> 独占模式下的阻塞过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire返回boolean值，true代表状态更新成功线程继续，否则当前线程需要阻塞，并添加到队列中。这里addWaiter会为当前线程创建Node并添加到队列中。因为是独占模式节点模式为Node.EXCLUSIVE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter中首先创建线程节点node,如果tail不为null说明队列不为空，通过CAS将node添加到队尾，然后返回，否则需要调用enq创建队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq会创建队列，通过CAS创建头尾节点，然后将node添加进去返回。</p><p>我们看看AQS中队列的节点信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>AQS队列是通过head和tail节点来维护的，其中Node节点分别有前驱和后继节点。<br>它是一个简单的队列结构，而保证线程节点能够正确添加到队列中正是基于CAS，这使得它是一个非阻塞式的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加Node到队列中后，有可能会阻塞当前线程，这里获取当前node的前驱，如果前驱是head表示当前线程已经变成队列中的第一个元素，并再次尝试tryAcquire，如果返回true表示同步状态更新成功则返回。如果不是第一个元素，则通过shouldParkAfterFailedAcquire判断是否应该park当前线程，返回true表示应该阻塞线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只有当node的前驱节点的waitStatus为Node.SIGNAL时才会返回true，此时表示前驱节点会unPark node节点的线程，所以可以park这个线程。如果前驱节点不满足这个条件，就需要查找一个不为CANCELED的节点作为node的前驱，并更新它的waitStatus为SIGNAL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的阻塞是在parkAndCheckInterrupt中进行的，阻塞使用了LockSupport的park。这样当前线程就阻塞在acquireQueued的for循环中等待被唤醒。</p><h3 id="共享模式下的阻塞过程"><a class="markdownIt-Anchor" href="#共享模式下的阻塞过程"></a> 共享模式下的阻塞过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在共享模式下的逻辑类似于独占模式，tryAcquireShared返回负值代表未获取到同步状态需要阻塞，这里是通过doAcquireShared来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">不同于独占模式下的阻塞模式，这里首先针对当前线程创建Node.SHARED节点，使用addWaiter添加到阻塞队列中，随后的逻辑基本和独占模式类似，即通过一个循环来判断当前节点是否满足唤醒的条件:<span class="number">1</span> 当前节点是阻塞队列的第一个节点，且再次通过tryAcqurireShared获取到了同步状态，对于共享模式来说即满足 r&gt;=<span class="number">0</span>，随后将本节点node设置为头结点根据需要设置中断返回。阻塞的逻辑同独占模式下，这里就不再赘述。</span><br><span class="line"></span><br><span class="line">## 唤醒操作</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类的实现tryRelease返回true表示释放了同步状态，这时候就可以唤醒当前node节点所代表线程的后继节点了。这一步是通过unparkSuccessor实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里取到当前队列的下一个node节点，并通过LockSupport.unpark解除相应线程的阻塞状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇我们主要分析AQS独占模式的源码，关于AQS的独占模式我们上一篇有所介绍。主要这里我们介绍acquire和release部分的代码。这会涉及到AQS的阻塞唤醒机制，还有其维护的FIFO队列。&lt;/p&gt;
&lt;h2 id=&quot;阻塞过程&quot;&gt;&lt;a class=&quot;markdownIt-
      
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://esligh.github.io/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="java" scheme="http://esligh.github.io/tags/java/"/>
    
      <category term="jdk" scheme="http://esligh.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Volley网络库源码分析</title>
    <link href="http://esligh.github.io/2015/11/19/android-libray-volley-src/"/>
    <id>http://esligh.github.io/2015/11/19/android-libray-volley-src/</id>
    <published>2015-11-19T13:32:18.000Z</published>
    <updated>2018-05-19T14:42:33.077Z</updated>
    
    <content type="html"><![CDATA[<h3 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h3><p>volley有三个层次的线程，分别为main thread、cache thread 以及network thrads。RequestQueue会维护一个缓存调度线程和一个网络调度线程，当一个Request被加入到队列中时，cache线程会对其进行筛选，如果这个请求的内容可以在缓存中找到，cache线程会亲自解析相应内容，并分发到UI线程。如果缓存中没有，这个请求就会被加入到NetWorkQueue中，所有真正准备进行网络通信的Request都在这里，第一个可用的net线程会从Queue中取出一个请求发送给服务器。当响应数据到的时候，这个net线程会解析原始响应数据并缓存，随后将解析的结果发送给主线程。</p><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><p>首先在使用中，我们会在应用中创建一个请求队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRequestQueue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>newRequestQueue的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volley.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">    String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">           String packageName = context.getPackageName();</span><br><span class="line">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">           userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建请求队列中，我们还会创建一个BasicNetWork 这是volley使用的网络请求库，通过一个httpstack 对象来初始化，HttpStack是一个网络请求的接口。可以看到，在SDK版本小于9时默认使用的是HttpClient ，否则就用HttpUrlConnection当做其请求库。随后创建完queue后就启动该请求队列。在看start之前我们先看看RequestQueue类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">       <span class="comment">/** Used for generating monotonically-increasing sequence numbers for requests. */</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger mSequenceGenerator = <span class="keyword">new</span> AtomicInteger(); </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Staging area for requests that already have a duplicate request in flight.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">        *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</span></span><br><span class="line"><span class="comment">        *          key.&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</span></span><br><span class="line"><span class="comment">        *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests =</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;(); </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The set of all requests currently being processed by this RequestQueue. A Request</span></span><br><span class="line"><span class="comment">        * will be in this set if it is waiting in any queue or currently being processed by</span></span><br><span class="line"><span class="comment">        * any dispatcher.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();<span class="comment">//请求队列</span></span><br><span class="line">       <span class="comment">/** The cache triage queue. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mCacheQueue =</span><br><span class="line">           <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;(); <span class="comment">//缓存阻塞队列</span></span><br><span class="line">       <span class="comment">/** The queue of requests that are actually going out to the network. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue =</span><br><span class="line">           <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;(); <span class="comment">//网络请求阻塞队列</span></span><br><span class="line">       <span class="comment">/** Number of network request dispatcher threads to start. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>; <span class="comment">//默认线程池大小</span></span><br><span class="line">       <span class="comment">/** Cache interface for retrieving and storing respones. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Cache mCache; <span class="comment">//使用的缓存对象</span></span><br><span class="line">       <span class="comment">/** Network interface for performing requests. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Network mNetwork; <span class="comment">//使用的网络请求对象</span></span><br><span class="line">       <span class="comment">/** Response delivery mechanism. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ResponseDelivery mDelivery;<span class="comment">//转发器</span></span><br><span class="line">       <span class="comment">/** The network dispatchers. */</span></span><br><span class="line">       <span class="keyword">private</span> NetworkDispatcher[] mDispatchers; <span class="comment">//网络调度线程</span></span><br><span class="line">       <span class="comment">/** The cache dispatcher. */</span></span><br><span class="line">       <span class="keyword">private</span> CacheDispatcher mCacheDispatcher; <span class="comment">//缓存调度线程</span></span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestQueue包含了多个队列和调度器以及一个ResponseDelivery转发器，这里NetworkDispatcher和CacheDispatcher都是继承自Thread类。<br>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">           ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mNetwork = network;</span><br><span class="line">       mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">               <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//RequestQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">       <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line">       <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">       NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                   mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在start中，创建了缓存调度线程（一个）和网络调度线程（四个）,并启动它们。也就是说，在我们创建了请求队列后，就有5个线程在后台运行，不断等待网络请求的到来。<br>我们创建好请求队列后，我们一般会add到该队列，所以看下add的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">       request.setRequestQueue(<span class="keyword">this</span>);<span class="comment">//设置请求所属队列</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">           mCurrentRequests.add(request);<span class="comment">//添加该请求</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">       request.setSequence(getSequenceNumber());<span class="comment">//得到该请求序列</span></span><br><span class="line">       request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">       <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></span><br><span class="line">       <span class="keyword">if</span> (!request.shouldCache()) &#123; <span class="comment">//判断是否可缓存</span></span><br><span class="line">           mNetworkQueue.add(request);<span class="comment">//不可缓存的话就直接添加到网络请求队列中</span></span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">           String cacheKey = request.getCacheKey();<span class="comment">//得到请求的key，实际上就是请求的url</span></span><br><span class="line">           <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123; <span class="comment">//等待请求map表中已经存在该请求了</span></span><br><span class="line">               <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">               Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);<span class="comment">//获取该请求对应的等待队列</span></span><br><span class="line">               <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               stagedRequests.add(request); <span class="comment">//添加请求进来</span></span><br><span class="line">               mWaitingRequests.put(cacheKey, stagedRequests);<span class="comment">//重置请求的map</span></span><br><span class="line">               <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                   VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">//请求目前还未添加进缓存队列</span></span><br><span class="line">               <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line">               <span class="comment">// flight.</span></span><br><span class="line">               mWaitingRequests.put(cacheKey, <span class="keyword">null</span>); </span><br><span class="line">               mCacheQueue.add(request); <span class="comment">//添加到缓存队列</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要针对需要缓存的request说下，volley默认的request是需要缓存的，在需要缓存是，主要针对mWaitingRequests这个map表进行操作。这map表主要用来记录对应每个请求目前的请求队列，因为volley在网络出现问题后会对再次request进行重试，而重试的次数是可以设置的，重试一旦超过设置值就会超时。这里用mWaitingRequests就是来记录重试队列的。<br>在应用层添加完request后，缓存调度线程就可以处理这个request了，所以看看CacheDispatcher的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheDispatcher </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">   <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">   mCache.initialize(); <span class="comment">//缓存初始化</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">           <span class="comment">// at least one is available.</span></span><br><span class="line">           <span class="keyword">final</span> Request request = mCacheQueue.take(); <span class="comment">//取一个请求出来</span></span><br><span class="line">           request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line">           <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">           <span class="keyword">if</span> (request.isCanceled()) &#123; <span class="comment">//如果被取消了就continue</span></span><br><span class="line">               request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">           Cache.Entry entry = mCache.get(request.getCacheKey()); <span class="comment">//取该request对应的缓存</span></span><br><span class="line">           <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">              request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">              <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">              mNetworkQueue.put(request); <span class="comment">//没有缓存就直接添加到网络请求队列中，然后continue</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line">           <span class="keyword">if</span> (entry.isExpired()) &#123; <span class="comment">//缓存是否过期</span></span><br><span class="line">                   request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                   request.setCacheEntry(entry);</span><br><span class="line">                   mNetworkQueue.put(request); <span class="comment">//如果过期，同样需要添加到网络请求队列中</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">               <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">           request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">           <span class="comment">//这里就算缓冲命中了</span></span><br><span class="line">           Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                       <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">           request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">           <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">              <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">              mDelivery.postResponse(request, response); <span class="comment">//通过转发器递交响应给Main Thread</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">//缓存命中了，但是需要刷新的情况</span></span><br><span class="line">                   <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">                   <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">                   <span class="comment">// refreshing.</span></span><br><span class="line">                   request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                   request.setCacheEntry(entry);</span><br><span class="line">                   <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                   response.intermediate = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                   <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                   <span class="comment">//先递交响应给main thread  随后在将该请求添加到网络请求队列以刷新缓存</span></span><br><span class="line">                   mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               mNetworkQueue.put(request);</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                               <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">               <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总体来说CacheDispatcher的处理流程很简单 ，主要的内容在注释我做了说明。在取到一个request后，需要该请求是否存在缓存，该缓存是否过期，是否需要刷新等问题。<br>接下来在看看NetworkDispatcher这个网络调度线程，它的任务就是从网络请求队列中取出request进行网络请求了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">       Request request;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Take a request from the queue.</span></span><br><span class="line">               request = mQueue.take(); <span class="comment">//取出一个请求</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">               <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line">               <span class="comment">// If the request was cancelled already, do not perform the</span></span><br><span class="line">               <span class="comment">// network request.</span></span><br><span class="line">               <span class="keyword">if</span> (request.isCanceled()) &#123; <span class="comment">//如果被取消了continue</span></span><br><span class="line">                   request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">               <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">                   TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Perform the network request.</span></span><br><span class="line">               <span class="comment">//通过网络请求库向服务器请求数据，响应保存在networkResponse中</span></span><br><span class="line">               NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">               request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">               <span class="comment">// If the server returned 304 AND we delivered a response already,</span></span><br><span class="line">               <span class="comment">// we're done -- don't deliver a second identical response.</span></span><br><span class="line">               <span class="comment">//响应请求的内容为被修改，服务器会返回304的响应码</span></span><br><span class="line">               <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; </span><br><span class="line">                   request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">               <span class="comment">//对相应进行解析，这里调用的parseNetworkResponse在request子类中实现</span></span><br><span class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">               request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line">               <span class="comment">// Write to cache if applicable.</span></span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">               <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123; <span class="comment">//需要缓存</span></span><br><span class="line">                   mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                   request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Post the response back.</span></span><br><span class="line">               request.markDelivered();</span><br><span class="line">               mDelivery.postResponse(request, response); <span class="comment">//转发器投递响应到主线程</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">               parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">               mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到网络请求线程的处理更加简单，主要就是从网络请求队列中取出reqeust进行网络请求，并根据设置将响应保存在缓存中，最后转发响应到主线程中。</p><p>我们看到在缓存调度线程和网络调度线程中都使用到了ResponseDelivery对象将结果投递到主线程，这里我们看看这个Delivery 。事实上，ResponseDelivery只是一个接口，我们在创建RequestQueue时使用的ExecutorDelivery它实现了该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">                   <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用通过一个Handler来构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">           handler.post(command);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">    postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">   request.markDelivered();</span><br><span class="line">   request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">   mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dlivery的有两个重载的PostResponse，在缓存调度线程和网络调度线程都使用了两个参数的，三个参数的用在了缓存需要刷新时的情况，这时我们不仅要将结果投递给主线程而且要刷新缓存（其实只是将请求添加到了网络请求队列中），刷新缓存的操作就是通过第三个参数Runable实现的。<br>我们看看这个ResponseDeliveryRunnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">           mRequest = request;</span><br><span class="line">           mResponse = response;</span><br><span class="line">           mRunnable = runnable;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">           <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">               mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">           <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">               mRequest.deliverResponse(mResponse.result); <span class="comment">//同样调用两个参数的将响应投递给主线程</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mRequest.deliverError(mResponse.error);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">           <span class="comment">// and the request can be finished.</span></span><br><span class="line">           <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">               mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">           <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mRunnable.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看Request类，这个请求类在我们的主线程中使用，是个抽象类，其子类需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br></pre></td></tr></table></figure><p>分别用来解析响应和转发响应</p><p>在Request中，有个RetryPolicy成员通过DefaultRetryPolicy构造，这是个重试策略，主要在用在请求需要重新请求时，我们看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRetryPolicy</span> <span class="keyword">implements</span> <span class="title">RetryPolicy</span> </span>&#123;</span><br><span class="line">       <span class="comment">/** The current timeout in milliseconds. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> mCurrentTimeoutMs;</span><br><span class="line">       <span class="comment">/** The current retry count. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount; <span class="comment">//当前重试次数</span></span><br><span class="line">       <span class="comment">/** The maximum number of attempts. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxNumRetries; <span class="comment">//最大重试次数</span></span><br><span class="line">       <span class="comment">/** The backoff multiplier for for the policy. */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mBackoffMultiplier; <span class="comment">//备值因子</span></span><br><span class="line">       <span class="comment">/** The default socket timeout in milliseconds */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</span><br><span class="line">       <span class="comment">/** The default number of retries */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/** The default backoff multiplier */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructs a new retry policy using the default timeouts.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructs a new retry policy.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> initialTimeoutMs The initial timeout for the policy.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> maxNumRetries The maximum number of retries.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> backoffMultiplier Backoff multiplier for the policy.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</span><br><span class="line">           mCurrentTimeoutMs = initialTimeoutMs;</span><br><span class="line">           mMaxNumRetries = maxNumRetries;</span><br><span class="line">           mBackoffMultiplier = backoffMultiplier;</span><br><span class="line">       &#125;</span><br><span class="line">       ....</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Prepares for the next retry by applying a backoff to the timeout.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> error The error code of the last attempt.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">           mCurrentRetryCount++;  <span class="comment">//重试次数加1</span></span><br><span class="line">           mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);<span class="comment">//计算当前超时时间</span></span><br><span class="line">           <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> error;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns true if this policy has attempts remaining, false otherwise.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们看看这个RetryPolicy的使用，它主要用在了网络请求类BasicNetWork中，主要看看接口方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">       Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Gather headers.</span></span><br><span class="line">           Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">           addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">           httpResponse = mHttpStack.performRequest(request, headers); <span class="comment">//请求数据，获取响应</span></span><br><span class="line">           StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">           <span class="keyword">int</span> statusCode = statusLine.getStatusCode(); <span class="comment">//获取状态码</span></span><br><span class="line">           responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">           <span class="comment">// Handle cache validation.</span></span><br><span class="line">           <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                       request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">           <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">             responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">              <span class="comment">// no-content request.</span></span><br><span class="line">             responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">           <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">           logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">           <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;<span class="comment">//socket 超时</span></span><br><span class="line">           attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123; <span class="comment">//连接超时</span></span><br><span class="line">           attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123; </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">           NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">               statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">           &#125;</span><br><span class="line">           VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">           <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">               networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                       responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">               <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                       statusCode == HttpStatus.SC_FORBIDDEN) &#123;<span class="comment">//未认证异常</span></span><br><span class="line">                   attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                           request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到performRequest是通过一个while循环来实现的，这是为了在发生请求出错是再次进行重试。在request超时、或者认证失败后都会调用attemptRetryOnException，这里就会进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span></span></span><br><span class="line"><span class="function"><span class="params">           VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">   RetryPolicy retryPolicy = request.getRetryPolicy();<span class="comment">//获取重试策略</span></span><br><span class="line">   <span class="keyword">int</span> oldTimeout = request.getTimeoutMs(); <span class="comment">//获取超时值</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        retryPolicy.retry(exception);<span class="comment">//重试</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">       request.addMarker(</span><br><span class="line">               String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这里退出重试循环是通过retry抛出VolleyError异常来结束的</strong></p><h3 id="volley的缓存策略"><a class="markdownIt-Anchor" href="#volley的缓存策略"></a> volley的缓存策略</h3><p>volley的缓存是通过服务端进行控制的，这样的方式比本地存储更加灵活，同服务端进行交互缓存能降低通信量，同时减轻本地缓存的压力。比如之前我们看到了服务端如何通过304的响应码通知内容未修改，这时就不需要再进行请求了。<br>volley的缓存类是在创建RequestQueue时指定的，这个缓存类以流的方式实现了Cach Entry的存取。所以我们看看这个Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">       <span class="comment">/** The data returned from cache. */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">byte</span>[] data; <span class="comment">//缓存的字节流</span></span><br><span class="line">       <span class="comment">/** ETag for cache coherency. */</span></span><br><span class="line">       <span class="keyword">public</span> String etag;</span><br><span class="line">       <span class="comment">/** Date of this response as reported by the server. */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line">       <span class="comment">/** TTL for this record. */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line">       <span class="comment">/** Soft TTL for this record. */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line">       <span class="comment">/** Immutable response headers as received from server; must be non-null. */</span></span><br><span class="line">       <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">       <span class="comment">/** True if the entry is expired. */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/** True if a refresh is needed from the original data source. */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，这个Entry对应我们一个请求的缓存条目，这个是在Request子类根据响应解析出来的。解析类为HttpHeaderParser，当然我们也可以根据需求自己定义类来解析响应得到想要的缓存。下面我们看看这个解析的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpHeaderParser.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">       Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line">       <span class="keyword">long</span> serverDate = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> serverExpires = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> softExpire = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> maxAge = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;</span><br><span class="line">       String serverEtag = <span class="keyword">null</span>;</span><br><span class="line">       String headerValue;</span><br><span class="line">       headerValue = headers.get(<span class="string">"Date"</span>); <span class="comment">//得到date</span></span><br><span class="line">       <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">           serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">       &#125;</span><br><span class="line">       headerValue = headers.get(<span class="string">"Cache-Control"</span>); <span class="comment">//获取Cache-Control值，服务端需要设置这个值来标记缓存</span></span><br><span class="line">       <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">           hasCacheControl = <span class="keyword">true</span>;</span><br><span class="line">           String[] tokens = headerValue.split(<span class="string">","</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">               String token = tokens[i].trim();</span><br><span class="line">               <span class="keyword">if</span> (token.equals(<span class="string">"no-cache"</span>) || token.equals(<span class="string">"no-store"</span>)) &#123; <span class="comment">//对应的值no-cache、no-store</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"max-age="</span>)) &#123; <span class="comment">//对应的值为max-age,这个值标记了缓存的生存时间</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"must-revalidate"</span>) || token.equals(<span class="string">"proxy-revalidate"</span>)) &#123;</span><br><span class="line">                   maxAge = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       headerValue = headers.get(<span class="string">"Expires"</span>); <span class="comment">//过期时间</span></span><br><span class="line">       <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">           serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">       &#125;</span><br><span class="line">       serverEtag = headers.get(<span class="string">"ETag"</span>);</span><br><span class="line">       <span class="comment">// Cache-Control takes precedence over an Expires header, even if both exist and Expires</span></span><br><span class="line">       <span class="comment">// is more restrictive.</span></span><br><span class="line">       <span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">           softExpire = now + maxAge * <span class="number">1000</span>;<span class="comment">//计算过期时间 这里以毫秒为单位</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">           <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">           softExpire = now + (serverExpires - serverDate);<span class="comment">//通过过期日期来计算过期时间</span></span><br><span class="line">       &#125;</span><br><span class="line">       Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</span><br><span class="line">       entry.data = response.data;</span><br><span class="line">       entry.etag = serverEtag;</span><br><span class="line">       entry.softTtl = softExpire;</span><br><span class="line">       entry.ttl = entry.softTtl;<span class="comment">//其实就是我们的过期时间</span></span><br><span class="line">       entry.serverDate = serverDate;</span><br><span class="line">       entry.responseHeaders = headers;</span><br><span class="line">       <span class="keyword">return</span> entry;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们在缓存调度线程中判断缓存条目失效的方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当前ttl的值小于当前系统时间就算过期了。所以我们需要服务端设置头部Cache-Control的max-age或者expires来控制缓存的生命时间已达到本地缓存的目的。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>volley使用场景 数据量不大但通信频繁的场景</p><h3 id="相关链接"><a class="markdownIt-Anchor" href="#相关链接"></a> 相关链接</h3><p><a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="noopener">Volley主页</a></p><p><a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="noopener">Volley仓库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;综述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#综述&quot;&gt;&lt;/a&gt; 综述&lt;/h3&gt;
&lt;p&gt;volley有三个层次的线程，分别为main thread、cache thread 以及network thrads。RequestQueue
      
    
    </summary>
    
      <category term="Android library" scheme="http://esligh.github.io/categories/Android-library/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
