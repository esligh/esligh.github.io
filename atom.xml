<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>esli&#39;s Blog</title>
  
  <subtitle>day day up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://esligh.github.io/"/>
  <updated>2019-03-16T08:09:11.652Z</updated>
  <id>http://esligh.github.io/</id>
  
  <author>
    <name>esli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SurfaceControl事务提交过程</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surfacecontrol-transaction/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surfacecontrol-transaction/</id>
    <published>2019-02-19T13:28:36.000Z</published>
    <updated>2019-03-16T08:09:11.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h3><p>SurfaceControl，顾明思议它是Surface的控制管理者，我们知道Surface是应用层用户进行UI绘制的绘图表面，它由WindowManagerService创建，WindowManagerService管理着窗口对象WindowState，Window是一个抽象的概念，它属于设计层面使用的类，而Surface实际上才是实现上的窗口实体。所以当WMS对Window做了改变，比如调整layerStack，Z-order，大小,位置等后需要通过SurfaceControl来告知SurfaceFlinger，以便SurfaceFlinger更新其在SF端的Layer图层进行合成渲染，这个Layer图层实际上和应用层使用的Surface是对应的。本篇我们将通过SuraceControl来了解这些属性更新的具体过程。</p><h3 id="surfacecontrol的创建"><a class="markdownIt-Anchor" href="#surfacecontrol的创建"></a> SurfaceControl的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">            WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outVisibleInsets, Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">            surfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建SurfaceControl 准备画布</span></span><br><span class="line">        SurfaceControl surfaceControl = winAnimator.createSurfaceLocked();</span><br><span class="line">        <span class="keyword">if</span> (surfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outSurface.copyFrom(surfaceControl);<span class="comment">//Surface从SurfaceControl中得到</span></span><br><span class="line">            <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG,</span><br><span class="line">                    <span class="string">"  OUT SURFACE "</span> + outSurface + <span class="string">": copied"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// For some reason there isn't a surface.  Clear the</span></span><br><span class="line">            <span class="comment">// caller's object so they see the same state.</span></span><br><span class="line">            outSurface.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前介绍创建Surface的流程中我们知道SurfaceControl的创建过程是在WMS的relayoutWindow方法中进行的，Surface是从SurfaceControl中取到的。它实际是通过WindowStateAnimator的createSurfaceLocked创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SurfaceControl <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//创建SurfaceControl</span></span><br><span class="line">    mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">        mSession.mSurfaceSession,</span><br><span class="line">        attrs.getTitle().toString(),</span><br><span class="line">        w, h, format, flags);</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里通过SurfaceControl的transaction来提交Surface的设置</span></span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSurfaceX = mWin.mFrame.left + mWin.mXOffset;</span><br><span class="line">            mSurfaceY = mWin.mFrame.top + mWin.mYOffset;</span><br><span class="line">            mSurfaceControl.setPosition(mSurfaceX, mSurfaceY);<span class="comment">//设置position</span></span><br><span class="line">            mSurfaceLayer = mAnimLayer;</span><br><span class="line">            mSurfaceControl.setLayerStack(mLayerStack);<span class="comment">//设置layerStack</span></span><br><span class="line">            mSurfaceControl.setLayer(mAnimLayer);<span class="comment">//设置Z order</span></span><br><span class="line">            mSurfaceControl.setAlpha(<span class="number">0</span>);<span class="comment">//设置透明度 0?</span></span><br><span class="line">            mSurfaceShown = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Error creating surface in "</span> + w, e);</span><br><span class="line">            mService.reclaimSomeSurfaceMemoryLocked(<span class="keyword">this</span>, <span class="string">"create-init"</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastHidden = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,</span><br><span class="line">                <span class="string">"&lt;&lt;&lt; CLOSE TRANSACTION createSurfaceLocked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowStateAnimator的createSurfaceLocked负责创建SurfaceControl对象，同时会开启一个事务来提交surface的初始属性。属性的设置是通过SurfaceControl的一系列set方法进行设置的。事务过程通过openTransaction和closeTransaction来控制。</p><h3 id="属性设置和事务提交"><a class="markdownIt-Anchor" href="#属性设置和事务提交"></a> 属性设置和事务提交</h3><p>下面我们就具体分析这两个方法是如何进行属性设置和事务提交的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceControl</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** start a transaction */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nativeOpenTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** end a transaction */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nativeCloseTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayer</span><span class="params">(<span class="keyword">int</span> zorder)</span> </span>&#123;</span><br><span class="line">        checkNotReleased();</span><br><span class="line">        nativeSetLayer(mNativeObject, zorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看的是Z-order的属性设置，属性的设置和提交都是通过JNI层进行一步处理的，我们接着看android_view_SurfaceControl.cpp中的JNI实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetLayer</span><span class="params">(JNIEnv* env, jclass clazz, jint nativeObject, jint zorder)</span> </span>&#123;</span><br><span class="line">    SurfaceControl* <span class="keyword">const</span> ctrl = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    status_t err = ctrl-&gt;setLayer(zorder);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; err != NO_INIT) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeOpenTransaction</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeCloseTransaction</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性设置通过native层的SurfaceControl来设置，提交实际上是经过SurfaceComposerClient处理，之前我们在介绍Surface创建流程是有过介绍，它实际上是SF端的Client在客户端的Binder代理，在WMS中的为应用端创建Session会话时也会构造一个SurfaceSession，这个SurfaceSession实际上就是SurfaceComposerClient在上层的体现。</p><h4 id="属性设置"><a class="markdownIt-Anchor" href="#属性设置"></a> 属性设置</h4><p>下面我们先看属性是如何设置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp)</span><br><span class="line">    : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t SurfaceControl::setLayer(int32_t layer) &#123;</span><br><span class="line">    status_t err = validate();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client(mClient);</span><br><span class="line">    <span class="keyword">return</span> client-&gt;setLayer(mHandle, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceControl中属性设置最终还是通过我们创建的SurfaceComposerClient进行处理的，它的构造方法中的client就是我们在SurfaceSession中创建的<br>SurfaceComposerClient。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">    : mStatus(NO_INIT), mComposer(Composer::getInstance())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Composer&amp; SurfaceComposerClient::getComposer() &#123;</span><br><span class="line">    <span class="keyword">return</span> mComposer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> SurfaceComposerClient::setLayer(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">int32_t</span> z) &#123;</span><br><span class="line">    <span class="keyword">return</span> getComposer().setLayer(<span class="keyword">this</span>, id, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建SurfaceComposerClient对象时同时会创建一个mComposer的Composer对象，它是一个单例，我们的属性值最终是通过它来进行设置的，我们看看Composer的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Composer : public Singleton&lt;Composer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">Composer</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">    mutable Mutex               mLock;</span><br><span class="line">    SortedVector&lt;ComposerState&gt; mComposerStates;</span><br><span class="line">    SortedVector&lt;DisplayState &gt; mDisplayStates;</span><br><span class="line">    uint32_t                    mForceSynchronous;</span><br><span class="line">    uint32_t                    mTransactionNestCount;</span><br><span class="line">    bool                        mAnimation;</span><br><span class="line"></span><br><span class="line">    Composer() : Singleton&lt;Composer&gt;(),</span><br><span class="line">        mForceSynchronous(<span class="number">0</span>), mTransactionNestCount(<span class="number">0</span>),</span><br><span class="line">        mAnimation(<span class="keyword">false</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openGlobalTransactionImpl</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeGlobalTransactionImpl</span><span class="params">(bool synchronous)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAnimationTransactionImpl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    layer_state_t* getLayerStateLocked(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id);</span><br><span class="line"></span><br><span class="line">    DisplayState&amp; getDisplayStateLocked(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">status_t <span class="title">setPosition</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line">    <span class="function">status_t <span class="title">setSize</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id,</span></span></span><br><span class="line"><span class="function"><span class="params">            uint32_t w, uint32_t h)</span></span>;</span><br><span class="line">    <span class="function">status_t <span class="title">setLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id,</span></span></span><br><span class="line"><span class="function"><span class="params">            int32_t z)</span></span>;</span><br><span class="line">    <span class="function">status_t <span class="title">setLayerStack</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, uint32_t layerStack)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAnimationTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Composer::getInstance().setAnimationTransactionImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openGlobalTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Composer::getInstance().openGlobalTransactionImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeGlobalTransaction</span><span class="params">(bool synchronous)</span> </span>&#123;</span><br><span class="line">        Composer::getInstance().closeGlobalTransactionImpl(synchronous);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过Composer的定义我们可以大概看出其实属性的设置和提交最终都是通过它来进行的。我们先看设置的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">status_t Composer::setLayer(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, int32_t z) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    layer_state_t* s = getLayerStateLocked(client, id);</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    s-&gt;what |= layer_state_t::eLayerChanged;</span><br><span class="line">    s-&gt;z = z;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer_state_t* Composer::getLayerStateLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id) &#123;</span><br><span class="line"></span><br><span class="line">    ComposerState s;</span><br><span class="line">    s.client = client-&gt;mClient;</span><br><span class="line">    s.state.surface = id;</span><br><span class="line"></span><br><span class="line">    ssize_t index = mComposerStates.indexOf(s);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// we don't have it, add an initialized layer_state to our list</span></span><br><span class="line">        index = mComposerStates.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComposerState* <span class="keyword">const</span> out = mComposerStates.editArray();</span><br><span class="line">    <span class="keyword">return</span> &amp;(out[index].state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setLayer首先通过getLayerStateLocked获取到一个layer_state_t对象，它保存的了layer的属性信息，layer_state_t实际上是由Composer类的mComposerStates维护的，它是一个SortedVector<composerstate>，即ComposerState的有序集合。我们最终从ComposerState取出layer_state_t，然后将我们设置的属性保存在里面。</composerstate></p><h4 id="提交属性事务"><a class="markdownIt-Anchor" href="#提交属性事务"></a> 提交属性事务</h4><p>接下来就是提交属性的过程，属性提交通过SurfaceComposerClient的openGlobalTransaction和closeGlobalTransaction<br>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceComposerClient::openGlobalTransaction() &#123;</span><br><span class="line">    Composer::openGlobalTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::closeGlobalTransaction(bool synchronous) &#123;</span><br><span class="line">    Composer::closeGlobalTransaction(synchronous);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openGlobalTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Composer::getInstance().openGlobalTransactionImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeGlobalTransaction</span><span class="params">(bool synchronous)</span> </span>&#123;</span><br><span class="line">    Composer::getInstance().closeGlobalTransactionImpl(synchronous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它内部实际上是使用Composer的静态方法实现，而在Compser的类定义中我们看到，这两个静态方法的实现实际上是会使用我们为<br>SurfaceComposerClient创建的单例mComposer来进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Composer::openGlobalTransactionImpl() &#123;</span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mTransactionNestCount += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Composer::closeGlobalTransactionImpl(bool synchronous) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Vector&lt;ComposerState&gt; transaction;</span><br><span class="line">    Vector&lt;DisplayState&gt; displayTransaction;</span><br><span class="line">    uint32_t flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mForceSynchronous |= synchronous;</span><br><span class="line">        <span class="keyword">if</span> (!mTransactionNestCount) &#123;</span><br><span class="line">            ALOGW(<span class="string">"At least one call to closeGlobalTransaction() was not matched by a prior "</span></span><br><span class="line">                    <span class="string">"call to openGlobalTransaction()."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (--mTransactionNestCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction = mComposerStates;</span><br><span class="line">        mComposerStates.clear();</span><br><span class="line"></span><br><span class="line">        displayTransaction = mDisplayStates;</span><br><span class="line">        mDisplayStates.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mForceSynchronous) &#123;</span><br><span class="line">            flags |= ISurfaceComposer::eSynchronous;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAnimation) &#123;</span><br><span class="line">            flags |= ISurfaceComposer::eAnimation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mForceSynchronous = <span class="keyword">false</span>;</span><br><span class="line">        mAnimation = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   sm-&gt;setTransactionState(transaction, displayTransaction, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>openGlobalTransactionImpl的实现只是更新事务计数值mTransactionNestCount，真正的提交操作是在closeGlobalTransactionImpl，这里的synchronous默认为false。我们之前设置的属性保存在mComposerStates中，这里将其添加到transaction中，并通过ISurfaceComposer的setTransactionState提交给SF。这里ISurfaceComposer是SurfaceFlinger的Binder 本地代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setTransactionState(</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;ComposerState&gt;&amp; state,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;DisplayState&gt;&amp; displays,</span><br><span class="line">        uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    uint32_t transactionFlags = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    size_t count = displays.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> DisplayState&amp; s(displays[i]);</span><br><span class="line">        transactionFlags |= setDisplayStateLocked(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = state.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> ComposerState&amp; s(state[i]);</span><br><span class="line">        <span class="comment">// Here we need to check that the interface we're given is indeed</span></span><br><span class="line">        <span class="comment">// one of our own. A malicious client could give us a NULL</span></span><br><span class="line">        <span class="comment">// IInterface, or one of its own or even one of our own but a</span></span><br><span class="line">        <span class="comment">// different type. All these situations would cause us to crash.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> it would be better to use RTTI as we could directly check</span></span><br><span class="line">        <span class="comment">// that we have a Client*. however, RTTI is disabled in Android.</span></span><br><span class="line">        <span class="keyword">if</span> (s.client != NULL) &#123;</span><br><span class="line">            sp&lt;IBinder&gt; binder = s.client-&gt;asBinder();</span><br><span class="line">            <span class="keyword">if</span> (binder != NULL) &#123;</span><br><span class="line">                <span class="function">String16 <span class="title">desc</span><span class="params">(binder-&gt;getInterfaceDescriptor()</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (desc == ISurfaceComposerClient::descriptor) &#123;</span><br><span class="line">                    <span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">( static_cast&lt;Client *&gt;(s.client.get()</span>) )</span>;</span><br><span class="line">                    transactionFlags |= setClientStateLocked(client, s.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags) &#123;</span><br><span class="line">        <span class="comment">// this triggers the transaction</span></span><br><span class="line">        setTransactionFlags(transactionFlags);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setTransactionState中会通过setClientStateLocked通知SF更新layer的属性。这里会从ComposerState中取出<br>state,即layer_state_t。设置完成后会通过setTransactionFlags通知SF进行layer属性的变更操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">uint32_t SurfaceFlinger::setClientStateLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> layer_state_t&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t flags = <span class="number">0</span>;</span><br><span class="line">    <span class="function">sp&lt;Layer&gt; <span class="title">layer</span><span class="params">(client-&gt;getLayerUser(s.surface)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> uint32_t what = s.what;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::ePositionChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setPosition(s.x, s.y))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eLayerChanged) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> index needs to be calculated before we update the state</span></span><br><span class="line">            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setLayer(s.z)) &#123;</span><br><span class="line">                mCurrentState.layersSortedByZ.removeAt(idx);</span><br><span class="line">                mCurrentState.layersSortedByZ.add(layer);</span><br><span class="line">                <span class="comment">// we need traversal (state changed)</span></span><br><span class="line">                <span class="comment">// AND transaction (list changed)</span></span><br><span class="line">                flags |= eTransactionNeeded|eTraversalNeeded;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eSizeChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setSize(s.w, s.h)) &#123;</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eAlphaChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setAlpha(uint8_t(<span class="number">255.0f</span>*s.alpha+<span class="number">0.5f</span>)))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eMatrixChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setMatrix(s.matrix))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eTransparentRegionChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setTransparentRegionHint(s.transparentRegion))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eVisibilityChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setFlags(s.flags, s.mask))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eCropChanged) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setCrop(s.crop))</span><br><span class="line">                flags |= eTraversalNeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (what &amp; layer_state_t::eLayerStackChanged) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> index needs to be calculated before we update the state</span></span><br><span class="line">            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;setLayerStack(s.layerStack)) &#123;</span><br><span class="line">                mCurrentState.layersSortedByZ.removeAt(idx);</span><br><span class="line">                mCurrentState.layersSortedByZ.add(layer);</span><br><span class="line">                <span class="comment">// we need traversal (state changed)</span></span><br><span class="line">                <span class="comment">// AND transaction (list changed)</span></span><br><span class="line">                flags |= eTransactionNeeded|eTraversalNeeded;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setClientStateLocked方法首先通过Client的getLayerUser取出Layer图层，这个图层就是我们为应用端创建Surface时在SF端创建的。它通过SF的addClientLayer添加到Client以及SF的mCurrentState.layersSortedByZ中。所以这里将我们设置的属性值最终更新到SF管理的layer中。</p><p>设置完SF中layer的属性后需要通知SF进行layer的属性变更，实际上就是让SF进行一次合成渲染操作以便更新应用界面，这个是通过setTransactionFlags进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags) &#123;</span><br><span class="line">    uint32_t old = android_atomic_or(flags, &amp;mTransactionFlags);</span><br><span class="line">    <span class="keyword">if</span> ((old &amp; flags)==<span class="number">0</span>) &#123; <span class="comment">// wake the server up</span></span><br><span class="line">        signalTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::signalTransaction() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(int32_t what) &#123;<span class="comment">//MessageQueue中消息实际是通过SF来处理的</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">if</span>(mDelayFlag) &#123;</span><br><span class="line">        usleep(<span class="number">20000</span>);</span><br><span class="line">        mDelayFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line"><span class="comment">//处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。</span></span><br><span class="line"><span class="keyword">case</span> MessageQueue::TRANSACTION:</span><br><span class="line">handleMessageTransaction();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于处理Layer或者display属性的变化以及Layer对应buffer的更新</span></span><br><span class="line"><span class="keyword">case</span> MessageQueue::INVALIDATE:</span><br><span class="line"></span><br><span class="line">handleMessageTransaction();<span class="comment">//处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。</span></span><br><span class="line">handleMessageInvalidate();<span class="comment">//主要是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域</span></span><br><span class="line"></span><br><span class="line">signalRefresh();<span class="comment">//进行刷新</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示SurfaceFlinger需要进行一次合成操作(Refresh):</span></span><br><span class="line"><span class="comment"> *   1) Layer属性的变化导致window state发生变化;</span></span><br><span class="line"><span class="comment"> 2) Layer有新的buffer到来;</span></span><br><span class="line"><span class="comment"> 3) HWC请求进行一次repaint。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">case</span> MessageQueue::REFRESH:</span><br><span class="line">handleMessageRefresh();<span class="comment">//合并和渲染输出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signalTransaction会通过SF的MessageQueue安排一次VSYNC信号，从而触发INVALIDATE事件，然后在SF中再通过onMessageReceived处理layer属性变更以及合成和渲染的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;综述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#综述&quot;&gt;&lt;/a&gt; 综述&lt;/h3&gt;
&lt;p&gt;SurfaceControl，顾明思议它是Surface的控制管理者，我们知道Surface是应用层用户进行UI绘制的绘图表面，它由Window
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>WindowManagerService添加窗口测试</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/android-wms-add-test/"/>
    <id>http://esligh.github.io/[object Object]/android-wms-add-test/</id>
    <published>2018-10-18T14:36:23.000Z</published>
    <updated>2019-03-16T08:02:14.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="windowmanagerservice创建窗口测试"><a class="markdownIt-Anchor" href="#windowmanagerservice创建窗口测试"></a> WindowManagerService创建窗口测试</h3><p>通过WindowManagerService我们可以直接申请、渲染并注销自己的窗口，而不需要经过Activity，Dialog等系统组件，通过本测试，我们可以清楚WMS最基本的工作方式。以下代码基于Android4.4</p><h4 id="创建一个samplewindow类"><a class="markdownIt-Anchor" href="#创建一个samplewindow类"></a> 创建一个SampleWindow类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.wms.samplewindow;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Point;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Rect;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.ParcelFileDescriptor;</span><br><span class="line"><span class="keyword">import</span> android.view.Choreographer;</span><br><span class="line"><span class="keyword">import</span> android.view.Display;</span><br><span class="line"><span class="keyword">import</span> android.view.DragEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.InputEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.Surface;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> android.os.ServiceManager;</span><br><span class="line"><span class="keyword">import</span> android.view.InputEventReceiver;</span><br><span class="line"><span class="keyword">import</span> android.view.InputChannel;</span><br><span class="line"><span class="keyword">import</span> android.view.DisplayInfo;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManagerGlobal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.IWindow;</span><br><span class="line"><span class="keyword">import</span> android.view.IWindowSession;</span><br><span class="line"><span class="keyword">import</span> android.view.IWindowManager;</span><br><span class="line"><span class="keyword">import</span> android.hardware.display.IDisplayManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleWindow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//SampleWindow.Run()是这个程序的主入口</span></span><br><span class="line">            <span class="keyword">new</span> SampleWindow().Run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IWindowSession 是客户端向WMS请求窗口操作的中间代理，并且是进程唯一的</span></span><br><span class="line">    IWindowSession mSession = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//InputChannel 是窗口接收用户输入事件的管道。在第5章中将对其进行详细的探讨</span></span><br><span class="line">    InputChannel mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    <span class="comment">// 下面的三个Rect保存了窗口的布局结果。其中mFrame表示了窗口在屏幕上的位置与尺寸</span></span><br><span class="line">    <span class="comment">// 在4.4中将详细介绍它们的作用以及计算原理</span></span><br><span class="line">    Rect mInsets1 = <span class="keyword">new</span> Rect();</span><br><span class="line">Rect mInsets2 = <span class="keyword">new</span> Rect();</span><br><span class="line">    Rect mFrame = <span class="keyword">new</span> Rect();</span><br><span class="line">    Rect mVisibleInsets = <span class="keyword">new</span> Rect();</span><br><span class="line">    Configuration mConfig = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">//窗口的Surface，在此Surface上进行的绘制都将在此窗口上显示出来</span></span><br><span class="line">    Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">    <span class="comment">// 用于在窗口上进行绘图的画刷</span></span><br><span class="line">    Paint mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    <span class="comment">// 添加窗口所需的令牌</span></span><br><span class="line">    IBinder mToken = <span class="keyword">new</span> Binder();</span><br><span class="line">    <span class="comment">// 一个窗口对象，本例演示了如何将此窗口添加到WMS中，并在其上进行绘制操作</span></span><br><span class="line">    MyWindow mWindow = <span class="keyword">new</span> MyWindow();</span><br><span class="line">    <span class="comment">//WindowManager.LayoutParams定义了窗口的布局属性，包括位置、尺寸以及窗口类型等</span></span><br><span class="line">    WindowManager.LayoutParams mLp = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">    Choreographer mChoreographer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//InputHandler 用于从InputChannel接收按键事件做出响应</span></span><br><span class="line">    InputHandler mInputHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mContinueAnime = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="comment">// 获取WMS服务</span></span><br><span class="line">        IWindowManager wms = IWindowManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.WINDOW_SERVICE));</span><br><span class="line">        <span class="comment">// 通过WindowManagerGlobal获取进程唯一的IWindowSession实例。它将用于向WMS</span></span><br><span class="line">        <span class="comment">// 发送请求。注意这个函数在较早的Android版本（如4.1）位于ViewRootImpl类中</span></span><br><span class="line">        mSession= WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取屏幕分辨率</span></span><br><span class="line">        IDisplayManager dm = IDisplayManager.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(Context.DISPLAY_SERVICE));</span><br><span class="line"></span><br><span class="line">        DisplayInfo di = dm.getDisplayInfo(Display.DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">        Point scrnSize = <span class="keyword">new</span> Point(di.appWidth, di.appHeight);</span><br><span class="line">         <span class="comment">// 初始化WindowManager.LayoutParams</span></span><br><span class="line">        initLayoutParams(scrnSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新窗口添加到WMS</span></span><br><span class="line">        installWindow(wms);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化Choreographer的实例，此实例为线程唯一。这个类的用法与Handler</span></span><br><span class="line">        <span class="comment">// 类似，不过它总是在VSYC同步时回调，所以比Handler更适合做动画的循环器[1]</span></span><br><span class="line">        mChoreographer= Choreographer.getInstance();</span><br><span class="line">        <span class="comment">// 开始处理第一帧的动画</span></span><br><span class="line">        scheduleNextFrame();</span><br><span class="line">        <span class="comment">// 当前线程陷入消息循环，直到Looper.quit()</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="comment">// 标记不要继续绘制动画帧</span></span><br><span class="line">         mContinueAnime= <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">// 卸载当前Window</span></span><br><span class="line">        uninstallWindow(wms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initLayoutParams</span><span class="params">(Point screenSize)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 标记即将安装的窗口类型为SYSTEM_ALERT，这将使得窗口的ZOrder顺序比较靠前</span></span><br><span class="line">        mLp.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;</span><br><span class="line">        mLp.setTitle(<span class="string">"SampleWindow"</span>);</span><br><span class="line">         <span class="comment">// 设定窗口的左上角坐标以及高度和宽度</span></span><br><span class="line">        mLp.gravity = Gravity.LEFT | Gravity.TOP;</span><br><span class="line">        mLp.x = screenSize.x / <span class="number">4</span>;</span><br><span class="line">        mLp.y = screenSize.y / <span class="number">4</span>;</span><br><span class="line">        mLp.width = screenSize.x / <span class="number">2</span>;</span><br><span class="line">        mLp.height = screenSize.y / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 和输入事件相关的Flag，希望当输入事件发生在此窗口之外时，其他窗口也可以接受输入事件</span></span><br><span class="line">        mLp.flags = mLp.flags | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWindow</span><span class="params">(IWindowManager wms)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 首先向WMS声明一个Token，任何一个Window都需要隶属与一个特定类型的Token</span></span><br><span class="line">        wms.addWindowToken(mToken,WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</span><br><span class="line">        <span class="comment">// 设置窗口所隶属的Token</span></span><br><span class="line">        mLp.token = mToken;</span><br><span class="line">        <span class="comment">// 通过IWindowSession将窗口安装进WMS，注意，此时仅仅是安装到WMS，本例的Window</span></span><br><span class="line">        <span class="comment">// 目前仍然没有有效的Surface。不过，经过这个调用后，mInputChannel已经可以用来接受</span></span><br><span class="line">        <span class="comment">// 输入事件了</span></span><br><span class="line">         mSession.add(mWindow,<span class="number">0</span>, mLp, View.VISIBLE, mInsets2, mInputChannel);</span><br><span class="line">        <span class="comment">/*通过IWindowSession要求WMS对本窗口进行重新布局，经过这个操作后，WMS将会为窗口</span></span><br><span class="line"><span class="comment">         创建一块用于绘制的Surface并保存在参数mSurface中。同时，这个Surface被WMS放置在</span></span><br><span class="line"><span class="comment">        LayoutParams所指定的位置上 */</span></span><br><span class="line">        mSession.relayout(mWindow,<span class="number">0</span>, mLp, mLp.width, mLp.height, View.VISIBLE,</span><br><span class="line">                <span class="number">0</span>, mFrame, mInsets1,mInsets2,mVisibleInsets, mConfig, mSurface);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mSurface.isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed creating Surface."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于WMS返回的InputChannel创建一个Handler，用于监听输入事件</span></span><br><span class="line">        <span class="comment">//mInputHandler一旦被创建，就已经在监听输入事件了</span></span><br><span class="line">        mInputHandler= <span class="keyword">new</span> InputHandler(mInputChannel, Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uninstallWindow</span><span class="params">(IWindowManager wms)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         <span class="comment">// 从WMS处卸载窗口</span></span><br><span class="line">         mSession.remove(mWindow);</span><br><span class="line">        <span class="comment">// 从WMS处移除之前添加的Token</span></span><br><span class="line">        wms.removeWindowToken(mToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleNextFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求在显示系统刷新下一帧时回调mFrameRender，注意，只回调一次</span></span><br><span class="line">         mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION</span><br><span class="line">                , mFrameRender, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Runnable对象用以在窗口上描绘一帧</span></span><br><span class="line">    <span class="keyword">public</span> Runnable mFrameRender = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 获取当期时间戳</span></span><br><span class="line">                <span class="keyword">long</span> time = mChoreographer.getFrameTime() % <span class="number">1000</span>;</span><br><span class="line">                <span class="comment">// 绘图</span></span><br><span class="line">                <span class="keyword">if</span> (mSurface.isValid()) &#123;</span><br><span class="line">                    Canvas canvas = mSurface.lockCanvas(<span class="keyword">null</span>);</span><br><span class="line">                    canvas.drawColor(Color.DKGRAY);</span><br><span class="line">                    canvas.drawRect(<span class="number">2</span> * mLp.width * time / <span class="number">1000</span></span><br><span class="line">                            - mLp.width, <span class="number">0</span>, <span class="number">2</span> *mLp.width * time / <span class="number">1000</span>, mLp.height,mPaint);</span><br><span class="line">                    mSurface.unlockCanvasAndPost(canvas);</span><br><span class="line">                    mSession.finishDrawing(mWindow);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mContinueAnime)&#123;</span><br><span class="line">                    scheduleNextFrame();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个类继承InputEventReceiver，用以在其onInputEvent()函数中接收窗口的输入事件</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Looper mLooper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InputHandler</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(inputChannel,looper);</span><br><span class="line">            mLooper= looper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(event <span class="keyword">instanceof</span> MotionEvent) &#123;</span><br><span class="line">                MotionEvent me = (MotionEvent)event;</span><br><span class="line">                <span class="keyword">if</span> (me.getAction() ==MotionEvent.ACTION_UP) &#123;</span><br><span class="line">                    <span class="comment">// 退出程序</span></span><br><span class="line">                    mLooper.quit();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">super</span>.onInputEvent(event);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 实现一个继承自IWindow.Stub的类MyWindow</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span> <span class="keyword">extends</span> <span class="title">IWindow</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resized</span><span class="params">(Rect frame, Rect overscanInsets, Rect contentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Rect visibleInsets, <span class="keyword">boolean</span> reportDraw, Configuration newConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moved</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchAppVisibility</span><span class="params">(<span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchGetNewSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchScreenState</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus, <span class="keyword">boolean</span> touchEnabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">(String command, String parameters, ParcelFileDescriptor out)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeSystemDialogs</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchWallpaperOffsets</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> xStep, <span class="keyword">float</span> yStep, <span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchDragEvent</span><span class="params">(DragEvent event)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchSystemUiVisibilityChanged</span><span class="params">(<span class="keyword">int</span> seq, <span class="keyword">int</span> globalUi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">int</span> localValue, <span class="keyword">int</span> localChanges)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchWallpaperCommand</span><span class="params">(String action, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> z, Bundle extras, <span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doneAnimating</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建androidmk文件"><a class="markdownIt-Anchor" href="#创建androidmk文件"></a> 创建Android.mk文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright 2012 The Android Open Source Project</span></span><br><span class="line"></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_SRC_FILES := $(call all-subdir-java-files)</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_MODULE := samplewindow</span><br><span class="line">include $(BUILD_JAVA_LIBRARY)</span><br></pre></td></tr></table></figure><h4 id="创建编译目录"><a class="markdownIt-Anchor" href="#创建编译目录"></a> 创建编译目录</h4><p>将Android.mk和SampleWindow.java文件放在frameworks\base\cmds\samplewindow目录下，最终的结构如下：<br>frameworks\base\cmds\samplewindow\src\test\wms\samplewindow\SampleWindow.java<br>frameworks\base\cmds\samplewindow\<a href="http://Android.mk" target="_blank" rel="noopener">Android.mk</a></p><h4 id="编译模块"><a class="markdownIt-Anchor" href="#编译模块"></a> 编译模块</h4><p>cd到Android源码目录中执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. /build/envsetup.sh</span><br><span class="line">lunch xxx</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> frameworks\base\cmds\samplewindow\</span><br><span class="line">mm</span><br></pre></td></tr></table></figure><p>经过编译后的模块最终会在out\target\product\system目录下生成samplewindow.jar文件，将该文件拷贝出来</p><h4 id="将jar文件转换为dex文件"><a class="markdownIt-Anchor" href="#将jar文件转换为dex文件"></a> 将jar文件转换为dex文件</h4><p>由于jar文件不能再Android系统中直接运行，需要转换为dex文件，所以我们需要通过sdk工具dx来进行转换，dx脚本在<br>sdk/build-tools/目录下，执行dx --dex --output=samplewindow.dex samplewindow.jar生成dex文件</p><h4 id="执行dex文件"><a class="markdownIt-Anchor" href="#执行dex文件"></a> 执行dex文件</h4><p>通过app_process 命令来执行dex文件，命令如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_process -Djava.class.path=/data/local/tmp/samplewindow.dex /system/bin test.wms.samplewindow.SampleWindow</span><br></pre></td></tr></table></figure><p>执行完成后手机屏幕就会显示我们创建的窗口，根据我们的设置，当在窗口触摸手指离开后退出窗口。</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p>深入理解WindowManagerService<br><a href="https://blog.csdn.net/innost/article/details/47660193" target="_blank" rel="noopener">https://blog.csdn.net/innost/article/details/47660193</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;windowmanagerservice创建窗口测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windowmanagerservice创建窗口测试&quot;&gt;&lt;/a&gt; WindowManagerService创建窗口测试&lt;/h3&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>contentprovider源码走读</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/asop-contentprovider-src/"/>
    <id>http://esligh.github.io/[object Object]/asop-contentprovider-src/</id>
    <published>2018-10-18T14:34:52.000Z</published>
    <updated>2019-03-16T08:10:22.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获取contentresolver"><a class="markdownIt-Anchor" href="#获取contentresolver"></a> 获取ContentResolver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mContentResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Context实例的创建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(ContextImpl container, ActivityThread mainThread,</span></span></span><br><span class="line"><span class="function"><span class="params">    LoadedApk packageInfo, IBinder activityToken, UserHandle user, <span class="keyword">boolean</span> restricted,</span></span></span><br><span class="line"><span class="function"><span class="params">    Display display, Configuration overrideConfiguration)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mContentResolver = <span class="keyword">new</span> ApplicationContentResolver(<span class="keyword">this</span>, mainThread, user);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ApplicationCOntentResolver继承自ContentResolver，ContentResolver是一个抽象类。它是ContextImpl的内部类。</p><h3 id="query"><a class="markdownIt-Anchor" href="#query"></a> query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContentResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> Uri uri, String[] projection,</span></span></span><br><span class="line"><span class="function"><span class="params">        String selection, String[] selectionArgs, String sortOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先根据uri获取到ICP，ICP是ContentProvider的binder接口，继承自IInterface，这里获取unstable类型的        </span></span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过ICP查询，这里涉及到Binder调用</span></span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">//远程进程死亡，负责清理unstable的ICP</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            <span class="comment">//随后创建stable的ICP</span></span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次进行查询，取到Cursor</span></span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qCursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force query execution.  Might fail and throw a runtime exception here.</span></span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        <span class="keyword">long</span> durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap the cursor object into CursorWrapperInner object.</span></span><br><span class="line">        CursorWrapperInner wrapper = <span class="keyword">new</span> CursorWrapperInner(qCursor,</span><br><span class="line">                stableProvider != <span class="keyword">null</span> ? stableProvider : acquireProvider(uri));</span><br><span class="line">        stableProvider = <span class="keyword">null</span>;</span><br><span class="line">        qCursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Arbitrary and not worth documenting, as Activity</span></span><br><span class="line">        <span class="comment">// Manager will kill this process shortly anyway.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (qCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qCursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.setRemote(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unstableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseUnstableProvider(unstableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseProvider(stableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以CursorWrapperInner返回，它实现了Cursor接口。这里unstable和stable的区别在于，unstable的ContentProvider<br>不会因为其远程服务进程的死亡而导致app被杀掉，而stable会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContentResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里acquireUnstableProvider是个抽象方法，那么应该在其子类ApplicationContentResolver中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ApplicationContentResolver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c, auth, mUser.getIdentifier(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里阻塞等待直到获取Provider代理，如果Provider未启动，则先启动</span></span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">    <span class="comment">// any ties in the race.</span></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到它ICP先试通过acquireExistingProvider来获取，如果取到就直接返回，否则就需要通过AMS的getContentProvider来取到的，<br>它返回一个IActivityManager.ContentProviderHolder成员holder,其中的provider就是ICP的binder代理接口。那么acquireExistingProvider<br>大概就是从缓存里取吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);<span class="comment">//以auth和userid构造一个key</span></span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);<span class="comment">//通过该key取到ProviderClientRecord</span></span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IContentProvider provider = pr.mProvider;<span class="comment">//从ProviderClientRecord就可以取到ICP的binder代理接口</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;<span class="comment">//判断binder server是否还活着</span></span><br><span class="line">            <span class="comment">// The hosting process of the provider has died; we can't</span></span><br><span class="line">            <span class="comment">// use this one.</span></span><br><span class="line">            Log.i(TAG, <span class="string">"Acquiring provider "</span> + auth + <span class="string">" for user "</span> + userId</span><br><span class="line">                    + <span class="string">": existing object's process dead"</span>);</span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only increment the ref count if we have one.  If we don't then the</span></span><br><span class="line">        <span class="comment">// provider is not reference counted and never needs to be released.</span></span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            incProviderRefLocked(prc, stable);<span class="comment">//增加该provider的引用计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中mProviderMap中记录的是本进程的ContentProvider，它再应用启动时候就进行了初始化，这样如果是当前应用使用自身的ContentProvider，就不需要再去<br>AMS中查找了，直接从这里就可以取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IApplicationThread caller, String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"getContentProvider"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, stable, userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            String name, IBinder token, <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        ...</span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);<span class="comment">//查看这个contentProvider是否已经有记录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> providerRunning = cpr != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (providerRunning) &#123;<span class="comment">//content provider已经存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                <span class="comment">//Content provider被允许运行在调用者进程，这样让调用者自己实例化一个content provider实例即可</span></span><br><span class="line">                ContentProviderHolder holder = cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">                holder.provider = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//content provider没在运行</span></span><br><span class="line">        <span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">            ……</span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> firstClass = cpr == <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                ApplicationInfo ai =</span><br><span class="line">                            AppGlobals.getPackageManager().</span><br><span class="line">                                getApplicationInfo(</span><br><span class="line">                                        cpi.applicationInfo.packageName,</span><br><span class="line">                                        STOCK_PM_FLAGS, userId);   </span><br><span class="line">                ai = getAppInfoForUser(ai, userId);</span><br><span class="line">                <span class="comment">//为content provider创建record</span></span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, ai, comp, singleton);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mLaunchingProviders.size();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Content provider is now in use, its package can't be stopped.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                                cpr.appInfo.packageName, <span class="keyword">false</span>, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                                + cpr.appInfo.packageName + <span class="string">": "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Use existing process if already started</span></span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);<span class="comment">//获取进程信息</span></span><br><span class="line">                    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span>) &#123;<span class="comment">//如果所在进程已经启动</span></span><br><span class="line">                        proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//启动content provider并发布</span></span><br><span class="line">                            proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//启动conent provider的目标进程</span></span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">                                <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                        cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        ……</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure the provider is published (the same provider class</span></span><br><span class="line">            <span class="comment">// may be published under multiple names).</span></span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环等待,直到provider发布完成才会退出循环.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            cpr.wait();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="provoider的install流程"><a class="markdownIt-Anchor" href="#provoider的install流程"></a> Provoider的install流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInstallProvider</span><span class="params">(ProviderInfo info)</span> </span>&#123;</span><br><span class="line">    installContentProviders(mInitialApplication, Lists.newArrayList(info));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(<span class="string">": "</span>);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发布该provider</span></span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">private</span> IActivityManager.<span class="function">ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">        ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">        IContentProvider provider;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">                localProvider = (ContentProvider)cl.</span><br><span class="line">                    loadClass(info.name).newInstance();</span><br><span class="line">                provider = localProvider.getIContentProvider();</span><br><span class="line">                localProvider.attachInfo(c, info);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">             IBinder jBinder = provider.asBinder();</span><br><span class="line">            <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">                ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">                <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    provider = pr.mProvider;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">                    holder.provider = provider;</span><br><span class="line">                    holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">                    pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                    mLocalProviders.put(jBinder, pr);</span><br><span class="line">                    mLocalProvidersByName.put(cname, pr);</span><br><span class="line">                &#125;</span><br><span class="line">                retHolder = pr.mHolder;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               ... </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该过程主要创建ContentProvider实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            ContentProviderHolder src = providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);<span class="comment">//将实例添加到mProviderMap</span></span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> NL = mLaunchingProviders.size();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NL; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        j--;</span><br><span class="line">                        NL--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.proc = r;</span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                updateOomAdjLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;获取contentresolver&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#获取contentresolver&quot;&gt;&lt;/a&gt; 获取ContentResolver&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Rtmp服务器搭建-推送流</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/live/"/>
    <id>http://esligh.github.io/[object Object]/live/</id>
    <published>2018-10-18T14:34:52.000Z</published>
    <updated>2019-02-20T12:53:23.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于nginx-rtmp的直播服务器搭建"><a class="markdownIt-Anchor" href="#基于nginx-rtmp的直播服务器搭建"></a> 基于Nginx-Rtmp的直播服务器搭建</h3><p>nginx-rtmp在window上的服务端<br><a href="https://github.com/illuspas/nginx-rtmp-win32" target="_blank" rel="noopener">https://github.com/illuspas/nginx-rtmp-win32</a><br>Linux上的搭建<br><a href="https://juejin.im/entry/599634d2f265da248a7a66a7" target="_blank" rel="noopener">https://juejin.im/entry/599634d2f265da248a7a66a7</a></p><p>测试推送流<br><a href="https://www.nodemedia.cn/uploads/NodeMediaDevClient.swf" target="_blank" rel="noopener">https://www.nodemedia.cn/uploads/NodeMediaDevClient.swf</a></p><p>推送流到<br>rtmp://localhost/live/stream</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基于nginx-rtmp的直播服务器搭建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于nginx-rtmp的直播服务器搭建&quot;&gt;&lt;/a&gt; 基于Nginx-Rtmp的直播服务器搭建&lt;/h3&gt;
&lt;p&gt;nginx-rtmp在window上
      
    
    </summary>
    
      <category term="音视频" scheme="http://esligh.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="直播" scheme="http://esligh.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>Android 类加载源码分析(一)</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-classloader-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-classloader-src/</id>
    <published>2018-09-15T01:15:15.000Z</published>
    <updated>2019-03-17T07:50:58.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>本篇将对Android的类加载机制进行分析。总体来说Android的ClassLoader分为系统ClassLoader和自定义的ClassLoader<br>系统的包括有三种：</p><ol><li>BootClassLoader Android系统启动时会使用BootClassLoader预加载一些类。它位于类加载器链的头部。</li><li>PathClassLoader 可以加载已经安装的apk,即也就是/data/app/package 下的apk文件，也可以加载/vendor/lib, /system/lib下的nativeLibrary。</li><li>DexClassLoader，可以加载一个未安装的apk文件。</li></ol><p>我们在App中使用的系统类加载器默认是PathClassLoader，它的父加载器是BootClassLoader。为什么是PathClassLoader呢？因为在contextImpl的getClassLoader有如下实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPackageInfo != <span class="keyword">null</span> ?</span><br><span class="line">            mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//创建PathClassLoader    </span></span><br><span class="line">            mClassLoader =</span><br><span class="line">                ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                    zip, libraryPath, mBaseClassLoader);</span><br><span class="line">            ……</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /frameworks/base/core/java/android/app/ApplicationLoaders.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader;</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//创建PathClassLoader</span></span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            <span class="keyword">return</span> pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">return</span> pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出ContextImpl为用户提供了PathClassLoader来供App加载。</p><h3 id="basedexclassloader"><a class="markdownIt-Anchor" href="#basedexclassloader"></a> BaseDexClassLoader</h3><p>Android中使用PathClassLoader来加载类，其实实现的就是从本地文件系统中加载类，它继承自BaseDexClassLoader，BaseDexClassLoader继承子ClassLoader，ClassLoader是一个抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcore/libdvm/src/main/java/java/lang/ClassLoader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际上为PathClassLoader</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader loader = ClassLoader.createSystemClassLoader();    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The parent ClassLoader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">         <span class="comment">//创建Android系统的ClassLoader即PathClassLoader</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, BootClassLoader.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SystemClassLoader.loader;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//返回已经被VM加载的类，如果已经加载过返回这个Class</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String className) &#123;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == BootClassLoader.getInstance())</span><br><span class="line">            loader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loader = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> VMClassLoader.findLoadedClass(loader, className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class加载的逻辑，先判断是否已经加载，已经加载就直接返回，否则通过findClass进行加载</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);<span class="comment">//查找是否已经加载过该类</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;<span class="comment">//clazz为null表示未加载过</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = parent.loadClass(className, <span class="keyword">false</span>);<span class="comment">//先通过parent加载，这也是遵循双亲委派模型</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Don't want to see this.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;<span class="comment">//parent loader未能加载则通过findClass来加载</span></span><br><span class="line">                clazz = findClass(className);<span class="comment">//注意findClass在该类的实现为空，它是由子类实现类加载的逻辑的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;<span class="comment">//返回加载的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出ClassLoader为我们实现了类加载的基本逻辑，首先它通过findLoadedClass查找要加载的类是否已经加载，如果已经加载了就直接返回，否则通过parent loader进行加载，这符合双亲委派的加载模型，如果父类loader找到该类并加载则返回，否则通过子类加载器进行加载，子类加载时通过findClass进行加载的。所以需要实现findClass的具体逻辑。那么在BaseDexClassLoader我们需要重点关注findClass的类加载逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">       <span class="comment">//BaseDexClassLoader继承自ClassLoader，这里将findClass的任务委托给了DexPathList</span></span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//没找到就抛出异常</span></span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现BaseDexClassLoader的实现非常简单，它内部有一个DexPathList成员pathList，在构造方法中进行初始化，它代表了一个jar/apk文件列表，在这些文件之中包含了class文件和资源文件。而在findClass中实际上是将加载类的任务委托给了pathList。那么就需要再取分析DexPathList了，在这之前我们看看它大概会包含的信息，这是我在应用中打印的ClassLoader信息，它内部的DexPathList包含了该apk和lib的信息。</p><blockquote><p>classLoader: dalvik.system.PathClassLoader[DexPathList[[zip file “/data/app/com.yujian.myapplication-2.apk”],nativeLibraryDirectories=[/data/app-lib/com.yujian.myapplication-2, /system/lib]]]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;<span class="comment">//Element是对应于dex/apk文件或者目录</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里 dexPath可以包含多个dex文件，这也是为什么会叫DexPathList</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions);<span class="comment">//生成Element数组</span></span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexPathList有两个成员dexElements和nativeLibraryDirectories，分别用来描述dex/apk文件信息和lib文件。它们都是在DexPathList构造方法中进行初始化的。其中dexElements是通过makeDexElements和splitLibraryPath生成的。其中Element的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File file;<span class="comment">//代表了源文件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;<span class="comment">//当前描述的文件是否为目录</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File zip;<span class="comment">//源文件如果未压缩文件 zip和file就是同一个File</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;<span class="comment">//dex文件</span></span><br><span class="line">        ……</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(File file, <span class="keyword">boolean</span> isDirectory, File zip, DexFile dexFile)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.file = file;</span><br><span class="line">            <span class="keyword">this</span>.isDirectory = isDirectory;</span><br><span class="line">            <span class="keyword">this</span>.zip = zip;</span><br><span class="line">            <span class="keyword">this</span>.dexFile = dexFile;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                             ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;<span class="comment">//遍历文件</span></span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();<span class="comment">//文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;<span class="comment">//后缀为.dex</span></span><br><span class="line">            <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);<span class="comment">//直接通过loadDexFile加载</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;<span class="comment">//后缀为.apk/.jar/.zip的情况</span></span><br><span class="line">            zip = file;<span class="comment">//赋值给zip</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * IOException might get thrown "legitimately" by the DexFile constructor if the</span></span><br><span class="line"><span class="comment">                    * zip file turns out to be resource-only (that is, no classes.dex file in it).</span></span><br><span class="line"><span class="comment">                    * Let dex == null and hang on to the exception to add to the tea-leaves for</span></span><br><span class="line"><span class="comment">                    * when findClass returns null.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                suppressedExceptions.add(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;<span class="comment">//为目录的情况</span></span><br><span class="line">            <span class="comment">// We support directories for looking up resources.</span></span><br><span class="line">            <span class="comment">// This is only useful for running libcore tests.</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));<span class="comment">//添加一个Element目录 true表示为目录</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"Unknown file type for: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));<span class="comment">//添加一个dex文件对应的Element</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeDexElements通过dexPath代表的dex/apk文件或者目录生成对应的elements数组，在构造DexPathList时传递的dexPath时可能包含多个文件路径的，我们上面打印的信息就只有一个apk，这里需要注意，这些文件路径经过splitDexPath返回一个ArrayList<file>代表了dexPath所代表的文件列表。通过一个循环处理这个文件列表，针对不同的文件类型比如dex/apk/jar/zip或者目录进行不同的处理：</file></p><ol><li>如果时dex文件，通过loadDexFile加载，并返回一个描述该文件的DexFile,</li><li>如果时zip/apk/jar，先保存压缩文件到zip中，然后通过loadDexFile加载并返回要描述的dex文件的DexFile</li><li>如果时目录，直接为其生成一个Element并添加到elements数组中</li></ol><p>对于1和2两种情况最终也会未其分别创建Element并添加到elements数组中,这个elements数组最终就是我们要的dexElements。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;<span class="comment">//对于PathClassLoader来说 optimizedDirectory总是为null的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);<span class="comment">//直接new一个DexFile返回 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadDexFile实际上只是为file创建一个DexFile对象。从名称上看它是专门处理dex文件的。</p><p>下面我们就看看DexPathList是如何加载类的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;<span class="comment">//遍历dexElements</span></span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;<span class="comment">//通过dexFile加载类</span></span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;<span class="comment">//加载成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexPathList先遍历dexElements，对于DexFile通过loadClassBinaryName来加载，如果找到就返回。这里又转到DexFile进行加载了，所以需要再看看DexFile是如何加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DexFile加载类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    Class result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过native来加载 runtime/native/dalvik_system_DexFile.cc</span></span><br><span class="line">        result = defineClassNative(name, loader, cookie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexFile调用defainClassNative方法来加载类，这里从名称看，它实际上是从native层加载类的，实现在runtime/native/dalvik_system_DexFile.cc。关于native层如何加载类我们在另外的篇章中进行分析。这样DexPathList加载类的逻辑就分析完成了。</p><blockquote><p>需要注意的是DexPathList遍历dexElements通过DexFile来进行的类加载的方式，为一些基于muti dex的热修复技术提供了可能，因为在dexElements数组中靠前的dex文件首先被访问到,这样被修复的类可以被优先加载。</p></blockquote><h3 id="pathclassloader"><a class="markdownIt-Anchor" href="#pathclassloader"></a> PathClassLoader</h3><p>PathClassLoader是BaseDexClassLoader的子类，它的类加载功能正是依赖于其父类。<br>我们看看它的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathClassLoader的实现非常简单，只是提供了两个不同的构造方法，这两个构造方法的区别在于是否提供了lib path，默认情况下的path就是system/lib/和data/app-lib/pakage-name</p><h3 id="dexclassloader"><a class="markdownIt-Anchor" href="#dexclassloader"></a> DexClassLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class loader that loads classes from &#123;<span class="doctag">@code</span> .jar&#125; and &#123;<span class="doctag">@code</span> .apk&#125; files</span></span><br><span class="line"><span class="comment"> * containing a &#123;<span class="doctag">@code</span> classes.dex&#125; entry. This can be used to execute code not</span></span><br><span class="line"><span class="comment"> * installed as part of an application.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span></span><br><span class="line"><span class="comment"> * cache optimized classes. Use &#123;<span class="doctag">@code</span> Context.getDir(String, int)&#125; to create</span></span><br><span class="line"><span class="comment"> * such a directory: &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   File dexOutputDir = context.getDir("dex", 0);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * External storage does not provide access controls necessary to protect your</span></span><br><span class="line"><span class="comment"> * application from code injection attacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexClassLoader的实现更加简单，只有一个构造方法，从注释也可以看出它可以从包含classes.dex文件的jar/apk文件中来加载类，而不需要jar/apk为已安装应用的一部分。因为它提供了一个optimizedDirectory参数，这个参数是一个应用私有且可写入的目录，用来保存dex经过优化后的类，需要注意的是为了防止注入，优化后的类是不能被保存在外置存储上的。在PathClassLoader中我们看到这个参数默认是null，也就是它会从默认的位置加载dex，这个位置就是/data/dalvik-cache，也就是已经安装的apk。这也是它们之间最大的区别了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;本篇将对Android的类加载机制进行分析。总体来说Android的ClassLoader分为系统ClassLoader和自定义的ClassLo
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger合成layer过程详解</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surfaceflinger-composer-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surfaceflinger-composer-src/</id>
    <published>2018-08-02T08:51:26.000Z</published>
    <updated>2019-03-16T08:09:35.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>本篇将对Android GUI系统SurfaceFlinger（简称SF）合成layer的具体过程进行分析。合成过程是SF最核心的任务，这个过程贯穿了整个SF业务逻辑，SF所有的工作都最终是为了合成显示做准备。所以，了解SF的合成过程对于我们进一步了解Android GUI系统是必不可少的一部分。</p><h3 id="vsync控制合成"><a class="markdownIt-Anchor" href="#vsync控制合成"></a> VSYNC控制合成</h3><p>在介绍SF的VSYNC信号控制同步的篇节中，我们分析了VSYNC信号在绘制和合成过程中所发挥的作用，在SF的init方法中，我们创建了合成延时源并通过EventThread管理该延时源，同时我们通过SF的MessageQueue来为SF创建一个监听合成延时源的Connection并将其注册到EventThread的监听者集合中，这样当合成延时源接收到VSYNC信号后通知SF MessageQueue，然后MessageQueue将该事件通知给SF，随后就可以开始进行合成过程了。这之间MessageQueue可以看作是SF的“秘书”，它负责接收一些SF的消息事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="keyword">false</span>);<span class="comment">//创建合成延时Vsync源</span></span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);<span class="comment">//将合成延时vysnc源与SF的事件管理关联，因为SF主要负责合成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里mSFEventThread为管理合成延时源的EventThread，mEventQueue为SF的MessageQueue，这里通过其setEventThread将其注册为EventThread的监听者，负责接收来自合成延时源的VSYNC事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span></span><br><span class="line"><span class="comment">//合成延时源的EventThread会和SF的MessageQueue关联起来</span></span><br><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">//为SF创建延时源的Connection监听</span></span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();<span class="comment">//取到BitTube</span></span><br><span class="line">    <span class="comment">//将其描述符fd添加到Looper中，当延时源的EventHandler收到VSYNC信号后触发cb_eventReceiver回调</span></span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过EventThead的createEventConnection方法创建一个Connection，这个Connection在第一次引用时被注册到EventThread的监听者队列中，随后获取到Connection对应的BitTube，然后将BitTube的文件描述符添加到MessageQueue的Looper中监听起来，监听的回调为MessageQueue::cb_eventReceiver，这样当EventThread通过Connection通知VSYNC信号到达时可以触发回调通知MessageQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当监听到Connection对应的BitTube的文件描述符有事件到达时，这个回调方法被Looper触发</span></span><br><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果MessageQueue请求了VSYNC信号，合成延时源收到VSYNC信号后触发该回调，再该回调中通知SF进行合成操作</span></span><br><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">#if INVALIDATE_ON_VSYNC </span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">#else</span><br><span class="line">                mHandler-&gt;dispatchRefresh();</span><br><span class="line">#endif</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cb_eventReceiver被触发后调用eventReceiver处理VSYNC信号事件，这里先通过DisplayEventReceiver::getEvents方法读取到事件信息。然后对VSYNC事件进行处理，这里INVALIDATE_ON_VSYNC被定义为1，所以通过mHandler的dispatchInvalidate方法进行处理。mHandler是MessageQueue内部使用的Handler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::REFRESH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchTransaction() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskTransaction, &amp;mEventMask) &amp; eventMaskTransaction) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::TRANSACTION));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:</span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue内部的Handler定义了三个dispatch方法，dispatchRefresh，dispatchInvalidate，dispatchTransaction，对应的在SF一端会通过onMessageReceived分别处理这三个事件，合成的任务也是在其中做处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:</span><br><span class="line">    <span class="comment">//负责处理Layer或者Display的属性变更，这些变更可能影响到图层可见区域脏区域的计算。</span></span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        <span class="comment">//主要调用handlePageFlip，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域</span></span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();<span class="comment">//会触发handleMessageRefresh</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();<span class="comment">//合并和渲染输出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SF的onMessageReceived方法中分别处理TRANSACTION，INVALIDATE以及REFRESH事件，TRANSACTION事件主要是处理Layer和Display的属性变更，这些变更更可能影响到图层可见区域及脏区域的计算。在INVALIDATE事件中除了处理TRANSACTION事件的内容外，还需要获取合成图层layer的最新帧数据，同时还要根据内容更新脏区域。REFRESH事件中主要是合并和渲染输出的处理。实际上我们可以看到，在INVALIDATE事件中包含了TRANSACTION和REFRESH事件的内容，它会完整的处理一次合并和渲染输出过程。大多数情况下SF的任务也是处理INVALIDATE事件。所以接下来我们分析的重点就从INVALIDATE事件开始。</p><h4 id="触发合成的时机"><a class="markdownIt-Anchor" href="#触发合成的时机"></a> 触发合成的时机</h4><p>SF合成机制依赖于VSYNC信号，但显示设备并不是任何时候都会去进行合成操作，显然，当显示设备的layer没有发生任何变化时候就不需要也不应该去让SF合成，只有当layer内部发生了变化，如最常见的应用绘制好了新的一帧数据，这时候会通过Layer BufferQueue的消费者接口onFrameAvaliable通知SF有新的一帧数据，这时候需要对layer进行合成渲染就需要去请求VSYNC信号，EventThread根据请求触发合成延时源的VSYNC信号通知给监听者也就是上面的MessageQueue，MessageQueue会通知SF去及逆行合成操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/Layer.cpp</span></span><br><span class="line"><span class="keyword">void</span> Layer::onFrameAvailable() &#123;</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);<span class="comment">//mQueuedFrames加1</span></span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();<span class="comment">//安排一次合成操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有新的一帧数据准备好了，通过SF通知MessageQueue安排一次合成操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过MessageQueue的invalidate方法请求一次VSYNC信号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////frameworks/native/services/surfaceflinger/MessageQueue.cpp</span></span><br><span class="line"><span class="keyword">void</span> MessageQueue::invalidate() &#123;</span><br><span class="line">#if INVALIDATE_ON_VSYNC</span><br><span class="line">    mEvents-&gt;requestNextVsync();<span class="comment">//请求一次VSYNC</span></span><br><span class="line">#else</span><br><span class="line">    mHandler-&gt;dispatchInvalidate();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invalidate会通过requestNextVsync请求一次VSYNC信号，这个会通过合成延时源的EventThread进行，当VSYNC信号到达后，会通知MessageQueue注册的监听者，从而将VSYNC信号事件传递给MessageQueue,MessageQueue最终告知SF进行合成操作。</p><h4 id="处理layer及display属性变更"><a class="markdownIt-Anchor" href="#处理layer及display属性变更"></a> 处理Layer及Display属性变更</h4><p>handleMessageTransaction的任务是处理Layer及Display的属性变更，这个什么意思呢？在Layer内部有实际上有两个State对象mCurrentState和mDrawingState，都维护着Layer的状态信息，当用户调用Layer的方法对其属性如大小，透明度等做了更改后<br>，设置的值是保存在mCurrentState这个对象中，而mDrawingState是当前正在使用的状态，这样做的目的是不会因为用户的更改而影响到Layer的绘制合成过程。所以在handleMessageTransaction方法中会计算相关Layer的属性变更，这些变更可能影响到后续可见区域的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageTransaction() &#123;</span><br><span class="line">    uint32_t transactionFlags = peekTransactionFlags(eTransactionMask);</span><br><span class="line">    <span class="keyword">if</span> (transactionFlags) &#123;</span><br><span class="line">        handleTransaction(transactionFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransaction(uint32_t transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">    <span class="comment">//进一步处理</span></span><br><span class="line">    handleTransactionLocked(transactionFlags);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleMessageTransaction通过peekTransactionFlags查看transaction flag，这个标记决定是否需要进行transaction<br>，如果需要调用handleTransaction进一步通过调用handleTransactionLocked方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//取到当前状态的Layer集合</span></span><br><span class="line">    <span class="keyword">const</span> LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);</span><br><span class="line">    <span class="keyword">const</span> size_t count = currentLayers.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;<span class="comment">//遍历所有的Layer</span></span><br><span class="line">            <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">            <span class="comment">//取到layer的transaction flag用以判断是否需要进行transaction</span></span><br><span class="line">            uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">            <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//调用layer的doTransaction处理变更，这些变更可能会影响到可视区域的计算，如果有一个layer影响到，</span></span><br><span class="line"><span class="comment">//就将mVisibleRegionsDirty置true</span></span><br><span class="line">            <span class="keyword">const</span> uint32_t flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                mVisibleRegionsDirty = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理显示设备的变更</span></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">        <span class="comment">//当前显示设备</span></span><br><span class="line">        <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">        <span class="comment">//上次的显示设备</span></span><br><span class="line">        <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理transform hint</span></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    <span class="comment">//说明layer增加了，这里置mVisibleRegionsDirty为true</span></span><br><span class="line">    <span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">        <span class="comment">// layers have been added</span></span><br><span class="line">        mVisibleRegionsDirty = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some layers might have been removed, so</span></span><br><span class="line">    <span class="comment">// we need to update the regions they're exposing.</span></span><br><span class="line">    <span class="comment">//layer被移除了</span></span><br><span class="line">    <span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">        mLayersRemoved = <span class="keyword">false</span>;</span><br><span class="line">        mVisibleRegionsDirty = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">const</span> size_t count = layers.size();</span><br><span class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">            <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;<span class="comment">//如果这个layer不存在</span></span><br><span class="line">                <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">                <span class="comment">//       compute the actual visible region</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">                <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">                Region visibleReg = s.transform.transform(</span><br><span class="line">                        Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">                <span class="comment">//将删除的layer的可见区域置为无效以便后续进行更新</span></span><br><span class="line">                invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//提交变更</span></span><br><span class="line">    commitTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SF内部也维护了两个State状态，mCurrentState和mDrawingState，它们同Layer内部的State定义是不同，mDrawingState是SF上次合成使用的绘图状态，而mCurrentState是SF当前最新的绘图状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct State &#123;</span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在State的内部包含了一个LayerVector对象layersSortedByZ，从名称上看它是一个以Z序排序的layer集合。这个集合中的layer就是SF即将要使用进行合成的layer。另一个成员displays描述了显示设备的状态信息，它实际上一个Map,key值为设备的Token，也是一个IBinder，value为DisplayDeviceState代表显示设备的状态。</p><p>在handleTransactionLocked方法中，我们先从当前状态中取出Layer集合，然后针对每个layer进行doTransaction处理，这里面会对layer的属性变更做处理，我们后面再分析，根据其处理结果，我们可以直到是否影响到可见区域，如果影响到则标记<br>mVisibleRegionsDirty为true。随后处理显示设备的变更，为什么会在这里处理我想可能是为了支持显示设备的热插拔。通过对比前后两次设备状态，可以知道设备是被移除了还是添加了，或者是设备的其他信息发生了变化等等，针对这些做不同的处理。<br>设备的增加和删除都会分别从SF的mDisplays进行相应的增加和删除操作，mDisplays是一个DefaultKeyedVector&lt; wp<ibinder>, sp<displaydevice> &gt;，它维护了SF使用的显示设备。</displaydevice></ibinder></p><p>接下来处理transform hint的变更，transform hint被用来提高layer的系统性能，关于这个在本篇中不做介绍，略过。</p><p>最后的部分是处理layer的变更，前后两次的绘制合成过程，可能有新的layer添加进来，这时候我们同样需要置mVisibleRegionsDirty为true，表示可见区域的变化，但也有可能之前使用的layer被移除，那么它之前的显示区域也就成了脏区域，需要进行更新，这个是通过invalidateLayerStack处理的。随后通过commitTransaction提交transaction，将mCurrentState赋值给mDrawingState</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::commitTransaction()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line">    mTransactionPending = <span class="keyword">false</span>;</span><br><span class="line">    mAnimTransactionPending = <span class="keyword">false</span>;</span><br><span class="line">    mTransactionCV.broadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="layer的属性变更"><a class="markdownIt-Anchor" href="#layer的属性变更"></a> layer的属性变更</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理layer的变更</span></span><br><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">    <span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line">    <span class="keyword">const</span> Layer::State&amp; c(getCurrentState());</span><br><span class="line"><span class="comment">//大小是否发生了变化</span></span><br><span class="line">    <span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                             (c.requested.h != s.requested.h);</span><br><span class="line">    <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">        <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">        <span class="comment">// a buffer, it'll get the new size.</span></span><br><span class="line">        <span class="comment">//layer的大小发生了变化</span></span><br><span class="line">        mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">                c.requested.w, c.requested.h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">                                   (c.requested.h != c.active.h);</span><br><span class="line">        <span class="keyword">if</span> (resizePending) &#123;</span><br><span class="line">            <span class="comment">// don't let Layer::doTransaction update the drawing state</span></span><br><span class="line">            <span class="comment">// if we have a pending resize, unless we are in fixed-size mode.</span></span><br><span class="line">            <span class="comment">// the drawing state will be updated only once we receive a buffer</span></span><br><span class="line">            <span class="comment">// with the correct size.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// in particular, we want to make sure the clip (which is part</span></span><br><span class="line">            <span class="comment">// of the geometry state) is latched together with the size but is</span></span><br><span class="line">            <span class="comment">// latched immediately when no resizing is involved.</span></span><br><span class="line"></span><br><span class="line">            flags |= eDontUpdateGeometryState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always set active to requested, unless we're asked not to</span></span><br><span class="line">    <span class="comment">// this is used by Layer, which special cases resizes.</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">        editCurrentState.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//活动大小也发生了变化</span></span><br><span class="line">    <span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">        <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">        flags |= Layer::eVisibleRegion;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当Layer的position，Zorder，alpha,matrix,transparent region,flags,crops.等发生变化的时候，sequence就会自增。这里不相等说明属性发生了变更</span></span><br><span class="line">    <span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">        <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">        flags |= eVisibleRegion;</span><br><span class="line">        <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">        <span class="keyword">const</span> uint8_t type = c.transform.getType();</span><br><span class="line">        mNeedsFiltering = (!c.transform.preserveRects() ||</span><br><span class="line">                (type &gt;= Transform::SCALE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commit the transaction</span></span><br><span class="line">    commitTransaction();<span class="comment">//更新layer的绘图状态</span></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layer的属性变更也是通过比较mDrawingState和mCurrentState进行计算的，最后同样会通过commitTransaction提交transaction。在这里会对影响可视区域计算的属性做了Layer::eVisibleRegion标记。</p><h4 id="获取layer的帧数据以及计算显示设备的脏区域"><a class="markdownIt-Anchor" href="#获取layer的帧数据以及计算显示设备的脏区域"></a> 获取Layer的帧数据以及计算显示设备的脏区域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageInvalidate() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    handlePageFlip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line"></span><br><span class="line">    bool visibleRegions = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//取到layer列表</span></span><br><span class="line">    <span class="keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    <span class="keyword">const</span> size_t count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        <span class="comment">//使用latchBuffer更新layer的图像，并获取其最新的显示数据到mActiveBuffer</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions)</span>)</span>;</span><br><span class="line">        <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">        invalidateLayerStack(s.layerStack, dirty);<span class="comment">//设置layer关联的设备的更新区域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新完transcation后接下来就是获取layer显示数据，这个是通过layer的latchBuffer方法获取到的，通过latchBuffer可以得知layer的可见区域，这个可见区域就是显示设备需要更新的脏区域，脏区域通过invalidateLayerStack计算。</p><h3 id="合成过程分析"><a class="markdownIt-Anchor" href="#合成过程分析"></a> 合成过程分析</h3><h4 id="合成主要流程"><a class="markdownIt-Anchor" href="#合成主要流程"></a> 合成主要流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ...</span><br><span class="line">    preComposition();</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    ...</span><br><span class="line">    doComposition();</span><br><span class="line">    postComposition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="precomposition"><a class="markdownIt-Anchor" href="#precomposition"></a> preComposition</h5><p>合成的过程主要是在handleMessageRefresh中进行的，我们分别介绍，先看preComposition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合成前的预处理</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::preComposition()</span><br><span class="line">&#123;</span><br><span class="line">    bool needExtraInvalidate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">    <span class="keyword">const</span> size_t count = layers.size();</span><br><span class="line">    <span class="comment">//取到当前绘制的layer，对于每个layer调用其onPreComposition判断其是否还有未处理的的frame，如果</span></span><br><span class="line">    <span class="comment">//有就将needExtraInvalidate置为true，表示需要进行额外的合成和渲染操作</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">            needExtraInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有layer还有未处理的frame，则需要再进行一次合成和渲染操作</span></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合成预处理回调，这里判断layer是否还有未处理的queued frame</span></span><br><span class="line">bool Layer::onPreComposition() &#123;</span><br><span class="line">    mRefreshPending = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preComposition是合成的预处理部分，这部分是判断合成前是否有layer还有新的帧数据mQueuedFrames &gt; 0，如果有的话就需要通过signalLayerUpdate再安排一次合成操作。</p><h5 id="rebuildlayerstacks"><a class="markdownIt-Anchor" href="#rebuildlayerstacks"></a> rebuildLayerStacks</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重建设备的可见Layer集合，并计算每个layer的可见区域和脏区域</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">    <span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_CALL();</span><br><span class="line">        mVisibleRegionsDirty = <span class="keyword">false</span>;</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line">        <span class="keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">        <span class="comment">//对每一个显示设备都需要重建可见layer</span></span><br><span class="line">        <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            Region opaqueRegion;<span class="comment">//不透明区域</span></span><br><span class="line">            Region dirtyRegion;<span class="comment">//透明区域</span></span><br><span class="line">            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;<span class="comment">//可见layer集合</span></span><br><span class="line">            <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="keyword">const</span> Transform&amp; tr(hw-&gt;getTransform());<span class="comment">//设备的变换矩阵</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(hw-&gt;getBounds()</span>)</span>;<span class="comment">//设备的显示区域</span></span><br><span class="line">            <span class="keyword">if</span> (hw-&gt;canDraw()) &#123;</span><br><span class="line">                <span class="comment">//为设备layer计算可见区域</span></span><br><span class="line">                SurfaceFlinger::computeVisibleRegions(layers,</span><br><span class="line">                        hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"><span class="comment">//重建可见layer</span></span><br><span class="line">                <span class="keyword">const</span> size_t count = layers.size();</span><br><span class="line">                <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">                    <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">                    <span class="comment">//只有layer和显示设备的layerStack匹配才能在该设备上显示</span></span><br><span class="line">                    <span class="keyword">if</span> (s.layerStack == hw-&gt;getLayerStack()) &#123;</span><br><span class="line">                    <span class="comment">//绘制的区域为layer的可见非透明区域</span></span><br><span class="line">                        <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line"><span class="function"><span class="params">                                layer-&gt;visibleNonTransparentRegion)</span>)</span>;</span><br><span class="line">                        drawRegion.andSelf(bounds);<span class="comment">//如果layer的可见区域和当前的设备的窗口区域做交集</span></span><br><span class="line">                        <span class="comment">//如果可见区域和当前的设备区域有交集，则该layer需要显示出来，将其添加到可见layer的集合中</span></span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            layersSortedByZ.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置设备的可见Layer集合，比如主屏幕可以有startus bar,app,navigation bar对应的layer，</span></span><br><span class="line">            <span class="comment">//这些layer存放在layersSortedByZ集合中</span></span><br><span class="line">            hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">            hw-&gt;undefinedRegion.set(bounds);<span class="comment">//初始的未定义区域为设备的显示区域</span></span><br><span class="line">            hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));<span class="comment">//未定义区域=当前未定义区域-不透明区域</span></span><br><span class="line">            hw-&gt;dirtyRegion.orSelf(dirtyRegion);<span class="comment">//设置脏区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuildLayerStacks负责重建设备的可见Layer集合，并计算每个layer的可见区域和脏区域。每个显示设备都有一个可见layer集合，这个layer集合将最终被合成在显示设备上。rebuildLayerStacks针对每一个显示设备都进行处理，通过computeVisibleRegions为每个显示设备计算layer可见区域和脏区域，当layer的可见区域和设备窗口区域有交集说明该layer可以显示在该设备中，添加到其可见的layer集合layersSortedByZ中，最后通过setVisibleLayersSortedByZ将该集合设置给显示设备，同时更新显示设备的脏区域dirtyRegion。</p><h5 id="setuphwcomposer"><a class="markdownIt-Anchor" href="#setuphwcomposer"></a> setUpHWComposer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;beginFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HWComposer&amp; hwc(getHwComposer());</span><br><span class="line">    <span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// build the h/w work list</span></span><br><span class="line">        <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">            mHwWorkListDirty = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//针对每个设备创建workList</span></span><br><span class="line">            <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">                <span class="keyword">const</span> int32_t id = hw-&gt;getHwcDisplayId();</span><br><span class="line">                <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                        hw-&gt;getVisibleLayersSortedByZ());<span class="comment">//取到每个设备的可见Layer集合</span></span><br><span class="line">                    <span class="keyword">const</span> size_t count = currentLayers.size();</span><br><span class="line">                    <span class="comment">//为设备创建workdList</span></span><br><span class="line">                    <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                        <span class="comment">//LayerListIterator用于遍历创建的worklist，具体为遍历DisplayData.list-&gt;hwLayers</span></span><br><span class="line">                        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                            <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                            layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                            <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize) &#123;</span><br><span class="line">                                cur-&gt;setSkip(<span class="keyword">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the per-frame data</span></span><br><span class="line">        <span class="comment">//遍历当前要显示的设备</span></span><br><span class="line">        <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="keyword">const</span> int32_t id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//取到设备的可见Layer集合，这个集合是在rebuildLayerStacks方法中设置的</span></span><br><span class="line">                <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                    hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">                <span class="keyword">const</span> size_t count = currentLayers.size();</span><br><span class="line">                HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                <span class="comment">//为可见的layer设置当前帧的数据</span></span><br><span class="line">                <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                     * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//这里需要注意LayerListIterator的++操作会去迭代DisplayData.list-&gt;hwLayers</span></span><br><span class="line">                    <span class="comment">//同时*cur返回的实际上是LayerListIterator内部的HWCLayer，HWCLayerVersion1实现了抽象类HWCLayer</span></span><br><span class="line">                    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                    layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过HWC的prepare确定合成方式</span></span><br><span class="line">        status_t err = hwc.prepare();</span><br><span class="line">        ALOGE_IF(err, <span class="string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            hw-&gt;prepareFrame(hwc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setUpHWComposer负责为显示设备创建workList，为每个设备要输出显示的layer设置frame data，最后由HWC的prepare确定显示设备可见layer的合成方式，下面我们详细的分析这些内容。</p><h6 id="创建worklist"><a class="markdownIt-Anchor" href="#创建worklist"></a> 创建WorkList</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></span><br><span class="line"><span class="comment">//设备创建worklist，这里的id为显示设备的id，numLayers是显示设备的可见layer集合数目</span></span><br><span class="line">status_t HWComposer::createWorkList(int32_t id, size_t numLayers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uint32_t(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">    <span class="comment">//每个设备都有一个DisplayData用来描述显示设备的信息</span></span><br><span class="line">        DisplayData&amp; disp(mDisplayData[id]);</span><br><span class="line">        <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">            <span class="comment">// we need space for the HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            <span class="comment">//如果版本为HWC_DEVICE_API_VERSION_1_1，则需要额外的一个hwc_layer_1_t用来存放合成后的纹理</span></span><br><span class="line">            numLayers++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化worklist主要是为初始化DispalyData中的hwc_display_contents_1，为其开辟内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (disp.capacity &lt; numLayers || disp.list == NULL) &#123;</span><br><span class="line">            size_t size = sizeof(hwc_display_contents_1_t)</span><br><span class="line">                    + numLayers * sizeof(hwc_layer_1_t);</span><br><span class="line">            free(disp.list);</span><br><span class="line">            <span class="comment">//分配hwc_display_contents_1_t，其中存放的是要显示的layer</span></span><br><span class="line">            disp.list = (hwc_display_contents_1_t*)malloc(size);</span><br><span class="line">            disp.capacity = numLayers;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">//hwc_display_contents_1内部的hwLayers的最后一个为FrameBufferTarget，合成后的纹理就存放在该对象中</span></span><br><span class="line">        <span class="comment">//这里将它拿出来赋值给framebufferTarget</span></span><br><span class="line">            disp.framebufferTarget = &amp;disp.list-&gt;hwLayers[numLayers - <span class="number">1</span>];</span><br><span class="line">            memset(disp.framebufferTarget, <span class="number">0</span>, sizeof(hwc_layer_1_t));</span><br><span class="line">            <span class="keyword">const</span> hwc_rect_t r = &#123; <span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) disp.width, (<span class="keyword">int</span>) disp.height &#125;;</span><br><span class="line">            <span class="comment">//这里初始化这个用来存放合成后的hwc_layer_1_t</span></span><br><span class="line">            <span class="comment">//类型为HWC_FRAMEBUFFER_TARGET，表示它是由GPU合成的</span></span><br><span class="line">            disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET;</span><br><span class="line">            disp.framebufferTarget-&gt;hints = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;flags = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;handle = disp.fbTargetHandle;</span><br><span class="line">            disp.framebufferTarget-&gt;transform = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;blending = HWC_BLENDING_PREMULT;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.left = <span class="number">0</span>;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.top = <span class="number">0</span>;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.right = disp.width;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.bottom = disp.height;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCrop = r;</span><br><span class="line">            &#125;</span><br><span class="line">            disp.framebufferTarget-&gt;displayFrame = r;</span><br><span class="line">            disp.framebufferTarget-&gt;visibleRegionScreen.numRects = <span class="number">1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;visibleRegionScreen.rects =</span><br><span class="line">                &amp;disp.framebufferTarget-&gt;displayFrame;</span><br><span class="line">            disp.framebufferTarget-&gt;acquireFenceFd = -<span class="number">1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;releaseFenceFd = -<span class="number">1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;planeAlpha = <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        disp.list-&gt;retireFenceFd = -<span class="number">1</span>;</span><br><span class="line">        disp.list-&gt;flags = HWC_GEOMETRY_CHANGED;</span><br><span class="line">        disp.list-&gt;numHwLayers = numLayers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个显示设备都有一个DisplayData对象用来描述显示数据。DisplayData的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct DisplayData &#123;</span><br><span class="line">        DisplayData();</span><br><span class="line">        ~DisplayData();</span><br><span class="line">        uint32_t width;</span><br><span class="line">        uint32_t height;</span><br><span class="line">        uint32_t format;    <span class="comment">// pixel format from FB hal, for pre-hwc-1.1</span></span><br><span class="line">        <span class="keyword">float</span> xdpi;</span><br><span class="line">        <span class="keyword">float</span> ydpi;</span><br><span class="line">        nsecs_t refresh;</span><br><span class="line">        bool connected;</span><br><span class="line">        bool hasFbComp;<span class="comment">//标记GLES合成</span></span><br><span class="line">        bool hasOvComp;<span class="comment">//标记硬件合成</span></span><br><span class="line">        size_t capacity;</span><br><span class="line">        <span class="comment">//list包括这个显示设备上所有的layer数据，layer数据放在hwLayers中，hwc_display_contents_1结构描述的是</span></span><br><span class="line">        <span class="comment">//这个结构描述的是输出到显示设备的内容，具体见hwcomposer.h中的定义</span></span><br><span class="line">        <span class="comment">//需要注意的是list-&gt;hwLayers的最后一个存放的是合成的layer</span></span><br><span class="line">        hwc_display_contents_1* list;</span><br><span class="line">        hwc_layer_1* framebufferTarget;<span class="comment">//gup合成的layer放在framebufferTarget中</span></span><br><span class="line">        buffer_handle_t fbTargetHandle;</span><br><span class="line">        sp&lt;Fence&gt; lastRetireFence;  <span class="comment">// signals when the last set op retires</span></span><br><span class="line">        sp&lt;Fence&gt; lastDisplayFence; <span class="comment">// signals when the last set op takes</span></span><br><span class="line">                                    <span class="comment">// effect on screen</span></span><br><span class="line">        buffer_handle_t outbufHandle;</span><br><span class="line">        sp&lt;Fence&gt; outbufAcquireFence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// protected by mEventControlLock</span></span><br><span class="line">        int32_t events;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中DisplayData的hwc_display_contents_1用来存放即将要显示到设备的layer，这个结构的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//这个结构描述的是输出到显示设备的内容</span></span><br><span class="line">typedef struct hwc_display_contents_1 &#123;</span><br><span class="line">    ...</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    size_t numHwLayers;<span class="comment">//指定了layer的个数</span></span><br><span class="line">    hwc_layer_1_t hwLayers[<span class="number">0</span>];<span class="comment">//将要合成显示在设备中的layer，它是用hwc_layer_1_t描述的</span></span><br><span class="line"></span><br><span class="line">&#125; hwc_display_contents_1_t;</span><br></pre></td></tr></table></figure><p>hwc_display_contents_1内部指定了要显示的layer的个数，这些layer是通过hwc_layer_1_t数组进行描述的。我们要创建的workList就是为hwc_display_contents_1以及其内部的hwc_layer_1_t数组分配内存用来存放即将要显示的layer信息。在createWorkList中，如果设备版本为HWC_DEVICE_API_VERSION_1_1，说明支持frameBufferTarget，需要额外的创建多一个hwc_layer_1_t，这个hwc_layer_1_t用来存放的是GLES合成后的layer的信息，它的合成类型被指定为HWC_FRAMEBUFFER_TARGET，在DisplayData中是以framebufferTarget描述的。它实际上是hwc_display_contents_1的hwLayers成员的最后一个hwc_layer_1_t。也就是说hwLayers包含了要合成的layer及合成后的layer的信息。</p><h6 id="为layer设置帧数据"><a class="markdownIt-Anchor" href="#为layer设置帧数据"></a> 为layer设置帧数据</h6><p>为显示设备创建完workList，这时候它只是有了容纳layer的结构体，我们还要告知它每个layer的帧数据，这样显示设备才知道layer如何获取这些数据并进行合成显示。这个是通过Layer的setPerFrameData处理的，还记得之前我们通过Layer的latchBuffer获取了layer最新的帧数据，它被放在mActiveBuffer中，这时候我们就可以将这个最新的帧数据的handle设置到显示设备的layer中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为Layer设置当前帧数据</span></span><br><span class="line"><span class="keyword">void</span> Layer::setPerFrameData(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        HWComposer::HWCLayerInterface&amp; layer) &#123;</span><br><span class="line">    <span class="comment">// we have to set the visible region on every frame because</span></span><br><span class="line">    <span class="comment">// we currently free it during onLayerDisplayed(), which is called</span></span><br><span class="line">    <span class="comment">// after HWComposer::commit() -- every frame.</span></span><br><span class="line">    <span class="comment">// Apply this display's projection's viewport to the visible region</span></span><br><span class="line">    <span class="comment">// before giving it to the HWC HAL.</span></span><br><span class="line">    <span class="keyword">const</span> Transform&amp; tr = hw-&gt;getTransform();</span><br><span class="line">    Region visible = tr.transform(visibleRegion.intersect(hw-&gt;getViewport()));</span><br><span class="line">    layer.setVisibleRegionScreen(visible);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> buffer can be NULL if the client never drew into this</span></span><br><span class="line">    <span class="comment">// layer yet, or if we ran out of memory</span></span><br><span class="line">    <span class="comment">//将当前Layer的buffer通过接口HWCLayerInterface保存起来，具体见HWCLayerVersion1</span></span><br><span class="line">    layer.setBuffer(mActiveBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HWCLayerVersion1实现</span></span><br><span class="line"><span class="comment">//将GraphicBuffer保存在对应的hwc_layer_1_t中</span></span><br><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">setBuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="number">0</span> || buffer-&gt;handle == <span class="number">0</span>) &#123;</span><br><span class="line">        getLayer()-&gt;compositionType = HWC_FRAMEBUFFER;</span><br><span class="line">        getLayer()-&gt;flags |= HWC_SKIP_LAYER;</span><br><span class="line">        getLayer()-&gt;handle = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getLayer()-&gt;handle = buffer-&gt;handle;<span class="comment">//指定buffer的handle即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="确定layer的合成方式"><a class="markdownIt-Anchor" href="#确定layer的合成方式"></a> 确定layer的合成方式</h6><p>setUpHWComposer的最后一步是通过HWComposer的prepare确定显示设备layer的合成方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">status_t HWComposer::prepare() &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        DisplayData&amp; disp(mDisplayData[i]);<span class="comment">//取到设备的DisplayData</span></span><br><span class="line">        <span class="keyword">if</span> (disp.framebufferTarget) &#123;<span class="comment">//它有待合成的hwc_layer_1_t</span></span><br><span class="line">            <span class="comment">// make sure to reset the type to HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            <span class="comment">// DO NOT reset the handle field to NULL, because it's possible</span></span><br><span class="line">            <span class="comment">// that we have nothing to redraw (eg: eglSwapBuffers() not called)</span></span><br><span class="line">            <span class="comment">// in which case, we should continue to use the same buffer.</span></span><br><span class="line">            LOG_FATAL_IF(disp.list == NULL);</span><br><span class="line">            <span class="comment">//确保framebufferTarget的合成类型为HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!disp.connected &amp;&amp; disp.list != NULL) &#123;</span><br><span class="line">            ALOGW(<span class="string">"WARNING: disp %d: connected, non-null list, layers=%d"</span>,</span><br><span class="line">                  i, disp.list-&gt;numHwLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLists[i] = disp.list;<span class="comment">//取到DispalayData的list存放在mLists中一份，它是一个hwc_display_contents_1数组</span></span><br><span class="line">        <span class="keyword">if</span> (mLists[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;</span><br><span class="line">                mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">                mLists[i]-&gt;outbufAcquireFenceFd = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">                <span class="comment">// garbage data to catch improper use</span></span><br><span class="line">                mLists[i]-&gt;dpy = (hwc_display_t)<span class="number">0xDEADBEEF</span>;</span><br><span class="line">                mLists[i]-&gt;sur = (hwc_surface_t)<span class="number">0xDEADBEEF</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLists[i]-&gt;dpy = EGL_NO_DISPLAY;</span><br><span class="line">                mLists[i]-&gt;sur = EGL_NO_SURFACE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//为显示设备准备好缓冲区，由硬件合成模块决定哪些layer可以通过硬件合成，并为其打上HWC_OVERLAY标记，</span></span><br><span class="line"><span class="comment">//默认的合成类型为HWC_FRAMEBUFFER</span></span><br><span class="line">    <span class="keyword">int</span> err = mHwc-&gt;prepare(mHwc, mNumDisplays, mLists);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"HWComposer: prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// here we're just making sure that "skip" layers are set</span></span><br><span class="line">        <span class="comment">// to HWC_FRAMEBUFFER and we're also counting how many layers</span></span><br><span class="line">        <span class="comment">// we have of each type.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If there are no window layers, we treat the display has having FB</span></span><br><span class="line">        <span class="comment">// composition, because SurfaceFlinger will use GLES to draw the</span></span><br><span class="line">        <span class="comment">// wormhole region.</span></span><br><span class="line">        <span class="comment">//对于每个显示设备</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="comment">//取到设备DisplayData</span></span><br><span class="line">            DisplayData&amp; disp(mDisplayData[i]);</span><br><span class="line">            disp.hasFbComp = <span class="keyword">false</span>;</span><br><span class="line">            disp.hasOvComp = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//取到hwc_display_contents_1</span></span><br><span class="line">            <span class="keyword">if</span> (disp.list) &#123;</span><br><span class="line">            <span class="comment">//对于显示设备的每一个hwc_layer_1_t都判断其合成类型</span></span><br><span class="line">                <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;disp.list-&gt;numHwLayers ; i++) &#123;</span><br><span class="line">                    hwc_layer_1_t&amp; l = disp.list-&gt;hwLayers[i];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ALOGD("prepare: %d, type=%d, handle=%p",</span></span><br><span class="line">                    <span class="comment">//        i, l.compositionType, l.handle);</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (l.flags &amp; HWC_SKIP_LAYER) &#123;<span class="comment">//需要跳过的layer使用OPENGL合成</span></span><br><span class="line">                        l.compositionType = HWC_FRAMEBUFFER;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l.compositionType == HWC_FRAMEBUFFER) &#123;<span class="comment">//合成类型为HWC_FRAMEBUFFER，则是OPENGL合成</span></span><br><span class="line">                        disp.hasFbComp = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l.compositionType == HWC_OVERLAY) &#123;<span class="comment">//如果合成类型为HWC_OVERLAY则为硬件合成</span></span><br><span class="line">                        disp.hasOvComp = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (disp.list-&gt;numHwLayers == (disp.framebufferTarget ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    disp.hasFbComp = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disp.hasFbComp = <span class="keyword">true</span>;<span class="comment">//如果没有硬件合成使用OPENGL合成</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (status_t)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepare将所有显示设备的hwc_display_contents_1防止在mLists数组中，然后通过hwc硬件的prepare方法决定每个显示设备的layer是否支持硬件合成，如果是就将其compositionType标记为HWC_OVERLAY，默认情况下compositionType是HWC_FRAMEBUFFER表示通过GLES合成。最后通过处理结果来更新DisplayData的hasFbComp和hasOvComp，它们分别表示是否有GLES合成和硬件合成的layer。</p><h5 id="docomposition"><a class="markdownIt-Anchor" href="#docomposition"></a> doComposition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doComposition() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">const</span> bool repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="comment">//同样针对每一个显示设备进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (size_t dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;canDraw()) &#123;</span><br><span class="line">            <span class="comment">// transform the dirty region into this screen's coordinate space</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Region <span class="title">dirtyRegion</span><span class="params">(hw-&gt;getDirtyRegion(repaintEverything)</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">            <span class="comment">//处理需要进行软件合成的部分，也有可能没有需要软件合成的Layer。</span></span><br><span class="line">            doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">            hw-&gt;dirtyRegion.clear();</span><br><span class="line">            hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">            hw-&gt;swapRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// inform the h/w that we're done compositing</span></span><br><span class="line">        hw-&gt;compositionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把不管是普通Layer的数据还是通过EGL合成后的数据都发送到硬件合成模块进行合成</span></span><br><span class="line">    postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doCompositiont负责处理那些需要进行GLES合成的layer。最后通过postFramebuffer提交给硬件合成模块进行合成显示。GLES合成layer是通过doDisplayComposition处理的，我们先看它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        <span class="keyword">const</span> Region&amp; inDirtyRegion)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the invalid region</span></span><br><span class="line">    hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line">    uint32_t flags = hw-&gt;getFlags();</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">        <span class="comment">// we can redraw only what's dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">        <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">        <span class="comment">// rectangle in that case</span></span><br><span class="line">        dirtyRegion.set(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;</span><br><span class="line">            <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">            <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">            <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">            <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">            dirtyRegion.set(hw-&gt;swapRegion.bounds());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">            dirtyRegion.set(hw-&gt;bounds());</span><br><span class="line">            hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(!mDaltonize)) &#123;</span><br><span class="line">    <span class="comment">//关键点1 合成layer</span></span><br><span class="line">        doComposeSurfaces(hw, dirtyRegion);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RenderEngine&amp; engine(getRenderEngine());</span><br><span class="line">        engine.beginGroup(mDaltonizer());</span><br><span class="line">        doComposeSurfaces(hw, dirtyRegion);</span><br><span class="line">        engine.endGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">    hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap buffers (presentation)</span></span><br><span class="line">    <span class="comment">//关键点2 将合成的纹理渲染在EGL本地窗口中，这会触发本地窗口对应的BufferQueue，通知它的消费端FrameBufferSurface进行消费</span></span><br><span class="line">    hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDisplayComposition又通过doComposeSurfaces合成显示设备的layer，之前我们为设备创建了workList，知道合成的layer最终会被保存在frameBufferTarget对应的hwc_layer_1_t中，那么这到底是怎么样实现呢？我们接着看doComposeSurfaces的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doComposeSurfaces(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="keyword">const</span> Region&amp; dirty)</span><br><span class="line">&#123;</span><br><span class="line">    RenderEngine&amp; engine(getRenderEngine());</span><br><span class="line">    <span class="keyword">const</span> int32_t id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    HWComposer&amp; hwc(getHwComposer());</span><br><span class="line">    </span><br><span class="line">    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line"><span class="comment">//判断是否需要进行GLES合成，如果设备的layer集合中有需要GLES合成的layer则返回true</span></span><br><span class="line">    bool hasGlesComposition = hwc.hasGlesComposition(id);</span><br><span class="line">    <span class="keyword">if</span> (hasGlesComposition) &#123;<span class="comment">//通过GLES进行合成</span></span><br><span class="line">    <span class="comment">//设置EGL的display和Context ，这里为EGL设置本地窗口对象，合成的纹理渲染在该窗口中</span></span><br><span class="line">        <span class="keyword">if</span> (!hw-&gt;makeCurrent(mEGLDisplay, mEGLContext)) &#123;</span><br><span class="line">            ALOGW(<span class="string">"DisplayDevice::makeCurrent failed. Aborting surface composition for display %s"</span>,</span><br><span class="line">                  hw-&gt;getDisplayName().string());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * and then, render the layers targeted at the framebuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//获取到显示设备的可见layer集合</span></span><br><span class="line">    <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; layers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">    <span class="keyword">const</span> size_t count = layers.size();</span><br><span class="line">    <span class="keyword">const</span> Transform&amp; tr = hw-&gt;getTransform();</span><br><span class="line">    <span class="keyword">if</span> (cur != end) &#123;</span><br><span class="line">        <span class="comment">// we're using h/w composer</span></span><br><span class="line">        <span class="comment">//遍历处理这些layer</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">            <span class="comment">//layer的设置裁剪区域</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Region <span class="title">clip</span><span class="params">(dirty.intersect(tr.transform(layer-&gt;visibleRegion)</span>))</span>;</span><br><span class="line">            <span class="keyword">if</span> (!clip.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (cur-&gt;getCompositionType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> HWC_OVERLAY: &#123;<span class="comment">//如果当前layer是通过硬件进行合成，则不需要进行任何处理，合成工作交给硬件处理</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前layer需要软件进行合成，调用draw方法通过EGL合成为纹理</span></span><br><span class="line">                    <span class="comment">//需要注意的是对于需要GLES进行合成的Layer，其都会绘制在同一个纹理上，这个纹理的Buffer会在后面的通过swapBuffer提交给设备的frameBufferTarget</span></span><br><span class="line">                    <span class="keyword">case</span> HWC_FRAMEBUFFER: &#123;</span><br><span class="line">                        layer-&gt;draw(hw, clip);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;setAcquireFence(hw, *cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在doComposeSurfaces方法中，我们首先通过DisplayDevice的makeCurrent方法配置EGL display和context,要合成的对象最终被渲染到DisplayDevice的本地窗口中，后面我们对此进行分析，随后取到设备的可见layer集合，然后通过循环遍历这个集合，在循环中我们只需要关心通过GLES合成部分的layer，这些layer的合成会调用draw方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Layer进行软件合成</span></span><br><span class="line"><span class="keyword">void</span> Layer::draw(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="keyword">const</span> Region&amp; clip) <span class="keyword">const</span> &#123;</span><br><span class="line">    onDraw(hw, clip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Layer::draw(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw) &#123;</span><br><span class="line">    onDraw( hw, Region(hw-&gt;bounds()) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Layer::onDraw(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="keyword">const</span> Region&amp; clip) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">// Bind the current buffer to the GL texture, and wait for it to be</span></span><br><span class="line">    <span class="comment">// ready for us to draw into.</span></span><br><span class="line">    <span class="comment">//绑定当前Buffer到GL纹理，等待渲染</span></span><br><span class="line">    status_t err = mSurfaceFlingerConsumer-&gt;bindTextureImage();</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGW(<span class="string">"onDraw: bindTextureImage failed (err=%d)"</span>, err);</span><br><span class="line">        <span class="comment">// Go ahead and draw the buffer anyway; no matter what we do the screen</span></span><br><span class="line">        <span class="comment">// is probably going to have something visibly wrong.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool blackOutLayer = isProtected() || (isSecure() &amp;&amp; !hw-&gt;isSecure());</span><br><span class="line"></span><br><span class="line">    RenderEngine&amp; engine(mFlinger-&gt;getRenderEngine());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blackOutLayer) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> we could be more subtle with isFixedSize()</span></span><br><span class="line">        <span class="keyword">const</span> bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize();</span><br><span class="line">        <span class="comment">// Query the texture matrix given our current filtering mode.</span></span><br><span class="line">        <span class="keyword">float</span> textureMatrix[<span class="number">16</span>];</span><br><span class="line">        mSurfaceFlingerConsumer-&gt;setFilteringEnabled(useFiltering);</span><br><span class="line">        mSurfaceFlingerConsumer-&gt;getTransformMatrix(textureMatrix);</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">// Set things up for texturing.</span></span><br><span class="line">        mTexture.setDimensions(mActiveBuffer-&gt;getWidth(), mActiveBuffer-&gt;getHeight());</span><br><span class="line">        mTexture.setFiltering(useFiltering);</span><br><span class="line">        mTexture.setMatrix(textureMatrix);</span><br><span class="line"><span class="comment">//为渲染引擎设置图层纹理</span></span><br><span class="line">        engine.setupLayerTexturing(mTexture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        engine.setupLayerBlackedOut();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过OPENGL渲染纹理，这里面会计算layer的绘制区域和纹理坐标等</span></span><br><span class="line">    drawWithOpenGL(hw, clip);</span><br><span class="line">    engine.disableTexturing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layer通过draw合成渲染之前，我们通过DisplayDevice的makeCurrent已经配置好了EGL，在onDraw方法中先通过bindTextureImage将当前layer的buffer绑定到GL纹理，这个是通过GLConsumer的bindTextureImageLocked实现的，因为<br>这里的mSurfaceFlingerConsumer它是个SurfaceFlingerConsumer，继承自GLConusmer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">status_t GLConsumer::bindTextureImageLocked() &#123;</span><br><span class="line">    ...</span><br><span class="line">    glBindTexture(mTexTarget, mTexName);<span class="comment">//绑定渲染的纹理</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EGLImageKHR image = mEglSlots[mCurrentTexture].mEglImage;</span><br><span class="line"></span><br><span class="line">        glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((error = glGetError()) != GL_NO_ERROR) &#123;</span><br><span class="line">            ST_LOGE(<span class="string">"bindTextureImage: error binding external texture image %p"</span></span><br><span class="line">                    <span class="string">": %#04x"</span>, image, error);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the new buffer to be ready.</span></span><br><span class="line">    <span class="keyword">return</span> doGLFenceWaitLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在bindTextureImaageLocked中glBindTexture绑定渲染的纹理，其中mTexName为纹理ID，这个纹理ID在Layer构造的时候就生成了，渲染的纹理mTexture也是在Layer构造的时候进行初始化的，它是通过SF创建的RenderEngine创建的纹理ID mTextureName,该纹理ID被传递给了Layer的消费者GLConsumer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Layer(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    mBufferQueue = <span class="keyword">new</span> SurfaceTextureLayer(mFlinger);<span class="comment">//创建一个BufferQueue</span></span><br><span class="line">    <span class="comment">//BufferQueue的消费者</span></span><br><span class="line">    mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(mBufferQueue, mTextureName);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SurfaceFlingerConsumer : public GLConsumer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SurfaceFlingerConsumer(<span class="keyword">const</span> sp&lt;BufferQueue&gt;&amp; bq, uint32_t tex)</span><br><span class="line">        : GLConsumer(bq, tex, GLConsumer::TEXTURE_EXTERNAL, <span class="keyword">false</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlingerConsumer的构造中将纹理ID传递给GLConsumer，GLConsumer将其保存在成员mTexName，所以layer通过onDraw渲染的纹理和消费者SurfaceFlingerConsumer使用的是同一个纹理。</p><p>前面我们知道Layer渲染纹理前会通过DisplayDevice通过makeCurrent配置EGL，我们看看DisplayDevice是如何创建为EGL创建本地窗口的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">DisplayDevice::DisplayDevice(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        DisplayType type,</span><br><span class="line">        int32_t hwcId,</span><br><span class="line">        bool isSecure,</span><br><span class="line">        <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; displayToken,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplaySurface&gt;&amp; displaySurface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; producer,</span><br><span class="line">        EGLConfig config)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mType(type), mHwcDisplayId(hwcId),</span><br><span class="line">      mDisplayToken(displayToken),</span><br><span class="line">      mDisplaySurface(displaySurface),<span class="comment">//这个是FrameBufferSurface</span></span><br><span class="line">      mDisplay(EGL_NO_DISPLAY),</span><br><span class="line">      mSurface(EGL_NO_SURFACE),</span><br><span class="line">      mDisplayWidth(), mDisplayHeight(), mFormat(),</span><br><span class="line">      mFlags(),</span><br><span class="line">      mPageFlipCount(),</span><br><span class="line">      mIsSecure(isSecure),</span><br><span class="line">      mSecureLayerVisible(<span class="keyword">false</span>),</span><br><span class="line">      mScreenAcquired(<span class="keyword">false</span>),</span><br><span class="line">      mLayerStack(NO_LAYER_STACK),</span><br><span class="line">      mOrientation()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过BufferQueue创建一个Surface本地窗口，这个Surface是作为生产者的，而FrameBufferSurface作为消费端，</span></span><br><span class="line"><span class="comment">* 它们共享同一个BufferQueue，同时Surface是作为EGL创建WindowSurface的本地窗口，当Layer通过EGL合成纹理后，</span></span><br><span class="line"><span class="comment">* eglSwapBuffers方法会通过其ANativeWindow的QueueBuffer方法将绘制好的纹理缓冲区入队列，并通过</span></span><br><span class="line"><span class="comment">* FrameBufferSurface的OnFrameAvaliable回调通知给消费端，消费端将取出该GraphicBuffer并将通过HWC的fbPost</span></span><br><span class="line"><span class="comment">* 将其设置到显示设备的DisplayData的FramebufferTarget，随后通过HWC的commit将其提交给显示设备。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    mNativeWindow = <span class="keyword">new</span> Surface(producer, <span class="keyword">false</span>);</span><br><span class="line">    ANativeWindow* <span class="keyword">const</span> window = mNativeWindow.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line">    window-&gt;query(window, NATIVE_WINDOW_FORMAT, &amp;format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that composition can never be stalled by a virtual display</span></span><br><span class="line">    <span class="comment">// consumer that isn't processing buffers fast enough. We have to do this</span></span><br><span class="line">    <span class="comment">// in two places:</span></span><br><span class="line">    <span class="comment">// * Here, in case the display is composed entirely by HWC.</span></span><br><span class="line">    <span class="comment">// * In makeCurrent(), using eglSwapInterval. Some EGL drivers set the</span></span><br><span class="line">    <span class="comment">//   window's swap interval in eglMakeCurrent, so they'll override the</span></span><br><span class="line">    <span class="comment">//   interval we set here.</span></span><br><span class="line">    <span class="keyword">if</span> (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL)</span><br><span class="line">        window-&gt;setSwapInterval(window, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create our display's surface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    EGLSurface surface;</span><br><span class="line">    EGLint w, h;</span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line"> <span class="comment">//通过Surface的ANativeWindow创建EGLSurface对象，EGL合成后的纹理数据被存放在Surface的BufferQueue中</span></span><br><span class="line">    surface = eglCreateWindowSurface(display, config, window, NULL);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH,  &amp;mDisplayWidth);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mDisplayHeight);</span><br><span class="line"></span><br><span class="line">    mDisplay = display;<span class="comment">//将创建的EGLDisplay保存</span></span><br><span class="line">    mSurface = surface;<span class="comment">//将创建的EGLSurface保存</span></span><br><span class="line">    mFormat  = format;</span><br><span class="line">    mPageFlipCount = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SF初始化显示设备的时候会为其创建DisplayDevice对象，这个对象内部会创建EGL本地窗口EGLSurface mSurface，它内部使用的BufferQueue和其参数mDisplaySurface指定的FrameBufferSurface使用同一个BufferQueue，这里又是一个生产-消费模型，本地窗口Surface负责成产数据，而FrameBufferSurface负责对数据进行消费。具体来说就是layer渲染的纹理数据最终是交给EGL本地窗口了，而本地窗口和FrameBufferSurface使用同一个BufferQueue,FrameBufferSurface作为BufferQueue的消费端最终会接收来自于DisplayDevice本地窗口的Buffer数据，这个是通过DisplayDevice的swapBuffer触发的，swapBuffer会使本地窗口的Buffer数据通过BufferQueue的queueBuffer入队，这样就能触发FrameBufferSurface的onFrameAvaliable回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp</span></span><br><span class="line"><span class="comment">//EGL合成好的Buffer最终会通过该回调通知FramebufferSurface</span></span><br><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameAvailable() &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    status_t err = nextBuffer(buf, acquireFence);<span class="comment">//取到合成好的纹理Buffer</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error latching nnext FramebufferSurface buffer: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将纹理Buffer通过HWC设置到显示设备的缓冲区中，准确来说是放在DisplayData的FramebufferTarget中</span></span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error posting framebuffer: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过EGL合成好的数据最终会通过FramebufferSurface的onFrameAvaliable回调消费，这里先通过nexBuffer取到合成好的GraphicBuffer的数据，然后通过HWComposer的fbPost方法将取到的GraphicBuffer保存到设备的framebufferTarget中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">status_t FramebufferSurface::nextBuffer(sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    BufferQueue::BufferItem item;</span><br><span class="line">    status_t err = acquireBufferLocked(&amp;item, <span class="number">0</span>);<span class="comment">//获取BufferItem</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//根据获取的BufferItem取到对应的GrapicBuffer</span></span><br><span class="line">    mCurrentBufferSlot = item.mBuf;</span><br><span class="line">    <span class="comment">//去对应槽内的Buffer</span></span><br><span class="line">    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;</span><br><span class="line">    outFence = item.mFence;</span><br><span class="line">    outBuffer = mCurrentBuffer;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextBuffer通过acquireBufferLocked取到BufferItem，然后从item中取到对应的槽索引mCurrentBufferSlot,最后根据该索引取到对应的GraphicBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将合成好的Buffer保存在DisplayData 的frameBufferTarget成员中</span></span><br><span class="line"><span class="keyword">int</span> HWComposer::fbPost(int32_t id,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer) &#123;</span><br><span class="line">    <span class="comment">//硬件合成模块的API版本要是1.1才支持framebufferTarget    </span></span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setFramebufferTarget(id, acquireFence, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acquireFence-&gt;waitForever(<span class="string">"HWComposer::fbPost"</span>);</span><br><span class="line">        <span class="keyword">return</span> mFbDev-&gt;post(mFbDev, buffer-&gt;handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将EGL合成好的纹理buffer设置到显示设备DispData的framebufferTarget中</span></span><br><span class="line">status_t HWComposer::setFramebufferTarget(int32_t id,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buf) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uint32_t(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要设置的显示设备的DisplayData</span></span><br><span class="line">    DisplayData&amp; disp(mDisplayData[id]);</span><br><span class="line">    <span class="keyword">if</span> (!disp.framebufferTarget) &#123;</span><br><span class="line">        <span class="comment">// this should never happen, but apparently eglCreateWindowSurface()</span></span><br><span class="line">        <span class="comment">// triggers a Surface::queueBuffer()  on some</span></span><br><span class="line">        <span class="comment">// devices (!?) -- log and ignore.</span></span><br><span class="line">        ALOGE(<span class="string">"HWComposer: framebufferTarget is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> acquireFenceFd = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (acquireFence-&gt;isValid()) &#123;</span><br><span class="line">        acquireFenceFd = acquireFence-&gt;dup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGD("fbPost: handle=%p, fence=%d", buf-&gt;handle, acquireFenceFd);</span></span><br><span class="line">    <span class="comment">//设置taget handle为buffer的handle</span></span><br><span class="line">    disp.fbTargetHandle = buf-&gt;handle;</span><br><span class="line">    disp.framebufferTarget-&gt;handle = disp.fbTargetHandle;</span><br><span class="line">    <span class="comment">//设置fence</span></span><br><span class="line">    disp.framebufferTarget-&gt;acquireFenceFd = acquireFenceFd;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fbPost将取到的GraphicBuffer通过setFramebufferTarget保存到相应设备的framebufferTarget中，这样就完成设备layer GLES合成的内容。</p><h5 id="postframebuffer"><a class="markdownIt-Anchor" href="#postframebuffer"></a> postFramebuffer</h5><p>在doComposition的最后一步是将设备的合成好的layer和需要硬件合成的layer一起提交给硬件合成模块，让其进行最终的显示。<br>这个是通过postFramebuffer完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知硬件合成模块进行合成</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    HWComposer&amp; hwc(getHwComposer());</span><br><span class="line">    <span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">            <span class="comment">// EGL spec says:</span></span><br><span class="line">            <span class="comment">//   "surface must be bound to the calling thread's current context,</span></span><br><span class="line">            <span class="comment">//    for the current rendering API."</span></span><br><span class="line">            getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交给硬件合成显示</span></span><br><span class="line">        hwc.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将layer数据提交给硬件合成模块</span></span><br><span class="line">status_t HWComposer::commit() &#123;</span><br><span class="line">    <span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line"><span class="comment">//将mLists提交给硬件合成，注意mLists是一个hwc_display_contents_1指针数组，它存放了显示设备最终要显示的图层数据。</span></span><br><span class="line">        err = mHwc-&gt;set(mHwc, mNumDisplays, mLists);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (status_t)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过HWComposer的commit方法，将设备数和hwc_display_contents_1指针数据一起传递给硬件的合成模块，hwc_display_contents_1包含了通过GLES合成的layer，它的信息保存hwLayers的最后一个hwc_layer_l_t中，<br>同时hwLayers还可能有需要进行硬件合成的layer。不管怎么样，它们都是一起提交给硬件合成模块的，硬件负责对这些layer进行最终的合成渲染。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;本篇将对Android GUI系统SurfaceFlinger（简称SF）合成layer的具体过程进行分析。合成过程是SF最核心的任务，这个过程
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="AOSP" scheme="http://esligh.github.io/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger之绘图缓冲区</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surfaceflinger-buffer-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surfaceflinger-buffer-src/</id>
    <published>2018-06-10T03:18:23.000Z</published>
    <updated>2019-03-17T09:27:45.656Z</updated>
    
    <content type="html"><![CDATA[<p>SurfaceFlinger是GUI系统的核心服务，它主要负责图层的合成任务，同时它为每个应用程序维护一个Client，Client又是由多个Layer组成，Layer对应应用端的Window，这样SurfaceFlinger就能通过Layer来明白各个应用的绘图需求，从而将其合成显示。本篇将从SurfaceFlinger的角度来分析系统是如何通过Layer来管理绘图缓冲区。</p><h3 id="缓冲队列"><a class="markdownIt-Anchor" href="#缓冲队列"></a> 缓冲队列</h3><p>绘图缓冲区是通过BufferQueeu进行管理的，它是一个缓冲区队列，从生产消费的角度来说它同时为消费者和生产者，这里看看它的结构便可以知道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class BufferQueue : public BnGraphicBufferProducer,</span><br><span class="line">                    <span class="keyword">public</span> BnGraphicBufferConsumer,</span><br><span class="line">                    <span class="keyword">private</span> IBinder::DeathRecipient</span><br></pre></td></tr></table></figure><p>BufferQueue同时是一个Binder,因此它也就具有跨进程的能力。本篇将会根据具体的使用来分析BufferQueue是如何同时作为消费者和生产者的。</p><h3 id="bufferqueue的构成"><a class="markdownIt-Anchor" href="#bufferqueue的构成"></a> BufferQueue的构成</h3><p>BufferQueue内部是一个BufferSlot数组，大小为32，BufferSlot即Buffer槽用来描述一块缓冲区，需要注意的是BufferQueue在初始情况下并未分配缓冲区，只有当用户进行申请时才真正的分配缓冲区。一个缓冲区一旦被分配它便具有了状态,分别是：</p><p>FREE 表明该Buffer空闲，可以dequeue被生产者使用，此时它的拥有者为BufferQueue。</p><p>DEQUEUED 表示该Buffer已经被生产者dequeue，但还未入队或者取消，此时生产者是它的拥有者</p><p>QUEUED 表明这个Buffer已经被生产者填充好内容，等待消费者进行消费，此时它的拥有者为BufferQueue</p><p>ACQUIRED 表示该Buffer块被消费者获取到，此时消费者作为其拥有者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BufferState &#123;</span><br><span class="line">    <span class="comment">// FREE indicates that the buffer is available to be dequeued</span></span><br><span class="line">    <span class="comment">// by the producer.  The buffer may be in use by the consumer for</span></span><br><span class="line">    <span class="comment">// a finite time, so the buffer must not be modified until the</span></span><br><span class="line">    <span class="comment">// associated fence is signaled.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The slot is "owned" by BufferQueue.  It transitions to DEQUEUED</span></span><br><span class="line">    <span class="comment">// when dequeueBuffer is called.</span></span><br><span class="line">    FREE = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DEQUEUED indicates that the buffer has been dequeued by the</span></span><br><span class="line">    <span class="comment">// producer, but has not yet been queued or canceled.  The</span></span><br><span class="line">    <span class="comment">// producer may modify the buffer's contents as soon as the</span></span><br><span class="line">    <span class="comment">// associated ready fence is signaled.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The slot is "owned" by the producer.  It can transition to</span></span><br><span class="line">    <span class="comment">// QUEUED (via queueBuffer) or back to FREE (via cancelBuffer).</span></span><br><span class="line">    DEQUEUED = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QUEUED indicates that the buffer has been filled by the</span></span><br><span class="line">    <span class="comment">// producer and queued for use by the consumer.  The buffer</span></span><br><span class="line">    <span class="comment">// contents may continue to be modified for a finite time, so</span></span><br><span class="line">    <span class="comment">// the contents must not be accessed until the associated fence</span></span><br><span class="line">    <span class="comment">// is signaled.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The slot is "owned" by BufferQueue.  It can transition to</span></span><br><span class="line">    <span class="comment">// ACQUIRED (via acquireBuffer) or to FREE (if another buffer is</span></span><br><span class="line">    <span class="comment">// queued in asynchronous mode).</span></span><br><span class="line">    QUEUED = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ACQUIRED indicates that the buffer has been acquired by the</span></span><br><span class="line">    <span class="comment">// consumer.  As with QUEUED, the contents must not be accessed</span></span><br><span class="line">    <span class="comment">// by the consumer until the fence is signaled.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The slot is "owned" by the consumer.  It transitions to FREE</span></span><br><span class="line">    <span class="comment">// when releaseBuffer is called.</span></span><br><span class="line">    ACQUIRED = <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bufferqueue作为消费者"><a class="markdownIt-Anchor" href="#bufferqueue作为消费者"></a> BufferQueue作为消费者</h3><p>View在第一次进行绘制时会从WMS请求一个Surface绘图表面，这个绘图表面实际上会通过IGrpahicBufferProducer来请求绘图缓冲区，它实际上是一个IBinder Client，它的服务端即BufferQueue是在为WMS对应的Window对象创建SF端的Layer对象时创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    mBufferQueue = <span class="keyword">new</span> SurfaceTextureLayer(mFlinger);</span><br><span class="line">    mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(mBufferQueue, mTextureName);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setFrameAvailableListener(<span class="keyword">this</span>);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</span><br><span class="line">#warning "disabling triple buffering"</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">2</span>);</span><br><span class="line">#else</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">3</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的SurfaceTextureLayer是BufferQueue的子类，它在Layer对象被创建后第一次引用时创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">status_t SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// initialize the surfaces</span></span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">        format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">#else</span><br><span class="line">        format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">#endif</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef NO_RGBX_8888</span><br><span class="line">    <span class="keyword">if</span> (format == PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    *outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line">    status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp = (*outLayer)-&gt;getBufferQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Layer被创建后，通过getBufferQueue得到该缓冲队列，这个队列是以一个Binder代理返回给应用端的，应用端最终是通过该BufferQueue来请求缓冲区，从而通过该缓冲区构造SkCanvas最终提交给上层使用的。从这个角度来讲BufferQueue是作为生产者的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SurfaceFlinger是GUI系统的核心服务，它主要负责图层的合成任务，同时它为每个应用程序维护一个Client，Client又是由多个Layer组成，Layer对应应用端的Window，这样SurfaceFlinger就能通过Layer来明白各个应用的绘图需求，从而
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="AOSP" scheme="http://esligh.github.io/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>Vsync信号图形绘制-Choreographer源码分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-choreographer/"/>
    <id>http://esligh.github.io/[object Object]/aosp-choreographer/</id>
    <published>2018-06-07T07:32:56.000Z</published>
    <updated>2019-03-16T08:03:42.245Z</updated>
    
    <content type="html"><![CDATA[<p>Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。</p><p>Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vsync信号。垂直信号到来后就要开始准备绘制下一帧的数据。Choreographer主要是在ViewRootImpl中使用的，ViewRootImpl是view树的管理者，负责view树的逻辑处理及事件事件输入。</p><p>所有的绘制流程是从ViewRootImpl.java的scheduleTraversals开始的，这个方法会去请求vsync信号，并在信号到来时去绘制更新ui。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//请求vsync信号，当vsync信号到达后开始mTraversalRunnable任务,垂直信号的接受由ChoreoGrpaher负责</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们不关心具体的绘制过程，主要是看Choreographer如何通过vysnc信号来协调界面的绘制。<br>这里首先是通过Choreographer对象mChoreographer对象post了一个回调，告诉Choreographer当vsync信号到达时帮我调用mTraversalRunable回调。这个回调的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();<span class="comment">//vsync信号到达后执行绘制流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure><p>doTraversal()内部会调用performTraversals()方法，从而开启view绘制的三大流程。</p><p>下面我们看看Choreographer是如何将vsync接受信号并告之ViewRoomImpl的刷新回调的。我们就从这个postCallback入手分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">        postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//post一个延时回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将请求的回调按照相应的类型添加到回调队列中，这里会根据一个失效时间来构造</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;<span class="comment">//延时为0时调用 ，对于scheduleTraversals走这里</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postCallback最终会调用postCallbackDelayedInternal，参数delayMillis为0，所以会调用scheduleFrameLocked进一步进行操作。这里需要注意的是每次请求都会添加到其类型对应的回调队列中， 这里的mCallbackQueues是一个根据类型区分的回调队列，有四种类型，分别是输入回调，动画回调和绘制回调以及Choreographer.CALLBACK_COMMIT。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;<span class="comment">//使用vsync信号更新</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">            <span class="comment">// as soon as possible.</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//通过ui线程发送请求等待一个vsync信号 </span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">这个USE_VSYNC代表我们系统使用vsync信号进行屏幕信号的同步，这个方法是在我们的ui线程操作的，所以会发送MSG_DO_SCHEDULE_VSYNC请求vsync信号。这里的mHandler是一个FrameHandler</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();<span class="comment">//请求vsync信号</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用doScheduleVsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();<span class="comment">//请求vsync信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mDisplayEventReceiver是一个FrameDisplayEventReceiver对象，它继承了DisplayEventReceiver，其中实现了其方法onVsync，这个方法就是当onVsync信号到达时的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//垂直信号到达</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore vsync from secondary display.</span></span><br><span class="line">    <span class="comment">// This can be problematic because the call to scheduleVsync() is a one-shot.</span></span><br><span class="line">    <span class="comment">// We need to ensure that we will still receive the vsync from the primary</span></span><br><span class="line">    <span class="comment">// display which is the one we really care about.  Ideally we should schedule</span></span><br><span class="line">    <span class="comment">// vsync for a particular display.</span></span><br><span class="line">    <span class="comment">// At this time Surface Flinger won't send us vsyncs for secondary displays</span></span><br><span class="line">    <span class="comment">// but that could change in the future so let's log a message to help us remember</span></span><br><span class="line">    <span class="comment">// that we need to fix this.</span></span><br><span class="line">    <span class="comment">//并不是sf内置的display</span></span><br><span class="line">    <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Received vsync from secondary display, but we don't support "</span></span><br><span class="line">                + <span class="string">"this case yet.  Choreographer needs a way to explicitly request "</span></span><br><span class="line">                + <span class="string">"vsync for a specific display to ensure it doesn't lose track "</span></span><br><span class="line">                + <span class="string">"of its scheduled vsync."</span>);</span><br><span class="line">        scheduleVsync();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></span><br><span class="line">                + <span class="string">"timestamps using the correct timebase."</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);<span class="comment">//垂直信号到来触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直信号vsync到来后会触发doFrame，在这个方法里面会进行我们的回调，即mTraversalRunnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    …… </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);<span class="comment">//回调输入事件的相关回调</span></span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);<span class="comment">//回调动画相关的回调</span></span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);<span class="comment">//回调绘制相关的回调</span></span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);<span class="comment">//获取相关类型的回调</span></span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"RunCallback: type="</span> + callbackType</span><br><span class="line">                        + <span class="string">", action="</span> + c.action + <span class="string">", token="</span> + c.token</span><br><span class="line">                        + <span class="string">", latencyMillis="</span> + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">            &#125;</span><br><span class="line">            c.run(frameTimeNanos);<span class="comment">//调用回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据类型从队列中取出相应的回调进行调用。这个就是上层对于vsync的处理。接下来我们看看底层的vsync信号是如何传递给Choreographer的。这就需要看看FrameDisplayEventReceiver的父类DisplayEventReceiver，这个DisplayEventReceiver会通过native层进行初始化，native层通过它的成员方法dispatchVsync将vsync信号报告给上层，即调用onVsync。我们先看其构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="keyword">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);<span class="comment">//初始化接收器</span></span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其构造方法是调用nativeInit进行初始化的，并将当前对象this作为一个接收器传递给底层。我们看看这个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span><br><span class="line"><span class="comment">//注册显示事件接收器 receiverWeak即DisplayEventReceiver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个messageQueue是通过ui线程的Looper构造的</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);<span class="comment">//创建本地接收器</span></span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();<span class="comment">//初始化native的接受器</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to initialize display event receiver.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化方法中会创建本地的接受器对象，它同时是用我们传递的java层的接受器对象构造的，构造完成后即进行初始化。这个NativeDisplayEventReceiver的定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native的显示事件接受器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeDisplayEventReceiver</span> :</span> <span class="keyword">public</span> DisplayEventDispatcher &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">            jobject receiverWeak, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NativeDisplayEventReceiver();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jobject mReceiverWeakGlobal;<span class="comment">//java层的接收器对象</span></span><br><span class="line">    sp&lt;MessageQueue&gt; mMessageQueue;</span><br><span class="line">    DisplayEventReceiver mReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dispatchHotplug</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">bool</span> connected)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NativeDisplayEventReceiver继承自DisplayEventDispatcher，而DisplayEventDispatcher又实现了LooperCallback的接口handleEvent，这个方法是Looper的事件回调，也就是当Looper接受到消息后会对其进行调用，那么这个DisplayEventDispatcher就是负责进行消息事件的转发的。后面我们看看它是如何将vsync信号转发的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化receiver</span></span><br><span class="line"><span class="keyword">status_t</span> DisplayEventDispatcher::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);<span class="comment">//添加事件侦听,这里的this代表注册的是一个LooperCallback,</span></span><br><span class="line">                        <span class="comment">//当事件到达后会调用其handleEvent方法,这个可以具体参见Looper的实现</span></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的addFd将其注册到为Looper的事件回调，注意这里第四个参数this，因为DisplayEventDispatcher是继承LooperCallback的。这样当事件到来后会调用handleEvent。</p><p>还有，在NativeDisplayEventReceiver的内部持有一个DisplayEventReceiver对象，这个对象比较重要，它是负责和Sf打交道的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//通过sf建立连接，这里就应该很熟悉了，这个连接创建好后在第一次引用时会去注册到EventThread中</span></span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = <span class="built_in">std</span>::make_unique&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;stealReceiveChannel(mDataChannel.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection(</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vsyncSource == eVsyncSourceSurfaceFlinger) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSFEventThread-&gt;createEventConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果时app端的就走这里</span></span><br><span class="line">        <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚说到DisplayEventReceiver是和Sf打交道的， 它和NativeDisplayEventReceiver是同时创建的。在其构造方法中首先通过sf的createDisplayEventConnection创建一个连接对象即Connection对象，mEventThread是管理绘图延时对象的vsync信号处理，它是一个EventThread。Connection就是由它创建的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));<span class="comment">//创建一个新的连接，这个连接在第一个被引用时会去进行注册</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个connection在第一次被引用时会进行注册，即将其添加到mEventThread的连接队列，在vsync消息到来时调用其postEvent方法对事件进行转发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册创建的连接，实际上时将创建的连接添加到监听队列，并通知等待的线程</span></span><br><span class="line"><span class="keyword">status_t</span> EventThread::registerDisplayEventConnection(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mDisplayEventConnections.add(connection);<span class="comment">//添加到连接队列中</span></span><br><span class="line">    mCondition.broadcast();<span class="comment">//唤醒等待的线程</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);<span class="comment">//post事件</span></span><br><span class="line">……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(</span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postEvent实际上会调用DisplayEventReceiver的setEvents方法，这样会触发getEvents的回调从而通过DisplayEventDispatcher的handleEvent回调方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel,</span><br><span class="line">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);<span class="comment">//发送接受到的事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DisplayEventDispatcher::handleEvent(<span class="keyword">int</span>, <span class="keyword">int</span> events, <span class="keyword">void</span>*)&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;<span class="comment">//丢弃所有的等待事件，只保留上次的vsync信号事件</span></span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Vsync pulse: timestamp=%"</span> PRId64 <span class="string">", id=%d, count=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);<span class="comment">//分派vsync信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DisplayEventDispatcher::processPendingEvents(</span><br><span class="line">        <span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount) &#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;<span class="comment">//等待事件到来</span></span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Read %d events."</span>, <span class="keyword">this</span>, <span class="keyword">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That's fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;<span class="comment">//timestamp</span></span><br><span class="line">                *outId = ev.header.id;<span class="comment">//id</span></span><br><span class="line">                *outCount = ev.vsync.count;<span class="comment">//count</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line"></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.get()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Invoking vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Returned from vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"dispatchVsync"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用NativeDisplayEventReceiver的dispatchVsync回调给java层的dispatchVsync，这样vsync信号就传递给上层应用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。&lt;/p&gt;
&lt;p&gt;Choreographer 即编舞者 负责协调app端的图形绘制，这里主要是等待vs
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GUI系统之SurfaceFlinger之VSYNC信号的产生和处理(二)</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surfaceflinger-vsync-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surfaceflinger-vsync-src/</id>
    <published>2018-06-04T07:32:56.000Z</published>
    <updated>2019-03-17T09:27:22.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="surfaceflinger中vsync信号的控制同步"><a class="markdownIt-Anchor" href="#surfaceflinger中vsync信号的控制同步"></a> SurfaceFlinger中VSYNC信号的控制同步</h4><p>SurfaceFlinger（简称SF）的绘制合成过程是在VSYNC信号(即垂直同步信号)的控制下同步进行的，所以VSYNC信号可以说是SF的指挥官，它的协调同步控制对于界面绘制效率至关重要。本篇将介绍VYSNC信号在SF服务中是如何发挥这个指挥官的角色。</p><h4 id="surfaceflinger中的vsync"><a class="markdownIt-Anchor" href="#surfaceflinger中的vsync"></a> SurfaceFlinger中的VSYNC</h4><p>SufaceFlinger的初始化是在init方法中进行的，这个方法中关于VYSNC信号有两个DispSyncSource，分别为App绘制延时源和SF合成延时源，这两个信号源基于同一个VSYNC信号模型mPrimaryDispSync，它是一个DispSync对象，DispSync是对硬件Hwc垂直信号的同步模型，那么为什么在有硬件VSYNC信号的情况下还需要一个这样的同步模型呢？实际上，这个是Android系统的一种优化策略，因为在VYSNC信号到来后，App绘制和SF合成过程如果此时同时进行，可能会竞争CPU，从而会影响绘制效率，为了避免竞争引入了VYSNC同步模型DispSync，该模型会根据需要打开硬件的VYSNC信号进行采样，然后同步VSYNC信号模型，从而为上层的绘制延时源和合成延时源提供VYSNC信号，基于该同步模型，绘制延时源和合成延时源可以分别在此基础上添加一个相位偏移量(vsyncPhaseOffsetNs和sfVsyncPhaseOffsetNs)，以此错开绘制和合成在VYSNC信号到来后的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建合成对象HWComposer，这里会打开fb和hwc硬件设备，HWComposer代表的不一定就是实际的底层硬件设备</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">        *static_cast&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">        vsyncPhaseOffsetNs, <span class="keyword">true</span>);<span class="comment">//App绘制延时 绘制垂直同步源</span></span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);<span class="comment">//这个EventThread负责管理绘制的Vsync同步源</span></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">        sfVsyncPhaseOffsetNs, <span class="keyword">false</span>);<span class="comment">//SF合成延时 由于延时的不同，渲染和合成在收到真正的VSync信号之后错开执行。</span></span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);<span class="comment">//这个EventThread负责管理合成的Vsync同步源</span></span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);<span class="comment">//这里会建立一个EventConnection，实际上就是注册成为了一个监听者，这样当有vsync信号时可以通知给MessageQueue </span></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给HWC硬件发送消息,用来控制打开关闭Vsync信号</span></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">     <span class="comment">// set initial conditions (e.g. unblank default device)</span></span><br><span class="line">    initializeDisplays();<span class="comment">//初始化显示器，这里会重新打开Vsync信号，默认它在EventControlThread中设置是关闭的。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="硬件vsync信号的产生"><a class="markdownIt-Anchor" href="#硬件vsync信号的产生"></a> 硬件VSYNC信号的产生</h4><p>在介绍VSYNC信号如何来协调绘制和合成过程前，我们先看硬件VSYNC信号是如何产生并传递给同步模型DispSync。首先硬件的垂直信号是通过显示设备产生的，它通过HAL层的HWComposer模块将硬件垂直信号发送给SF。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></span><br><span class="line">HWComposer::HWComposer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),</span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),</span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(<span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> fberr = loadFbHalModule();<span class="comment">//打开fb设备</span></span><br><span class="line">    loadHwcModule();<span class="comment">//打开hwc模块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;<span class="comment">//支持硬件合成</span></span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<span class="comment">//硬件垂直信号的回调</span></span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))<span class="comment">//1.1版本支持热插拔</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = NULL;</span><br><span class="line">            memset(mCBContext-&gt;procs.zero, <span class="number">0</span>, sizeof(mCBContext-&gt;procs.zero));</span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);<span class="comment">//注册回调</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't need a vsync thread if we have a hardware composer</span></span><br><span class="line">        needVSyncThread = <span class="keyword">false</span>;<span class="comment">//支持硬件合成的话就不需要软件进行模拟了</span></span><br><span class="line">        <span class="comment">// always turn vsync off when we start</span></span><br><span class="line">        <span class="comment">//先关闭VSYNC，后面会重新打开</span></span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFbDev) &#123;<span class="comment">//fb设备已经打开</span></span><br><span class="line">        DisplayData&amp; disp(mDisplayData[HWC_DISPLAY_PRIMARY]);</span><br><span class="line">        disp.connected = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//设置主屏幕的参数，包括显示参数包括宽度、高度，像素格式以及刷新频率</span></span><br><span class="line">        disp.width = mFbDev-&gt;width;</span><br><span class="line">        disp.height = mFbDev-&gt;height;</span><br><span class="line">        disp.format = mFbDev-&gt;format;</span><br><span class="line">        disp.xdpi = mFbDev-&gt;xdpi;</span><br><span class="line">        disp.ydpi = mFbDev-&gt;ydpi;</span><br><span class="line">        <span class="keyword">if</span> (disp.refresh == <span class="number">0</span>) &#123;</span><br><span class="line">            disp.refresh = nsecs_t(<span class="number">1e9</span> / mFbDev-&gt;fps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp.refresh == <span class="number">0</span>) &#123;</span><br><span class="line">            disp.refresh = nsecs_t(<span class="number">1e9</span> / <span class="number">60.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要通过软件模拟Vsync信号</span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;</span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it</span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer对象负责SF的硬件合成，理所当然VSYNC信号也应该由其提供，在其构造方法中，会加载hwc设备模块，并将VSYNC信号的回调hook_vsync注册到hwc设备中这样硬件产生的VSYNC信号就可以回调给HWCoposer对象的hook_vsync。需要注意的是HWComposer并不一定就是底层存在的硬件设备，它也可以代表一个虚拟设备，这样VSYNC信号就是通过一个VSyncThread线程模拟硬件产生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知HWComposer垂直事件到达</span></span><br><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        int64_t timestamp) &#123;</span><br><span class="line">    cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;(</span><br><span class="line">            const_cast&lt;hwc_procs_t*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VSYNC事件到达</span></span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, int64_t timestamp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// There have been reports of HWCs that signal several vsync events</span></span><br><span class="line">            <span class="comment">// with the same timestamp when turning the display off and on. This</span></span><br><span class="line">            <span class="comment">// is a bug in the HWC implementation, but filter the extra events</span></span><br><span class="line">            <span class="comment">// out here so they don't cause havoc downstream.</span></span><br><span class="line">            <span class="keyword">if</span> (timestamp == mLastHwVSync[disp]) &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring duplicate VSYNC event from HWC (t=%lld)"</span>,</span><br><span class="line">                        timestamp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLastHwVSync[disp] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);<span class="comment">//sf回调 将vsync消息通告给sf</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在hook_vsync方法中进一步调用HWComposer的vsync方法通知VSYNC信号事件，在vsync方法中，最终是通过EventHandler的onVsyncReceived方法通知给SF的，这个EventHandler是在构造HWComposer时由SF提供的，实际上SF本身就是继承自HWComposer::EventHandler，而HWComposer::EventHandler的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HWComposer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">        friend <span class="class"><span class="keyword">class</span> <span class="title">HWComposer</span></span>;</span><br><span class="line">        <span class="function">virtual <span class="keyword">void</span> <span class="title">onVSyncReceived</span><span class="params">(<span class="keyword">int</span> disp, nsecs_t timestamp)</span> </span>= <span class="number">0</span>;<span class="comment">//vynsc消息回调</span></span><br><span class="line">        <span class="function">virtual <span class="keyword">void</span> <span class="title">onHotplugReceived</span><span class="params">(<span class="keyword">int</span> disp, bool connected)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        virtual ~EventHandler() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以VSYNC信号是通过vsync方法的mEventHandler回调onVsyncReceived通知给SF，我们看看SF是如何实现的onVsyncReceived方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(<span class="keyword">int</span> type, nsecs_t timestamp) &#123;</span><br><span class="line">    bool needsHwVsync = <span class="keyword">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;<span class="comment">//mPrimaryHWVsyncEnabled是用来标识主屏幕对应的HWC的VSYNC功能有没有被开启</span></span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);<span class="comment">//统计Vsync样本</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，我们看到硬件产生的同步信号最终是交给同步模型DispSync的addResyncSample方法，根据该方法的返回值，可以根据需要控制硬件是否继续发送垂直信号，可见，硬件的垂直信号并不是持续产生的，而是同步模型在需要的时候才打开的，而什么时候需要，是由addResyncSample计算得到的。</p><p>这里我们顺便看看硬件的垂直信号是如何打开和关闭的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启硬件Vsync</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::enableHardwareVsync() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123;</span><br><span class="line">        mPrimaryDispSync.beginResync();</span><br><span class="line">        <span class="comment">//eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, true);</span></span><br><span class="line">        mEventControlThread-&gt;setVsyncEnabled(<span class="keyword">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//禁用硬件Vsync</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::disableHardwareVsync(bool makeUnavailable) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        <span class="comment">//eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, false);</span></span><br><span class="line">        mEventControlThread-&gt;setVsyncEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mPrimaryDispSync.endResync();</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (makeUnavailable) &#123;</span><br><span class="line">        mHWVsyncAvailable = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬件垂直信号的开关是通过mEventControlThread的setVysncEnable方法控制的，在SF的init方法中会创建这个mEventControlThread，它是一个EventControlThread，也是一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventControlThread::setVsyncEnabled(bool enabled) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCond.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool EventControlThread::threadLoop() &#123;<span class="comment">//EventControlThread主要用来控制硬件是否应该发送Vsync信号</span></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    bool vsyncEnabled = mVsyncEnabled;</span><br><span class="line">    <span class="comment">//EventControlThread是在SF的Init中创建的，所以硬件Vsync信号默认是关闭的，这个在屏幕点亮后会开启</span></span><br><span class="line">    mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC,</span><br><span class="line">            mVsyncEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        status_t err = mCond.wait(mMutex);<span class="comment">//没有控制信号的时候是阻塞的</span></span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"error waiting for new events: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态发生了变化，则通知SF来控制Vysnc，HWC_DISPLAY_PRIMARY代表了主显示屏，EVENT_VSYNC说明控制的是VSync信号</span></span><br><span class="line">        <span class="keyword">if</span> (vsyncEnabled != mVsyncEnabled) &#123;</span><br><span class="line">            mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY,</span><br><span class="line">                    SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled);</span><br><span class="line">            vsyncEnabled = mVsyncEnabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在threadLoop中，它一开始默认的就通过SF的eventControl将硬件的VSYNC信号关闭，然后进入到while循环中阻塞，当通过setVsyncEnabled设置了mVsyncEnabled并唤醒线程后，根据设置的状态，通过SF的eventControl将通知hwc开关VSYNC信号。当然，在SF初始化完成后会打开硬件的VSYNC信号。这个流程我简单的介绍下。</p><p>SurfaceFlinger::initializeDisplays<br>SurfaceFlinger::onInitializeDisplays<br>SurfaceFlinger::onScreenAcquired<br>SurfaceFlinger::resyncToHardwareVsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::resyncToHardwareVsync(bool makeAvailable) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        mHWVsyncAvailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        ALOGE(<span class="string">"resyncToHardwareVsync called when HW vsync unavailable"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nsecs_t period =</span><br><span class="line">            getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);<span class="comment">// //获得显示设备的刷新率</span></span><br><span class="line"></span><br><span class="line">    mPrimaryDispSync.reset();</span><br><span class="line">    mPrimaryDispSync.setPeriod(period);<span class="comment">//设置DispSync模型里period为显示设备的频率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        mPrimaryDispSync.beginResync();</span><br><span class="line">        <span class="comment">//eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, true);</span></span><br><span class="line">        <span class="comment">//如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC</span></span><br><span class="line">        mEventControlThread-&gt;setVsyncEnabled(<span class="keyword">true</span>);<span class="comment">//打开硬件的VSYNC功能,即在屏幕点亮的时候打开</span></span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SF在init中会对显示设备进行一次初始化，这个初始化的过程最终会通过resyncToHardwareVsync根据显示设备设置同步模型的刷新频率同时也会打开硬件的VSYNC信号，以此为VSYNC同步模型做好同步的准备。</p><h4 id="dispsync同步模型"><a class="markdownIt-Anchor" href="#dispsync同步模型"></a> DispSync同步模型</h4><p>硬件VSYNC是如何产生并交给同步模型的过程我们已经清楚了，接下来，我们看看同步模型是如何处理硬件的同步信号并为上层的监听者提供VSYNC信号的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vsync的同步模型对象 默认会启动一个线程进行信号同步</span></span><br><span class="line">DispSync::DispSync() &#123;</span><br><span class="line">    mThread = <span class="keyword">new</span> DispSyncThread();<span class="comment">//启动同步线程，在在线程中等待垂直信号的到达</span></span><br><span class="line">    mThread-&gt;run(<span class="string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line">    beginResync();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DisySync构造方法中会默认的开启一个同步线程DispSyncThread，这个线程负责进行VYSNC信号的同步同时会将垂直同步信号发送给感兴趣的监听者(比如我们在SF的init方法中创建的两个延时源DispSyncSource)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class DispSyncThread: public Thread &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">virtual bool <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status_t err;</span><br><span class="line">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);<span class="comment">//当前时间</span></span><br><span class="line">        nsecs_t nextEventTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Vector&lt;CallbackInvocation&gt; callbackInvocations;<span class="comment">//回调列表</span></span><br><span class="line"></span><br><span class="line">            nsecs_t targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;<span class="comment">//还未设置模型频率，则等待</span></span><br><span class="line">                    err = mCond.wait(mMutex);</span><br><span class="line">                    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                        ALOGE(<span class="string">"error waiting for new events: %s (%d)"</span>,</span><br><span class="line">                                strerror(-err), err);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nextEventTime = computeNextEventTimeLocked(now);</span><br><span class="line">                targetTime = nextEventTime;<span class="comment">//触发时间</span></span><br><span class="line"></span><br><span class="line">                bool isWakeup = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (now &lt; targetTime) &#123;<span class="comment">//还未到触发时间，则等待一段时间</span></span><br><span class="line">                    err = mCond.waitRelative(mMutex, targetTime - now);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (err == TIMED_OUT) &#123;<span class="comment">//等待时间到达触发时间</span></span><br><span class="line">                        isWakeup = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                        ALOGE(<span class="string">"error waiting for next event: %s (%d)"</span>,</span><br><span class="line">                                strerror(-err), err);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                    mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) +</span><br><span class="line">                            (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mWakeupLatency &gt; <span class="number">500000</span>) &#123;</span><br><span class="line">                        <span class="comment">// Don't correct by more than 500 us</span></span><br><span class="line">                        mWakeupLatency = <span class="number">500000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (traceDetailedInfo) &#123;</span><br><span class="line">                        ATRACE_INT64(<span class="string">"DispSync:WakeupLat"</span>, now - nextEventTime);</span><br><span class="line">                        ATRACE_INT64(<span class="string">"DispSync:AvgWakeupLat"</span>, mWakeupLatency);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收集此次应该通知的监听者</span></span><br><span class="line">                callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//回调通知，调用注册的事件，即SF中的绘图延时和合成延时对象</span></span><br><span class="line">                fireCallbackInvocations(callbackInvocations);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispSyncThread的逻辑很简单，它通过一个while循环，来不断的通过computeNextEventTimeLocked计算下一次VSYNC信号的时间，然后通过gatherCallbackInvocationsLocked收集要通知的监听者，最后通过fireCallbackInvocations来通知他们VSYNC信号的到达事件。这里最关键的是VYSNC信号的计算过程，同步模型是如何按照监听者的延时要求提供VSYNC信号的，它是如何保证VSYNC信号的精度和有序性的？以及模型出现误差后是如何做出调整？要回答这些问题，需要对同步模型的整个机制进行完整和全面的了解。这里为了保证文章篇幅，我们不会对同步模型做详细的描述，这里只简单的描述下即可。</p><p>前面我们知道SF在接收到硬件的VSYNC信号后通过addResyncSample方法来将信号发送给同步模型的进行样本统计。下面我们看看其实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool DispSync::addResyncSample(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    updateModelLocked();</span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        resetErrorLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runningWithoutSyncFramework) &#123;</span><br><span class="line">        <span class="comment">// If we don't have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we're synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;hasAnyEventListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mPeriod == <span class="number">0</span> || mError &gt; errorThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，同步模型会收集硬件的Vsync信号的时间戳信息到mResyncSamples中，最多保存MAX_RESYNC_SAMPLES(定义为32)个硬件的VSYNC信号的时间信息，其中mNumResyncSamples和mFirstResyncSample构成了一个大小为32的VSYNC信号窗口，这个窗口最多可以包含32份硬件的VSYNC信号的时间戳信息，其中mFirstResyncSample是窗口的第一个VSYNC信号样本，而mNumResyncSamples表示已经有多少个信号样本。有了这些样本，就可以基于此来更新我们的同步模型的来使其和硬件的VSYNC信号同步。这个是通过updateModelLocked方法来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DispSync::updateModelLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        nsecs_t durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            size_t prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="comment">// durationSum 表示保存的所有样本(除去第一个vsync)时间间隔之后，用于后面计算 平均 mPeriod</span></span><br><span class="line">            <span class="comment">// mResyncSamples[idx] - mResyncSamples[prev] 这个差值就是计算出两个硬件vsync样本之间的时间间隔</span></span><br><span class="line">            durationSum += mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个平均值就是硬件vsync产生的时间间隔</span></span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面计算出模型需要的偏移</span></span><br><span class="line">        <span class="keyword">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="keyword">double</span>(mPeriod);</span><br><span class="line">        <span class="comment">//将硬件vsync的时间间隔换算成对应的度数,即刻度，这里的刻度表示每ns代表多少度</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            nsecs_t sample = mResyncSamples[idx];</span><br><span class="line">            <span class="keyword">double</span> samplePhase = <span class="keyword">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += cos(samplePhase);</span><br><span class="line">            sampleAvgY += sin(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得在x轴与y轴的偏移的平均值</span></span><br><span class="line">        sampleAvgX /= <span class="keyword">double</span>(mNumResyncSamples);</span><br><span class="line">        sampleAvgY /= <span class="keyword">double</span>(mNumResyncSamples);</span><br><span class="line">        <span class="comment">//最后再通过atan2获得最终的相移值</span></span><br><span class="line">        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line">        <span class="comment">//如果相移小于0 ，那么重新调整一下</span></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traceDetailedInfo) &#123;</span><br><span class="line">            ATRACE_INT64(<span class="string">"DispSync:Period"</span>, mPeriod);</span><br><span class="line">            ATRACE_INT64(<span class="string">"DispSync:Phase"</span>, mPhase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最新的 偏移 mPhase和 vsync时间间隔mPeriod 更新到模型当中</span></span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateModelLocked方法根据统计的样本来更新同步模型，只有当样本数大于等于MIN_RESYNC_SAMPLES_FOR_UPDATE(定义为3)时才进行模型的更新，当样本数大于等于3时先通过样本计算mPerid，这个值时计算方式是统计所有相邻样本的时间间隔总和到durationSum中，然后除以样本数减1就是样本的频率mPeriod。接下来计算模型的偏移，因为现在 mPeriod 算出来的是平均值，所以并不是真的硬件vsync时间间隔就是 mPeriod, 存在着误差，即有些样本信号的时间间隔大于平均值，而有些样本时间间隔小于平均值，而这些与mPriod的差值就是偏移，下面就是要算出这些平均的偏移值，计算偏移值后会将偏移值mPhase和时间间隔mPeriod更新到模型中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(nsecs_t period, nsecs_t phase)</span> </span>&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    mCond.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在同步模型线程中computeNextEventTimeLocked基于统计样本计算的mPeriod和mPhase计算下一次的VSYNC信号，接下来我们看看computeNextEventTimeLocked是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最接近的下次VSYNC信号的时间</span></span><br><span class="line"><span class="function">nsecs_t <span class="title">computeNextEventTimeLocked</span><span class="params">(nsecs_t now)</span> </span>&#123;</span><br><span class="line">    nsecs_t nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">        nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i],now);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为监听者计算下次Vsync信号事件发生时间</span></span><br><span class="line"><span class="function">nsecs_t <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="keyword">const</span> EventListener&amp; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">        nsecs_t ref)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    nsecs_t lastEventTime = listener.mLastEventTime;<span class="comment">//上次的事件</span></span><br><span class="line">    <span class="keyword">if</span> (ref &lt; lastEventTime) &#123;</span><br><span class="line">        ref = lastEventTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nsecs_t phase = mPhase + listener.mPhase;</span><br><span class="line">    nsecs_t t = (((ref - phase) / mPeriod) + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t - listener.mLastEventTime &lt; mPeriod / <span class="number">2</span>) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computeNextEventTimeLocked针对所有的监听者计算下一次的VSYNC信号的发生时间，并将最接近当前时间的一次作为结果返回，而每个监听者的下一次VSYNC信号的发生时间可能是不同，因为他们可能设置了不同的偏移，因此针对每个监听者计算下一次VSYNC信号的发生时间是通过computeListenerNextEventTimeLocked完成的。</p><p>同步模型并不一定完全准确，每次计算可能都会有误差的出现，当出现误差后，则需要更新误差值，根据误差值来判断是否需要开启硬件VSYNC重新添加样本到同步模型中进行计算。这个过程是在SF的postCompostion中进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::postComposition()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> HWComposer&amp; hwc = getHwComposer();</span><br><span class="line">    sp&lt;Fence&gt; presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (presentFence-&gt;isValid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPrimaryDispSync.addPresentFence(presentFence)) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disableHardwareVsync(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在postComposition中先拿到当前设备的Fence,然后通过addPresentFence计算同步模型的误差值，根据误差值来决定是否需要启用硬件VSYNC。</p><h4 id="通知监听者"><a class="markdownIt-Anchor" href="#通知监听者"></a> 通知监听者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集回调，根据回调的延时偏量计算是否要触发回调</span></span><br><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(nsecs_t now)</span> </span>&#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">    nsecs_t ref = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">        nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i],</span><br><span class="line">                ref);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;<span class="comment">//小于当前时间的都是需要通知的监听者</span></span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.push(ci);</span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算完下次要触发VSYNC信号的时间后，可能需要等待一段时间，因为当前时间还未到达最近的触发事件，当到达触发的时间后，同步模型线程会通过gatherCallbackInvocationsLocked收集需要进行通知的监听者，如果监听者的下次VSYNC信号发生时间已经小于本次VSYNC信号的触发时间，则说明监听者需要进行通知了，将其添加到集合中等待回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调对同步模型的VSync信号感兴趣的监听者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过监听者的添加的回调通知其VSYNC信号已经到达。</p><h4 id="绘图延时源和合成延时源dispsyncsource"><a class="markdownIt-Anchor" href="#绘图延时源和合成延时源dispsyncsource"></a> 绘图延时源和合成延时源(DispSyncSource)</h4><p>在SF的init方法中我们知道SF创建了两个延时源对象DispSyncSource，他们基于同步模型来处理VSYNC信号，这两个不同的延时源通过两个不同的EventThread来管理，他们分别为mEventThread和mSFEventThread，这里的EventThread是为了延时源方便管理VSYNC信号，比如对于绘图延时源，它的监听者就有大名鼎鼎的Choreographer，上层App的绘制过程正是在Choreographer的协调下同步进行的，而Choreographer正是注册到绘图延时源的EventThread中以此来监听VSYNC信号，而SF是注册到合成延时源的EventThread中。</p><p>下面我们看看由同步模型传递给延时源的VSYNC信号是如何使用传递给需要的监听者的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class DispSyncSource : public VSyncSource, private DispSync::Callback &#123;//VsyncSource定义在EventThread.h</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//DispSync是Vsync信号的模型对象</span></span><br><span class="line">    DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, bool traceVsync) :</span><br><span class="line">            mValue(<span class="number">0</span>),</span><br><span class="line">            mPhaseOffset(phaseOffset),<span class="comment">//距离Vsync信号的延时偏移</span></span><br><span class="line">            mTraceVsync(traceVsync),</span><br><span class="line">            mDispSync(dispSync) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual ~DispSyncSource() &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">virtual <span class="keyword">void</span> <span class="title">setVSyncEnabled</span><span class="params">(bool enable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do NOT lock the mutex here so as to avoid any mutex ordering issues</span></span><br><span class="line">        <span class="comment">// with locking it in the onDispSyncEvent callback.</span></span><br><span class="line">        <span class="keyword">if</span> (enable) &#123;<span class="comment">//如果启用Vsync</span></span><br><span class="line">            status_t err = mDispSync-&gt;addEventListener(mPhaseOffset,</span><br><span class="line">                    static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));<span class="comment">//添加Vsync信号的事件回调</span></span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">"error registering vsync callback: %s (%d)"</span>,</span><br><span class="line">                        strerror(-err), err);</span><br><span class="line">            &#125;</span><br><span class="line">            ATRACE_INT(<span class="string">"VsyncOn"</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status_t err = mDispSync-&gt;removeEventListener(</span><br><span class="line">                    static_cast&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">"error unregistering vsync callback: %s (%d)"</span>,</span><br><span class="line">                        strerror(-err), err);</span><br><span class="line">            &#125;</span><br><span class="line">            ATRACE_INT(<span class="string">"VsyncOn"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">virtual <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">const</span> sp&lt;VSyncSource::Callback&gt;&amp; callback)</span> </span>&#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">//实现了DispSync的回调接口,这个回调是在DispSync中通过fireCallbackInvocations来调用的</span></span><br><span class="line">    <span class="function">virtual <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(nsecs_t when)</span> </span>&#123;</span><br><span class="line">        sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            callback = mCallback;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mTraceVsync) &#123;</span><br><span class="line">                mValue = (mValue + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">                ATRACE_INT(<span class="string">"VSYNC"</span>, mValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != NULL) &#123;</span><br><span class="line">            callback-&gt;onVSyncEvent(when);<span class="comment">//调用设置的回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nsecs_t mPhaseOffset;</span><br><span class="line">    <span class="keyword">const</span> bool mTraceVsync;</span><br><span class="line"></span><br><span class="line">    DispSync* mDispSync;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; mCallback;</span><br><span class="line">    Mutex mMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>延时源通过同步模型DispSync来构造，同步模型通过接口onDispSyncEvent上报给延时源VSYNC信号，并通过延时源设置的回调callback的onVSyncEvent方法将VSYNC信号的到达事件发送给设置者(事实上就是EventThread)。同时，延时源可以通过setVSyncEnabled方法来控制是否监听来自于同步模型的VSYNC信号。</p><h4 id="eventthread"><a class="markdownIt-Anchor" href="#eventthread"></a> EventThread</h4><p>EventThread顾明思议，它实际上也是一个Thread，它创建的时候就会启动该线程.我们看看它的线程回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span></span><br><span class="line">bool EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);<span class="comment">//阻塞中，等待VYSNC信号通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> size_t count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        status_t err = conn-&gt;postEvent(event);<span class="comment">//post事件</span></span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// The destination doesn't accept events anymore, it's probably</span></span><br><span class="line">            <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">            <span class="comment">// to be re-sent later.</span></span><br><span class="line">            <span class="comment">// Right-now we don't have the ability to do this.</span></span><br><span class="line">            ALOGW(<span class="string">"EventThread: dropping event (%08x) for connection %p"</span>,</span><br><span class="line">                    event.header.type, conn.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">            <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">            <span class="comment">// The most common error we'll get here is -EPIPE.</span></span><br><span class="line">            removeDisplayEventConnection(signalConnections[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程回调方法首先通过waitForEvent等待VSYNC信号的通知，同时获取到需要通知的Connection，这里的Connection就是延时源VSYNC信号的监听者，随后通过Connection的postEvent方法将事件发送给监听者，所以EventThread最核心的内容应该是在waitForEvent中进行处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当接收到vsync信号时接收到 或者至少有一个连接对VSYNC信号感兴趣此方法返回给调用者</span></span><br><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        bool eventPending = <span class="keyword">false</span>;</span><br><span class="line">        bool waitForVSync = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        size_t vsyncCount = <span class="number">0</span>;</span><br><span class="line">        nsecs_t timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//关键点1 垂直信号事件</span></span><br><span class="line">        <span class="keyword">for</span> (int32_t i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// we have a vsync event to dispatch</span></span><br><span class="line">                *event = mVSyncEvent[i];<span class="comment">//垂直事件到来</span></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timestamp) &#123;</span><br><span class="line">            <span class="comment">// no vsync event, see if there are some other event</span></span><br><span class="line">            eventPending = !mPendingEvents.isEmpty();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];<span class="comment">//其他的事件</span></span><br><span class="line">                mPendingEvents.removeAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find out connections waiting for events</span></span><br><span class="line">        <span class="comment">//关键点2 查看是否有对VSYNC信号感兴趣的连接</span></span><br><span class="line">        size_t count = mDisplayEventConnections.size();</span><br><span class="line">        <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote()</span>)</span>;<span class="comment">//取得连接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != NULL) &#123;</span><br><span class="line">                bool added = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;<span class="comment">//关于这个显示屏垂直信号的客户端个数大于等于0</span></span><br><span class="line">                    <span class="comment">// we need vsync events because at least</span></span><br><span class="line">                    <span class="comment">// one connection is waiting for it</span></span><br><span class="line">                    waitForVSync = <span class="keyword">true</span>;<span class="comment">//至少有一个连接在等待VSync事件</span></span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                        <span class="comment">// we consume the event only if it's time</span></span><br><span class="line">                        <span class="comment">// (ie: we received a vsync event)</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = -<span class="number">1</span>;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don't have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn't promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="comment">//关键点3  根据需要开启和关闭VSYNC信号，这里的开启和关闭是指注册回调到延时源以及从同步源移除或者添加监听</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;<span class="comment">//收到了一个垂直信号当时没有客户端感兴趣</span></span><br><span class="line">            <span class="comment">// we received a VSYNC but we have no clients</span></span><br><span class="line">            <span class="comment">// don't report it, and disable VSYNC events</span></span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// we have at least one client, so we want vsync enabled</span></span><br><span class="line">            <span class="comment">// (<span class="doctag">TODO:</span> this function is called right after we finish</span></span><br><span class="line">            <span class="comment">// notifying clients of a vsync, so this call will be made</span></span><br><span class="line">            <span class="comment">// at the vsync rate, e.g. 60fps.  If we can accurately</span></span><br><span class="line">            <span class="comment">// track the current state we could avoid making this call</span></span><br><span class="line">            <span class="comment">// so often.)</span></span><br><span class="line">            enableVSyncLocked();<span class="comment">//启用Vsync</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span></span><br><span class="line">        <span class="comment">// don't populate signalConnections if there's no vsync pending</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="comment">// wait for something to happen</span></span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123;<span class="comment">//如果VSYNC信号未到达，但有管兴趣的连接等待VSYNC，则等待VSYNC信号，线程阻塞等待唤醒</span></span><br><span class="line">                <span class="comment">// This is where we spend most of our time, waiting</span></span><br><span class="line">                <span class="comment">// for vsync events and new client registrations.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// If the screen is off, we can't use h/w vsync, so we</span></span><br><span class="line">                <span class="comment">// use a 16ms timeout instead.  It doesn't need to be</span></span><br><span class="line">                <span class="comment">// precise, we just need to keep feeding our clients.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// We don't want to stall if there's a driver bug, so we</span></span><br><span class="line">                <span class="comment">// use a (long) timeout when waiting for h/w vsync, and</span></span><br><span class="line">                <span class="comment">// generate fake events when necessary.</span></span><br><span class="line">                bool softwareSync = mUseSoftwareVSync;</span><br><span class="line">                nsecs_t timeout = softwareSync ? ms2ns(<span class="number">16</span>) : ms2ns(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"Timed out waiting for hw vsync; faking it"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<span class="comment">//消息类型</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有对VSync信号感兴趣的，只是让线程阻塞</span></span><br><span class="line">                <span class="comment">// Nobody is interested in vsync, so we just want to sleep.</span></span><br><span class="line">                <span class="comment">// h/w vsync should be disabled, so this will wait until we</span></span><br><span class="line">                <span class="comment">// get a new connection, or an existing connection becomes</span></span><br><span class="line">                <span class="comment">// interested in receiving vsync again.</span></span><br><span class="line">                mCondition.wait(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we're guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we'll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直事件到达后会将其保存在参数event中，如果timestamp是0，表示没有VSYNC信号到达。mDisplayEventConnections中保存了已经注册的监听者。如果此时connection的count大于等于0，则表示有监听者对VSYNC信号感兴趣，同时置waitForVSync为true,同时将该监听者添加到signalConnections集合中。这里connection的count值的含义如下：</p><ol><li>count &gt;= 1 : continuous event. count is the vsync rate  如果在大于等于1，表示会持续接收vsync event</li><li>count == 0 : one-shot event that has not fired    表示只接收一次</li><li>count ==-1 : one-shot event that fired this round / disabled   等于-1，表示不能再接收vsync事件了</li></ol><p>当满足timestamp &amp;&amp; !waitForVSync时表示VSYNC信号已经到达，但是此时没有感兴趣的监听者，所以此时不需要再接收VSYNC信号了，通过disableVSyncLocked移除对同步模型的VSYNC信号的监听。</p><p>当!timestamp &amp;&amp; waitForVSync满足时则说明有感兴趣的监听者，但VSYNC信号还未达到，这时候需要使用enableVSyncLocked将延时源添加到同步模型的监听者集合中。</p><p>如果!timestamp &amp;&amp; !eventPending则表示没有VSYNC信号到达，且没有其他等待的事件，但此时如果waitForVSync为true,则要等待VSYNC信号，但此时不会无限等待下去，而是有一个超时时间。</p><p>当VSYNC信号到达后，通过EventThread设置的callback来接收来自同步模型的VSYNC信号，这个回调就是EventThread的onVSyncEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<span class="comment">//准备好发送的消息</span></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">    mCondition.broadcast();<span class="comment">//广播解除threadloop的阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onVSyncEvent方法中，会解除在waitForEvent中等待VSYNC信号的阻塞状态。从而退出while循环，通知相应的监听者VSYNC信号的到达。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>至此，我们就将VSYNC信号在SF中的传递和控制过程介绍完了，我们简单总结下整个传递过程：</p><ol><li>硬件或者由软件模拟触发VSYNC信号，通知给SF</li><li>SF接收到硬件的VSYNC信号后将其添加到同步模型DispSync的样本数组中进行统计和计算模型的偏移和周期</li><li>同步模型根据计算的偏移和周期计算下次VSYNC信号发生时间，并通知监听者VSYNC信号到达的事件</li><li>同步模型的VSYNC信号传递给延时源，延时源通过EventThread来管理VSYNC信号的收发</li></ol><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><p>Android 5.1 SurfaceFlinger VSYNC详解<br><a href="https://blog.csdn.net/newchenxf/article/details/49131167" target="_blank" rel="noopener">https://blog.csdn.net/newchenxf/article/details/49131167</a></p><p>DispSync<br><a href="https://echuang54.blogspot.com/2015/01/dispsync.html" target="_blank" rel="noopener">https://echuang54.blogspot.com/2015/01/dispsync.html</a></p><p>Android中的GraphicBuffer同步机制-Fence<br><a href="https://blog.csdn.net/jinzhuojun/article/details/39698317" target="_blank" rel="noopener">https://blog.csdn.net/jinzhuojun/article/details/39698317</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;surfaceflinger中vsync信号的控制同步&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#surfaceflinger中vsync信号的控制同步&quot;&gt;&lt;/a&gt; SurfaceFlinger中VSYNC信号的控制同步&lt;/h4&gt;

      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GUI系统之SurfaceFlinger HAL层(一)</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surfaceflinger-1-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surfaceflinger-1-src/</id>
    <published>2018-06-03T02:45:56.000Z</published>
    <updated>2019-03-16T08:09:18.955Z</updated>
    
    <content type="html"><![CDATA[<p>SurfaceFlinger是GUI系统的核心，本篇将以自底向上的方式对其展开介绍。</p><h3 id="硬件层面"><a class="markdownIt-Anchor" href="#硬件层面"></a> 硬件层面</h3><p>Linux 内核提供了统一的famebuffer显示驱动，设备节点/dev/graphics/fb* 或者 /dev/fb*,fb0是第一个显示屏。</p><h3 id="hal层面"><a class="markdownIt-Anchor" href="#hal层面"></a> HAL层面</h3><p>HAL即硬件抽象层，Android的各个子系统通常不会直接使用内核驱动，而是由HAL层简介引用底层架构。Android的HAL层提供了Gralloc，包括了fb和gralloc两个设备。前者负责打开内核中的framebuffer，初始化配置；后者则管理帧缓冲去的分配和释放。</p><p>在HAL层中还有一个重要的模块 “Composer”，它为厂商自定制“UI合成”提供了接口。Composer的直接使用者是SurfaceFlinger中的HWComposer</p><h3 id="gralloc模块"><a class="markdownIt-Anchor" href="#gralloc模块"></a> Gralloc模块</h3><p>下面我们就从HAL层来看看Gralloc的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\include\hardware\gralloc.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gralloc_module_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> <span class="title">common</span>;</span><span class="comment">//每个硬件模块对应的结构都需要hw_module_t这个抽象模块</span></span><br><span class="line">    <span class="keyword">int</span> (*registerBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*unregisterBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> (*lock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,</span><br><span class="line">            <span class="keyword">void</span>** vaddr);</span><br><span class="line">        <span class="keyword">int</span> (*unlock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">      ……………</span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br></pre></td></tr></table></figure><p>对于以上的结构体需要注意的是：<br>1.每一个硬件都有其对应的模块结构，并且该结构的第一个成员必须为hw_module_t结构，该结构是HAL层对硬件的统一抽象。所以每一个硬件模块都要对应一个hw_module_t结构，并且名称必须为HAL_MODULE_INFO_SYM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\include\hardware\hardware.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;<span class="comment">//version_major</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;<span class="comment">//version_minor</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br></pre></td></tr></table></figure><p>hw_module_t结构用来描述硬件模块的基本信息，如当前的版本，模块Id以及硬件模块对应的打开方法。</p><p>Gralloc模块负责管理gralloc设备和fb设备，它是处于HAL层的，向上提供了这个两个设备的功能。其中最主要的两个接口分别为gralloc_device_open和gralloc_alloc。<br>我们先看gralloc_device_open，这个方法负责打开gralloc或者fb设备的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gralloc模块的打开设备方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;<span class="comment">//打开GPU</span></span><br><span class="line">        <span class="keyword">gralloc_context_t</span> *dev;</span><br><span class="line">        dev = (<span class="keyword">gralloc_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* initialize our state here */</span></span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* initialize the procs */</span></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">        dev-&gt;device.common.close = gralloc_close;</span><br><span class="line"></span><br><span class="line">        dev-&gt;device.alloc   = gralloc_alloc;</span><br><span class="line">        dev-&gt;device.<span class="built_in">free</span>    = gralloc_free;</span><br><span class="line"></span><br><span class="line">        *device = &amp;dev-&gt;device.common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//打开fb设备</span></span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数name指定了要打开的模块，Name为GRALLOC_HARDWARE_GPU0说明打开的是GPU，否则打开fb设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对外的分配缓冲区的方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span>* pStride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHandle || !pStride)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesPerPixel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;<span class="comment">//指定的缓冲区像素格式</span></span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_FP16:</span><br><span class="line">            bytesPerPixel = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBX_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_BGRA_8888:</span><br><span class="line">            bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_888:</span><br><span class="line">            bytesPerPixel = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_565:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW16:</span><br><span class="line">            bytesPerPixel = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> tileWidth = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> tileHeight = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> stride = align(width, tileWidth);</span><br><span class="line">    <span class="keyword">size_t</span> size = align(height, tileHeight) * stride * bytesPerPixel + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_HW_FB) &#123;<span class="comment">//在FB设备中分配帧缓冲区</span></span><br><span class="line">        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//在内存中分配图形缓冲区</span></span><br><span class="line">        err = gralloc_alloc_buffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pStride = stride;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法gralloc_alloc 负责为上层分配缓冲区，注意这里的缓冲区既可以是内存缓冲区，也可以是fb的帧缓冲区。这分别是通过gralloc_alloc_buffer 和 gralloc_alloc_framebuffer来实现的。在内存中创建缓冲区是基于asheme的方式来创建一块匿名共享内存来作为缓冲区的，而如果是从fb中分配则只需要将fb的帧缓冲区映射到当前进程来即可。具体可以参见famebuffer.cpp中的mapFrameBufferLocked方法。</p><p>关于fb设备 其最重要的功能是将上层缓冲区的内容通过交换显示在屏幕上，这个功能是通过fb_post来实现的，在这之前我们看看如何打开fb设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开fb设备 这个方法通过HAL层的Gralloc模块提供给上层接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;<span class="comment">//打开的是Fb设备</span></span><br><span class="line">        <span class="comment">/* initialize our state here */</span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));<span class="comment">//分配fb_context_t 结构</span></span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* initialize the procs */</span></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">        dev-&gt;device.common.close = fb_close;</span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;</span><br><span class="line">        dev-&gt;device.post   = fb_post;<span class="comment">//设置设备post回调接口，这个接口将缓冲区的内容显示在屏幕上</span></span><br><span class="line">        dev-&gt;device.setUpdateRect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)<span class="keyword">module</span>;</span><br><span class="line">        status = mapFrameBuffer(m);<span class="comment">//对fb设备进行映射 其实是调用mapFrameBufferLocked</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">int</span> format = (m-&gt;info.bits_per_pixel == <span class="number">32</span>)</span><br><span class="line">                         ? (m-&gt;info.red.offset ? HAL_PIXEL_FORMAT_BGRA_8888 : HAL_PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">                         : HAL_PIXEL_FORMAT_RGB_565;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = format;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line">            *device = &amp;dev-&gt;device.common;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将缓冲区的内容显示在屏幕上</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fb_post</span><span class="params">(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(buffer) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fb_context_t</span>* ctx = (<span class="keyword">fb_context_t</span>*)dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(buffer);</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123; <span class="comment">//如果缓冲区是来自于fb设备的帧缓冲区</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base;</span><br><span class="line">        m-&gt;info.activate = FB_ACTIVATE_VBL;</span><br><span class="line">        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;<span class="comment">//直接调整y方向的分辨率偏移既可，不需要做任何拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == <span class="number">-1</span>) &#123;<span class="comment">//通过FBIOPUT_VSCREENINFO命令</span></span><br><span class="line">            ALOGE(<span class="string">"FBIOPUT_VSCREENINFO failed"</span>);                                       <span class="comment">//显示在屏幕上</span></span><br><span class="line">            m-&gt;base.unlock(&amp;m-&gt;base, buffer); </span><br><span class="line">            <span class="keyword">return</span> -errno;</span><br><span class="line">        &#125;</span><br><span class="line">        m-&gt;currentBuffer = buffer;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则是来自内存的缓冲区</span></span><br><span class="line">        <span class="comment">// If we can't do the page_flip, just copy the buffer to the front </span></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> use copybit HAL instead of memcpy</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span>* fb_vaddr;</span><br><span class="line">        <span class="keyword">void</span>* buffer_vaddr;</span><br><span class="line">        </span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer, </span><br><span class="line">                GRALLOC_USAGE_SW_WRITE_RARELY, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,</span><br><span class="line">                &amp;fb_vaddr);<span class="comment">//对帧缓冲区加锁</span></span><br><span class="line"></span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, buffer, </span><br><span class="line">                GRALLOC_USAGE_SW_READ_RARELY, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,</span><br><span class="line">                &amp;buffer_vaddr);<span class="comment">//对内存缓冲区加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres);<span class="comment">//需要将内存的缓冲区拷贝到fb的帧                              缓冲中</span></span><br><span class="line">        </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, buffer); </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，对于HAL层的模块分析就到这里了，下篇我们介绍下VSYNC信号相关的内容。</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p><a href="http://blog.csdn.net/luoshengyang/article/details/7747932" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/7747932</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SurfaceFlinger是GUI系统的核心，本篇将以自底向上的方式对其展开介绍。&lt;/p&gt;
&lt;h3 id=&quot;硬件层面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#硬件层面&quot;&gt;&lt;/a&gt; 硬件层面&lt;/h3&gt;
&lt;p&gt;Linux 内核提供了统一的fa
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GUI系统之SurfaceFlinger启动过程分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-gui-surfaceflinger-startup/"/>
    <id>http://esligh.github.io/[object Object]/aosp-gui-surfaceflinger-startup/</id>
    <published>2018-05-30T13:32:09.000Z</published>
    <updated>2019-03-16T08:06:05.342Z</updated>
    
    <content type="html"><![CDATA[<p>surfaceFlinger 在init.rc中是作为一个service存在的它声明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">graphics</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br></pre></td></tr></table></figure><p>从上面的内容可以看出，surfaceflinger所属的class为main，这和zygote时同级的。但它的启动并不需要带任何参数。同时由于surfaceflinger是service,说明它是单独的可执行程序，程序路径为/system/bin/surfaceflinger 运行在单独的进程里，另外，从最后一行也能看出sf重启时要重启zygote。</p><p>Surfaceflinger主程序对应的文件是frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp 所以我们从这个文件入手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></span><br><span class="line">    <span class="comment">// binder threads to 4.</span></span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);<span class="comment">//限制了binder线程的个数为4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();<span class="comment">//启动binder线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();<span class="comment">//创建SF对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();<span class="comment">//SF的初始化 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>);<span class="comment">//添加到SM中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run in this thread</span></span><br><span class="line">    flinger-&gt;run();<span class="comment">//sf运行起来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sf的主程序中做了以下事情：<br>1.初始binder的运行环境<br>2.创建Sf对象，并对其进行初始化<br>3.将Sf服务添加到ServiceManger中，以便向其他进程提供服务<br>4.SF在自己的线程中开始运行</p><p>SurfaceFlinger作为服务进程，必然需要通过Binder进行IPC通信，所以在一开始需要对Binder环境进行初始化。接着创建了SurfaceFlinger对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line">SurfaceFlinger::SurfaceFlinger()</span><br><span class="line">    :   BnSurfaceComposer(),</span><br><span class="line">        mTransactionFlags(<span class="number">0</span>),</span><br><span class="line">        mTransactionPending(<span class="literal">false</span>),</span><br><span class="line">        mAnimTransactionPending(<span class="literal">false</span>),</span><br><span class="line">        mLayersRemoved(<span class="literal">false</span>),</span><br><span class="line">        mRepaintEverything(<span class="number">0</span>),</span><br><span class="line">        mRenderEngine(<span class="literal">NULL</span>),</span><br><span class="line">        mBootTime(systemTime()),</span><br><span class="line">        mVisibleRegionsDirty(<span class="literal">false</span>),</span><br><span class="line">        mHwWorkListDirty(<span class="literal">false</span>),</span><br><span class="line">        mAnimCompositionPending(<span class="literal">false</span>),</span><br><span class="line">        mDebugRegion(<span class="number">0</span>),</span><br><span class="line">        mDebugDDMS(<span class="number">0</span>),</span><br><span class="line">        mDebugDisableHWC(<span class="number">0</span>),</span><br><span class="line">        mDebugDisableTransformHint(<span class="number">0</span>),</span><br><span class="line">        mDebugInSwapBuffers(<span class="number">0</span>),</span><br><span class="line">        mLastSwapBufferTime(<span class="number">0</span>),</span><br><span class="line">        mDebugInTransaction(<span class="number">0</span>),</span><br><span class="line">        mLastTransactionTime(<span class="number">0</span>),</span><br><span class="line">        mBootFinished(<span class="literal">false</span>),</span><br><span class="line">        mPrimaryHWVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">        mHWVsyncAvailable(<span class="literal">false</span>),</span><br><span class="line">        mDaltonize(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// debugging stuff...</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"ro.bq.gpu_to_cpu_unsupported"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mGpuToCpuSupported = !atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"debug.sf.showupdates"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mDebugRegion = atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(<span class="string">"debug.sf.ddms"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    mDebugDDMS = atoi(value);</span><br><span class="line">    <span class="keyword">if</span> (mDebugDDMS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!startDdmConnection()) &#123;</span><br><span class="line">            <span class="comment">// start failed, and DDMS debugging not enabled</span></span><br><span class="line">            mDebugDDMS = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法很简单，只是都其成员进行初始化，读取一些配置信息，比如是否开启DDMS的调试。<br>接下来通过init方法对该对象进行初始化。这个初始化过程会做大量比较重要的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line"><span class="comment">//sf的初始化方法</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize EGL for the default display</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);<span class="comment">//获取默认的显示设备</span></span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//为默认的显示设备初始EGL环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the H/W composer object.  There may or may not be an</span></span><br><span class="line">    <span class="comment">// actual hardware composer underneath.</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">            *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));<span class="comment">//创建合成对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// First try to get an ES2 config</span></span><br><span class="line">    err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(), EGL_OPENGL_ES2_BIT,</span><br><span class="line">            &amp;mEGLConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// If ES2 fails, try ES1</span></span><br><span class="line">        err = selectEGLConfig(mEGLDisplay, mHwc-&gt;getVisualID(),</span><br><span class="line">                EGL_OPENGL_ES_BIT, &amp;mEGLConfig);</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line">    EGLint r,g,b,a;</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_RED_SIZE,   &amp;r);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_GREEN_SIZE, &amp;g);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_BLUE_SIZE,  &amp;b);</span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig, EGL_ALPHA_SIZE, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a RenderEngine for the given display / config (can't fail)</span></span><br><span class="line">    mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);<span class="comment">//通过给定的设备创建渲染引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// retrieve the EGL context that was selected/created</span></span><br><span class="line">    mEGLContext = mRenderEngine-&gt;getEGLContext();<span class="comment">//获取EGL context</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out which format we got</span></span><br><span class="line">    eglGetConfigAttrib(mEGLDisplay, mEGLConfig,</span><br><span class="line">            EGL_NATIVE_VISUAL_ID, &amp;mEGLNativeVisualId);</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT,</span><br><span class="line">            <span class="string">"couldn't create EGLContext"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize our non-virtual displays</span></span><br><span class="line">  <span class="comment">//初始化所有的非虚拟显示设备</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        <span class="comment">// set-up the displays that are already connected</span></span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            <span class="comment">// All non-virtual displays are currently considered secure.</span></span><br><span class="line">            <span class="keyword">bool</span> isSecure = <span class="literal">true</span>;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line">          <span class="comment">//为显示设备创建BufferQueue用来管理其帧缓冲区 并通过FramebufferSurface进行管理</span></span><br><span class="line">            sp&lt;BufferQueue&gt; bq = <span class="keyword">new</span> BufferQueue(<span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs = <span class="keyword">new</span> FramebufferSurface(*mHwc, i, bq);</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                    type, allocateHwcDisplayId(type), isSecure, token,</span><br><span class="line">                    fbs, bq,</span><br><span class="line">                    mEGLConfig);<span class="comment">//为每个实体设备创建显示设备对象</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> currently we don't get blank/unblank requests</span></span><br><span class="line">                <span class="comment">// for displays other than the main display, so we always</span></span><br><span class="line">                <span class="comment">// assume a connected display is unblanked.</span></span><br><span class="line">                ALOGD(<span class="string">"marking display %d as acquired/unblanked"</span>, i);</span><br><span class="line">                hw-&gt;acquireScreen();</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make the GLContext current so that we can create textures when creating Layers</span></span><br><span class="line">    <span class="comment">// (which may happens before we render something)</span></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<span class="comment">//将EGL context和默认的显示设备关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>);<span class="comment">//创建绘图延时对象</span></span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);<span class="comment">//负责管理绘图延时Vsync信号</span></span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">false</span>);<span class="comment">//创建合成延时对象</span></span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);<span class="comment">//负责管理合成延时Vsync信号</span></span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line"></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">     ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在init方法中，sf做了以下的事：<br>1.为默认的显示设备初始EGL环境<br>2.创建合成对象<br>3.初始化所有的非虚拟显示设备<br>4.创建绘图延时Vysnc源 及 合成延时Vysnc源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);<span class="comment">//为sf的vsync信号注册事件回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是在main方法中创建的SurfaceFlinger是个强引用对象，所以在第一次调用同时也会会触发onFirstRef方法，这个方法会对SF的mEventQueue成员进行初始化。它是一个MessageQueue对象，负责SF的消息管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    mEventQueue.init(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::init(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">&#123;</span><br><span class="line">    mFlinger = flinger;<span class="comment">//持有sf的引用</span></span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">true</span>);<span class="comment">//为其创建一个Looper对象</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(*<span class="keyword">this</span>);<span class="comment">//创建Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用sf的run方法，这个方法会进入一个循环，不断等待消息的到来并进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::run() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::waitForEvent() &#123;</span><br><span class="line">    mEventQueue.waitMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="line"><span class="keyword">void</span> MessageQueue::waitMessage() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        <span class="keyword">int32_t</span> ret = mLooper-&gt;pollOnce(<span class="number">-1</span>);<span class="comment">//内部会调用MessageQueue的handleMessage方法对消息进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                ALOGE(<span class="string">"ALOOPER_POLL_ERROR"</span>);</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="comment">// timeout (should not happen)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// should not happen</span></span><br><span class="line">                ALOGE(<span class="string">"Looper::pollOnce() returned unknown status %d"</span>, ret);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过消息的handler对消息进行处理</span></span><br><span class="line"><span class="keyword">void</span> MessageBase::handleMessage(<span class="keyword">const</span> Message&amp;) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handler();</span><br><span class="line">    barrier.open();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SF的消息来源有两种，一个是Vsync信号，这是通过注册的cb_eventReceiver事件回调来处理的，另一种可能是应用进程或者说客户端的消息，比如创建Layer的请求，就是通过发送消息的方式来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"><span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;<span class="comment">//继承子messagbase</span></span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;<span class="comment">//实现了handler 这个方法用于接收方处理消息</span></span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;surfaceFlinger 在init.rc中是作为一个service存在的它声明如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/android-libray-retrofit-src/"/>
    <id>http://esligh.github.io/[object Object]/android-libray-retrofit-src/</id>
    <published>2018-05-21T03:26:05.000Z</published>
    <updated>2019-03-17T03:59:04.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="retrofit源码分析"><a class="markdownIt-Anchor" href="#retrofit源码分析"></a> Retrofit源码分析</h3><p>基于Retrofit2.1.的源码分析，Retrofit的用例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.example.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyApi</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">'/xx/xx'</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyApi api = retrofit.create(MyApi.class);</span><br><span class="line">Response&lt;User&gt; user = api.getUser().execute();</span><br></pre></td></tr></table></figure><h3 id="参数配置"><a class="markdownIt-Anchor" href="#参数配置"></a> 参数配置</h3><p>Retrofit使用了Builder的方式来配置参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Retrofit配置的参数：</p><p><font color="#0ff">platform</font>指定了Retrofit使用的平台，可以为Android或者Java8。在不同平台使用了不同的callAdapter以及CallbackExecutor，前者负责转换OkHttpCall为该平台下的Call请求，CallbackExecutor负责将请求投递出去。</p><p><font color="#0ff">callFactory</font> 即Call的工厂类，通过该工厂类可以生成Call对象,这个Call是什么呢？它如下描述所说</p><blockquote><p>A call is a request that has been prepared for execution，A call can be canceled. As this object represents a single request/response pair (stream), it cannot be executed twice</p></blockquote><p>Call封装了我们的HTTP请求，它可以被执行调用并返回结果，这样使得http请求对外界来说是透明的，它也是个请求/响应对，Retrofit默认使用OkHttpClient作为其CallFactory。</p><p><font color="#0ff">baseUrl</font> 是Http请求的基址，在接口方法中指定的相对url和该字段拼接为一个完整的url，如示例中的https://api.example.com/</p><p><font color="#0ff">converterFactories</font> 请求结果的转换器，通过该转换器可以将请求的结果转换成我们想要的数据格式或者对象。这是一个集合，可以添加多个转换器，接口方法根据其返回类型决定使用哪个转换器。</p><p><font color="#0ff">adapterFactories</font> 请求适配器用来将生成的请求转换成平台需要的请求对象。</p><h3 id="生成调用请求"><a class="markdownIt-Anchor" href="#生成调用请求"></a> 生成调用请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为Service接口类动态生成代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//接口方法的调用最终会通过代理对象来完成请求对象的生成</span></span><br><span class="line">                ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">                OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">                <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create是retrofit最为精妙的部分，它结合了动态代理可以为每个接口方法生成对应的请求，事实上，这会经过以下几步完成：</p><ol><li>根据调用的method方法来生成ServiceMethod，ServiceMethod是经过解析后的对象，它根据Method方法的注解来生成了一些创建OKHttpCall所需的信息。</li><li>结合解析后的Method对象即ServiceMethod和用户传递的方法参数生成OkHttpCall这是Retroift默认的请求对象</li><li>根据Method的返回类型ServiceMethod为Method创建适当的CallAdapter，通过该Adapter可以将创建的OkHttpCall转换成我们需要的Call请求。</li></ol><h3 id="针对接口方法生成servicemethod"><a class="markdownIt-Anchor" href="#针对接口方法生成servicemethod"></a> 针对接口方法生成ServiceMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServieMethod也是使用build模式来构建</span></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">    <span class="keyword">this</span>.method = method;<span class="comment">//对应的Service方法</span></span><br><span class="line">    <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();<span class="comment">//方法的注解</span></span><br><span class="line">    <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();<span class="comment">//参数类型</span></span><br><span class="line">    <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();<span class="comment">//参数注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为Service Method生成描述对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    callAdapter = createCallAdapter();<span class="comment">//为方法的请求生成相应的适配器</span></span><br><span class="line">    responseType = callAdapter.responseType();<span class="comment">//响应类型</span></span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">        + Utils.getRawType(responseType).getName()</span><br><span class="line">        + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    responseConverter = createResponseConverter();<span class="comment">//创建响应转换器</span></span><br><span class="line">    <span class="comment">//解析方法注解</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据解析结果得到的httpMethod不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123; <span class="comment">//multiPart注解必需要body的请求</span></span><br><span class="line">                <span class="keyword">throw</span> methodError(</span><br><span class="line">                    <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;<span class="comment">//FormUrlEncoded注解必需要body的请求</span></span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">                + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">    parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        Type parameterType = parameterTypes[p];</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">                parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">        <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析注解参数的值</span></span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有设置相对url 则需要通过@Url指定</span></span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是FormUrlEncoded或者MultiPart注解 就不需要@Body注解</span></span><br><span class="line">    <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果提交Form需要至少一个@Filed注解</span></span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是MultiPart需要至少一个@Part</span></span><br><span class="line">    <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为接口方法创建ServiceMethod对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成Method对应的CallAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type returnType = method.getGenericReturnType();<span class="comment">//取到返回类型</span></span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;<span class="comment">//返回类型不能为空</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();<span class="comment">//取到方法的注解</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="comment">//根据返回类型和注解返回相应的CallAdapter,这个CallAdapter用来将OkHttpCall转换为相应平台下的网络请求执行器</span></span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成Method对应的ResponseConverter,它负责将请求的结果进行格式转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();<span class="comment">//获取注解</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转由retrofit处理，因为转换器都配置在这里</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据返回类型和注解取到转换器，skipPast为null</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从converter集合列表中找到满足要求的转换器就返回，这里需要注意遍历是从集合首部开始，也就是说如果有两//个满足要求的转换器，先添加的转换器先匹配到。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//未找到要求的抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析Method注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;<span class="comment">//解析@DELETE注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;<span class="comment">//解析@GET注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;<span class="comment">//解析@HEAD注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Void.class.equals(responseType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;<span class="comment">//解析@PATCH注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;<span class="comment">//解析@POST注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;<span class="comment">//解析@PUT注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;<span class="comment">//解析@OPTIONS注解</span></span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"OPTIONS"</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">        <span class="comment">//解析@HTTP注解，表示一个自定义的HTTP请求，如：</span></span><br><span class="line">        <span class="comment">// @HTTP(method = "GET", path = "xxx/", hasBody = false)</span></span><br><span class="line">        HTTP http = (HTTP) annotation;</span><br><span class="line">        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">        <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        headers = parseHeaders(headersToParse);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">        <span class="comment">//解析@Multipart 表示请求体是多部分的。 每一部分作为一个参数,且用Part注解声明</span></span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isMultipart = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">        <span class="comment">//解析FormUrlEncoded，表示请求正文将使用表单网址编码。使用FormUrlEncoded注解的请求将具”application / x-www-form-urlencoded” MIME类型</span></span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Only one HTTP method is allowed. Found: %s and %s."</span>,</span><br><span class="line">        <span class="keyword">this</span>.httpMethod, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.httpMethod = httpMethod;<span class="comment">//HTTP method 只能有一个</span></span><br><span class="line">    <span class="keyword">this</span>.hasBody = hasBody;<span class="comment">//是否有body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;<span class="comment">//注解对应的参数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">    <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        String queryParams = value.substring(question + <span class="number">1</span>);</span><br><span class="line">        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(<span class="string">"URL query string \"%s\" must not have replace block. "</span></span><br><span class="line">                + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = value;<span class="comment">//相对url</span></span><br><span class="line">    <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);<span class="comment">//相对url中包含的请求参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http请求的创建"><a class="markdownIt-Anchor" href="#http请求的创建"></a> HTTP请求的创建</h3><p>根据ServiceMethod创建OkHttpCall对象，这个代表一个http请求。这个OkHttpCall是Retrofit默认使用的请求对象，如果配置了callAdapterFactory则会通过相应的适配器工厂将该Call请求转换成我们需要的请求对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;<span class="comment">//service 接口方法的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;<span class="comment">//网络请求调用的参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;<span class="comment">//实际进行网络请求的的调用对象</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure; <span class="comment">// Either a RuntimeException or IOException.</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>前面我们知道Retrofit在配置过程中 即build时为Retrofit配置默认的CallAdapterFactory，这个是根据PlatForm来决定的，这里我们看看Android平台下它是怎样的一个Adapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回默认的回调执行器</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Android平台下默认的请求适配工厂</span></span><br><span class="line">    <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        <span class="comment">//这里通过回调执行器来构造请求适配工厂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果回调执行器 用来将请求结果投递到主线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Android使用了ExecutorCallAdapterFactory，默认的callbackExecutor使用了MainThreadExecutor，它是一个回调执行器，用来将请求结果投递给主线程的，使用了Handler来投递Runable的方式来返回结果。接下来我们就重点分析下这个ExecutorCallAdapterFactory的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Retrofit使用get接口从工厂实例中取到CallAdapter</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor; <span class="comment">//回调执行器，负责请求结果回调</span></span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;<span class="comment">//委托对象，这个对象负责HTTP请求的</span></span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步的请求方式</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//回调执行器将结果回调给用户</span></span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//同步的请求方式</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们分析了为对应的接口方法生成ServiceMethod对象时，同时会为该对象指定一个CallAdapter，这个CallAdapter负责接口方法对应的请求及结果的回调，它是通过Retrofit的callAdapter来获取的，实际上是CallAdapterFactory的get接口从工厂实例中取到CallAdapter，CallAdapter只是一个接口，这里直接创建接口实例对象，其最重要的方法为adapt将请求的Call转换为平台下需要的call，这里我们看到它构造了ExecutorCallbackCall对象。</p><p>Http请求是委托给了adapt参数传递过来的Call，它是OkHttpCall负责HTTP请求的。Retrofit支持同步和异步的请求方式，对于异步的请求我们需要回调告诉用户请求结果成功与否，这是通过回调执行器来完成的。这里我们可以看到在CallBack的onResponse中通过callbackExecutor的execute投递请求结果，实际上是通过handler来进行的。这里总共有两个CallBack,第一个是用户传递给enqueue方法的，用户通过这个回调得到请求响应，第二个是用来响应委托请求的，而回调执行器就是在这两个接口之前负责线程切换。</p><p>对于同步的请求方式，就很简单了，它不需要回调调用后直接返回响应结果Response，但需要注意同步方式需在子线程使用。</p><h3 id="请求过程"><a class="markdownIt-Anchor" href="#请求过程"></a> 请求过程</h3><p>从CallAdapter中了解到，HTTP的请求是委托给了OkHttpCall的，因此下面我们需要进一步了解OkHttpCall是如何完成http请求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;<span class="comment">//接口方法对应的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;<span class="comment">//请求参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;<span class="comment">//元请求对象 它才是实际上进行http请求的</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure; <span class="comment">// Either a RuntimeException or IOException.</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从OkHttpCall的类结构我们大致了解OkHttpCall，它负责完成http请求则需要知道接口方法完成HTTP请求的参数以及HTTP请求的一些配置信息，因此我们需要serviceMethod和args，同时由于OkHttpCall它也是一个Call，我们需要控制请求过程，比如发起请求和取消请求。而rawCall看起来是负责OkHttpCall内部的http请求。我们继续看看execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http的异步请求过程</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要加锁控制</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          call = rawCall = createRawCall();<span class="comment">//创建一个元请求</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          failure = creationFailure = t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callback.onFailure(<span class="keyword">this</span>, failure);<span class="comment">//失败回调</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();<span class="comment">//取消请求的回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过okhttp3完成的请求过程并通过回调相应</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          response = parseResponse(rawResponse);<span class="comment">//解析相应结果</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);<span class="comment">//通过callback回调给调用者</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步请求过程</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">                creationFailure = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上进行请求的Call是通过createRawCall创建的，我们看看它的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = serviceMethod.toRequest(args);</span><br><span class="line">    okhttp3.Call call = serviceMethod.callFactory.newCall(request);</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到createRawCall是通过callFactory来创建实际请求的Call的，这个callFactory是在Retrofit中进行配置的，Retrofit倾向于使用OkHttp，它提供了client接口来配置OkHttpClient,它是一个基于OkHttp的call Factory，当然Retrofit同样支持其他的请求库，这也是它为什么会有callFactory的原因。我们完全可以封装HttpUrlConnection作为Retrofit的Call Factory，并通过builder的callFactory方法进行配置，它同volley一样是可以配置自身的请求库的，从这个角度来说Retrofit是比较开放和包容的library。这里我就不继续分析OkHttpClient具体的请求过程了，在介绍OkHttp时再做介绍，感兴趣的童鞋可以自行查看。</p><h3 id="请求结果的转换"><a class="markdownIt-Anchor" href="#请求结果的转换"></a> 请求结果的转换</h3><p>在上一部分内容中请求的结果最终是送给parseResponse进行处理的，从名称来看它负责解析响应的内容。我们看看它的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();<span class="comment">//得到ResponseBody</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();<span class="comment">//得到响应码</span></span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">        ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">        <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">      <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里对请求结果进行转换</span></span><br><span class="line">      T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">      <span class="comment">// a runtime exception.</span></span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>paserResponse通过请求响应rawResponse构造Response，这里面首先取到响应的ResponseBody，然后构造一个body为空的Response，这个Response只有状态，为什么这么做可能是因为转换后的Response本身就包含了响应内容的，在rawResponse再包含相同的数据传递就没必要了，尤其是当数据内容较大时。随后会根据得到的响应码来做不同的处理，最终会通过Response的success或者error构造Response对象返回给调用者。在最后调用Response的success之前会调用serviceMethod的toResponse对响应内容进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Builds a method return value from an HTTP response body. */</span></span><br><span class="line"> <span class="function">R <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到ServiceMethod的toResponse实际上是通过我们配置的转换器调用convert来完成数据转换的，这里就是将ResponseBody转换成接口方法的返回类型。Retrofit内置了几种转换器，它是通过BuiltInConverters来实现的，这里看看最常用的一种转换器的实现即将ResponseBody转换为Gson对象，实际上我们为Retrofit配置的Converter Factory支持请求和响应的转换，这里我们看看响应转换即GsonResponseBodyConverter的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonResponseBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter.read(jsonReader);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换是通过ResponseBody的字符流来构造JsonReader对象来完成的，具体过程就不分析了。</p><p>到这里我们基本上就分析完Retrofit的结构了，从整体的结构来说Retrofit的架构比较简单和直接，代码结构也非常清晰和易读，这是一个优秀框架难得的部分。内部使用了大量的设计模式来解耦，如工厂模式，代理模式，以及装饰模式，适配模式等等，这些设计模式带来的优势也是非常明显的，既使得代码结构清晰，也增强了可拓展性。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>Retrofit本质上是一个Restful API的网络请求库，它将http请求封装成接口，通过注解的方式来修饰方法和参数以配置Http请求，内部通过动态代理来生成Http请求的Call对象，生成过程首先通过解析接口方法得到ServiceMethod对象并缓存到Map中，<br>通过该对象构造一个OkHttpCall，这个负责http的请求，随后通过callAdapter将该请求进行封装和适配以满足PlatForm的要求，在这个过程中异步请求会将Call和callbackExecutor关联起来，以在请求后将结果通过回调执行器投递给调用者。请求完成后通过配置的转换器将响应内容转换为需要的格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;retrofit源码分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#retrofit源码分析&quot;&gt;&lt;/a&gt; Retrofit源码分析&lt;/h3&gt;
&lt;p&gt;基于Retrofit2.1.的源码分析，Retrofit的用例如下：&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="Android Library" scheme="http://esligh.github.io/categories/Android-Library/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ANR分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/anr-analysis/"/>
    <id>http://esligh.github.io/[object Object]/anr-analysis/</id>
    <published>2018-04-19T13:19:00.000Z</published>
    <updated>2019-03-17T01:20:53.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anr问题分析"><a class="markdownIt-Anchor" href="#anr问题分析"></a> ANR问题分析</h2><p>在Android开发的bug调试过程中，ANR算是最让开发者头疼的一种情况，一方面是因为导致ANR发生的原因很多，另一个方面ANR不像一般的BUG可能又会非常明显异常堆栈，最重要的一方面也是因为大多数ANR发生时并没有什么规律可寻，因此也不好重现。本篇笔者将对ANR做一个全面的介绍，并为排除ANR提出可行的方案。</p><h3 id="anr的检测机制"><a class="markdownIt-Anchor" href="#anr的检测机制"></a> ANR的检测机制</h3><p>Android对于ANR有多个方面的监测机制：</p><ol><li>Input事件5秒内未处理超时导致ANR</li><li>Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。</li><li>BroadCast事件处理中如果执行时间超过10秒导致ANR</li></ol><p>本篇不打算分析Anroid系统在以上的几种检测机制的实现过程。我们只需要知道ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对操作的响应;否则，就可以认为应用程序主线程失去响应能力。</p><h3 id="anr-日志"><a class="markdownIt-Anchor" href="#anr-日志"></a> ANR 日志</h3><p>CPU日志</p><ol><li>ANR发生的进程</li><li>ANR发生的原因</li><li>CPU负载</li><li>各进程的CPU使用率</li><li>CPU使用汇总</li></ol><p>首先发生ANR时，系统会对该异常做出响应，并在data/anr/traces.txt生成相应的信息。这些信息打印了发生ANR时相关进程堆栈状态，我们正是基于此来分析发生ANR发生的原因。下面我们看一组Anr发生时的logcat日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E/SensorsHal(  <span class="number">406</span>): poll() failed (Interrupted system call)</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): ANR in at.smarthome.hcomm  </span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): PID: <span class="number">584</span></span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=<span class="number">0x50000014</span> (has extras) &#125;</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): Load: <span class="number">2.04</span> / <span class="number">0.73</span> / <span class="number">0.26</span></span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): CPU usage from <span class="number">5849</span>ms to <span class="number">0</span>ms ago:</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">8.7</span>% <span class="number">725</span>/wpa_supplicant: <span class="number">0.1</span>% user + <span class="number">8.5</span>% kernel / faults: <span class="number">1</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">1.5</span>% <span class="number">406</span>/system_server: <span class="number">0.6</span>% user + <span class="number">0.8</span>% kernel / faults: <span class="number">118</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">1.5</span>% <span class="number">812</span>/RTW_CMD_THREAD: <span class="number">0</span>% user + <span class="number">1.5</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">1</span>% <span class="number">950</span>/com.tt.ttt: <span class="number">0.3</span>% user + <span class="number">0.6</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">584</span>/at.xxx.xxx: <span class="number">0.1</span>% user + <span class="number">0</span>% kernel / faults: <span class="number">29</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">20</span>/kconsole: <span class="number">0</span>% user + <span class="number">0.1</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0</span>% <span class="number">25</span>/irq/<span class="number">58</span>-rk30-adc: <span class="number">0</span>% user + <span class="number">0</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">28</span>/fb-vsync: <span class="number">0</span>% user + <span class="number">0.1</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">30</span>/cfinteractive: <span class="number">0</span>% user + <span class="number">0.1</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">462</span>/com.android.systemui: <span class="number">0.1</span>% user + <span class="number">0</span>% kernel / faults: <span class="number">1</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">0.1</span>% <span class="number">640</span>/xx.yyyy.yyyy: <span class="number">0</span>% user + <span class="number">0.1</span>% kernel / faults: <span class="number">12</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): <span class="number">3.1</span>% TOTAL: <span class="number">0.5</span>% user + <span class="number">2.5</span>% kernel + <span class="number">0</span>% softirq</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): CPU usage from <span class="number">1858</span>ms to <span class="number">2367</span>ms later:</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">3.8</span>% <span class="number">406</span>/system_server: <span class="number">0</span>% user + <span class="number">3.8</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):     <span class="number">5.7</span>% <span class="number">421</span>/ActivityManager: <span class="number">1.9</span>% user + <span class="number">3.8</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">1.4</span>% <span class="number">97</span>/surfaceflinger: <span class="number">0</span>% user + <span class="number">1.4</span>% kernel</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>):   <span class="number">1.6</span>% <span class="number">640</span>/yy.yyyy.yyyy: <span class="number">1.6</span>% user + <span class="number">0</span>% kernel / faults: <span class="number">1</span> minor</span><br><span class="line">E/ActivityManager(  <span class="number">406</span>): <span class="number">0.5</span>% TOTAL: <span class="number">0</span>% user + <span class="number">0.5</span>% kernel</span><br></pre></td></tr></table></figure><p>从日志我们可以看到发生anr时的进程信息（包名和PID），以及发生ANR的原因，比如第一个的REASON表示在处理TIME_TICK广播消息超时。 意思是TIME_TICK是一个串行广播消息，在PID为584的进程中，执行BroadcastReceiver.onReceive()方法已经超过10秒，Load关键字表示了最近1分钟，5分钟，15分钟内CPU的负载分别是 2.04 / 0.73 / 0.26，最近1分钟内的负载为2.04，可以理解为CPU最近1分钟平均有2.04个任务处理，这样的CPU负载并不算高，那么发生ANR的具体原因应该不是因为CPU负载过重引起，可能是由于等待IO引起的。CPU关键字后面的是发生ANR时各进程的CPU负载统计</p><h3 id="经验法则"><a class="markdownIt-Anchor" href="#经验法则"></a> 经验法则</h3><ol><li>如果iowait较高，则倾向考虑是由io读写阻塞导致的</li><li>CPU负载较高，考虑程序中是否哪里由做频繁的运算，比如ACTION_MOVE中做一些耗时的运算或者引起频繁GC导致CPU一直被占用这时候再响应Input是就会出现ANR。</li><li>内存泄漏导致的内存不足问题，此时Dalvik线程为VMWAIT状态。</li><li>死锁导致的ANR</li><li></li></ol><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p><a href="https://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">https://duanqz.github.io/2015-10-12-ANR-Analysis</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;anr问题分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#anr问题分析&quot;&gt;&lt;/a&gt; ANR问题分析&lt;/h2&gt;
&lt;p&gt;在Android开发的bug调试过程中，ANR算是最让开发者头疼的一种情况，一方面是因为导致ANR发生的原因很多，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android 属性动画原理</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-animation2-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-animation2-src/</id>
    <published>2018-03-20T13:31:42.000Z</published>
    <updated>2019-03-16T08:03:00.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>属性动画是在Android3.0提供的一套全新的动画Api，它和传统的补间动画相比有更大的灵活性。比如我们要使用动画更新一个button的宽度，如果使用补间动画ScaleAnimation那么最后放大后的button是变形的，而使用属性动画实现不存在这样的问题，还有最大的区别在于补间动画不会真正的改变view的属性，而属性动画会。</p><p>本篇将从源码角度对属性动画进行分析</p><h3 id="valueanimation"><a class="markdownIt-Anchor" href="#valueanimation"></a> ValueAnimation</h3><p>关于属性动画，我们最常用的类便是ValueAnimation和ObjectAnimator，其中ValueAnimation是ObjectAnimator的父类。它是属性动画实现的核心，所以我们先来看看ValueAnimation的实现</p><p>####继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueAnimator继承自Animator，Animator是属性动画最基本的类，它是一个抽象类，定义了一些属性动画的接口，如start，cancel,setduration，addListener等等，ValueAnimator一般是通过使用其静态的of方法来构造，这里我们看看ofInt的实现,其他of方法实现类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    ValueAnimator anim = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    anim.setIntValues(values);</span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ofInt构造ValueAnimator实例并通过setIntValues为其设置初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">        setValues(PropertyValuesHolder.ofInt(<span class="string">""</span>, values));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = mValues[<span class="number">0</span>];</span><br><span class="line">        valuesHolder.setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mValues是一个PropertyValuesHolder数组，从名称来看PropertyValuesHolder是属性和值的持有者，它维护属性和值的相关信息。开始mValues是null，继续调用setValues，同时使用PropertyValuesHolder的ofInt方法构造PropertyValuesHolder实例作为参数，属性名为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numValues = values.length;</span><br><span class="line">    mValues = values;</span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mValuesMap是一个Map,key值时属性名，value是PropertyValuesHolder，对于每一个属性的PropertyValuesHolder都会保存在mValuesMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPlayingBackwards = playBackwards;</span><br><span class="line">    mCurrentIteration = <span class="number">0</span>;</span><br><span class="line">    mPlayingState = STOPPED;</span><br><span class="line">    mStarted = <span class="keyword">true</span>;</span><br><span class="line">    mStartedDelay = <span class="keyword">false</span>;</span><br><span class="line">    mPaused = <span class="keyword">false</span>;</span><br><span class="line">    AnimationHandler animationHandler = getOrCreateAnimationHandler();</span><br><span class="line">    animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">        setCurrentPlayTime(<span class="number">0</span>);</span><br><span class="line">        mPlayingState = STOPPED;</span><br><span class="line">        mRunning = <span class="keyword">true</span>;</span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">    animationHandler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueAnimation的启动默认调用了内部的private的start方法，参数playBackwards为false,表示动画是否反向执行。随后通过getOrCreateAnimationHandler创建一个AnimationHandler，然后将当前动画添加到其内部的等待队列mPendingAnimations中，这个animationHandler成员是个AnimationHandler，它是ValueAnimation内部类，如果未设置mStartDelay，则开始执行动画第一帧，随后通过notifyStartListeners通知动画Listener动画启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">    initAnimation();<span class="comment">//初始化动画</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = AnimationUtils.currentAnimationTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayingState != RUNNING) &#123;</span><br><span class="line">        mSeekTime = playTime;</span><br><span class="line">        mPlayingState = SEEKED;</span><br><span class="line">    &#125;</span><br><span class="line">    mStartTime = currentTime - playTime;<span class="comment">//计算动画执行的开始时间</span></span><br><span class="line">    doAnimationFrame(currentTime);<span class="comment">//执行动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setCurrentPlayTime是执行playTime指定的时间点的动画，这个playTime是在[0,duration]的区间内。在setCurrentPlayTime需要先初始化动画，然后设置mSeekTime为0，执行状态为SEEKED，随后通过doAnimationFrame执行动画。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].init();</span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画只需要初始化一次，主要是对PropertyValuesHolder进行初始化，后面我们在看关于PropertyValuesHolder的初始化部分。初始化通过mInitialized标记控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingState == STOPPED) &#123;</span><br><span class="line">        mPlayingState = RUNNING;<span class="comment">//设置播放状态为RUNNING</span></span><br><span class="line">        <span class="keyword">if</span> (mSeekTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mStartTime = frameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStartTime = frameTime - mSeekTime;</span><br><span class="line">            <span class="comment">// Now that we're playing, reset the seek time</span></span><br><span class="line">            mSeekTime = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = frameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;</span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">    <span class="keyword">return</span> animationFrame(currentTime);<span class="comment">//如果动画结束了就返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mSeekTime为0，mStartTime为frameTime值，即当前的时间值。如果mPaused表示暂停动画中，返回false，mResumed为true表示动画继续执行，此时根据mPauseTime重新计算mStartTime，即动画的开始执行时间，随后取frameTime和mStartTime的最大值传递给animationFrame进一步执行动画。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (mPlayingState) &#123;</span><br><span class="line">    <span class="keyword">case</span> RUNNING:</span><br><span class="line">    <span class="keyword">case</span> SEEKED:</span><br><span class="line">        <span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                ……    </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 done = <span class="keyword">true</span>;</span><br><span class="line">                fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        animateValue(fraction);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>animationFrame中首先根据mDuration计算fraction，fraction即时间流逝的百分比，它的值是客观均匀的，随后通过animateValue计算动画值，这个方法返回动画是否执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">    mCurrentFraction = fraction;</span><br><span class="line">    <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        mValues[i].calculateValue(fraction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">            mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过fraction和插值器计算动画插值，我们知道插值器是能够控制动画的执行速率，它根据fraction值计算，ValueAnimation中默认的插值器是AccelerateDecelerateInterpolator，随后通过PropertyValuesHolder的calculateValue根据插值计算动画值，这个动画值就是我们在of方法指定的区间内的值，最后通过onAnimatinoUpdate来通知动画值的更新。到这里我们的动画第一帧就算执行了，那么它如何连续执行呢？这就要靠AnimationHandler了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br></pre></td></tr></table></figure><p>其中AnimationHandler的说明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This custom, static handler handles the timing pulse that is shared by</span></span><br><span class="line"><span class="comment">* all active animations. This approach ensures that the setting of animation</span></span><br><span class="line"><span class="comment">* values will happen on the UI thread and that all animations will share</span></span><br><span class="line"><span class="comment">* the same times for calculating their values, which makes synchronizing</span></span><br><span class="line"><span class="comment">* animations possible.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The handler uses the Choreographer for executing periodic callbacks.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出AnimationHandler在线程内是由所有活动的动画共享的。它可以保证animation动画值设置操作发生在UI线程，而所有的动画将共享相同的相同值来计算它们自己的值以使动画同步执行。这个handler使用Choreographer来执行周期性的回调。这个Choreographer可以看做是一个Vsync信号的观察者，它为上层应用提供监听VSync信号的接口，应用程序根据该信号刷新UI。</p><p>在start的方法最后调用了AnimationHandler的start，我们看看它的内部如何实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimationHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleAnimation();<span class="comment">//在下一帧中安排动画</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">        doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性动画是的绘制是交给编舞者来处理绘制的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAnimationScheduled) &#123;</span><br><span class="line">            <span class="comment">//实际上是post一个Callback给编舞者 在垂直信号到来时这个Callback的run方法会执行</span></span><br><span class="line">            mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animationhandler是通过Choreographer来执行动画的，在start方法中调用scheduleAnimation添加当前AnimationHandler到Choreographer的回调队列中，它的类型为Choreographer.CALLBACK_ANIMATION，Choreographer在接收到VSync信号时会通知该回调也就是调用回调的run方法，这里就是执行doAnimationFrame方法，同时重置mAnimationScheduled。所以真正执行动画的是通过doAnimationFrame来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能有多组等待的动画，将他们启动并添加到活动列表中</span></span><br><span class="line">    <span class="keyword">while</span> (mPendingAnimations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ArrayList&lt;ValueAnimator&gt; pendingCopy =</span><br><span class="line">                (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</span><br><span class="line">        mPendingAnimations.clear();</span><br><span class="line">        <span class="keyword">int</span> count = pendingCopy.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = pendingCopy.get(i);</span><br><span class="line">            <span class="comment">// If the animation has a startDelay, place it on the delayed list</span></span><br><span class="line">            <span class="keyword">if</span> (anim.mStartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">                anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mDelayedAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里将活动动画添加到临时动画中 然后执行doAnimationFrame绘制一帧动画 </span></span><br><span class="line">    <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">        mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">        ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">        <span class="comment">//根据doAnimationFrame的返回值可以知道动画是否结束了</span></span><br><span class="line">        <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">            mEndingAnims.add(anim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mTmpAnimations.clear();<span class="comment">//清理添加的临时动画 这里为什么需要一个mTmpAnimations？</span></span><br><span class="line">    <span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">            mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mEndingAnims.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有活动的动画或者延时的动画就等待下次垂直信号安排下一次绘制</span></span><br><span class="line">    <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">        scheduleAnimation();<span class="comment">//再绘制下一帧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要执行的动画添加到活动列表中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    initAnimation();</span><br><span class="line">    handler.mAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span> &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Listeners were already notified in start() if startDelay is 0; this is</span></span><br><span class="line">        <span class="comment">// just for delayed animations</span></span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    handler.mAnimations.remove(<span class="keyword">this</span>);</span><br><span class="line">    handler.mPendingAnimations.remove(<span class="keyword">this</span>);</span><br><span class="line">    handler.mDelayedAnims.remove(<span class="keyword">this</span>);</span><br><span class="line">    mPlayingState = STOPPED;</span><br><span class="line">    mPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mStarted || mRunning) &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">            <span class="comment">// If it's not yet running, then start listeners weren't called. Call them now.</span></span><br><span class="line">            notifyStartListeners();</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">        <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">            tmpListeners.get(i).onAnimationEnd(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRunning = <span class="keyword">false</span>;</span><br><span class="line">    mStarted = <span class="keyword">false</span>;</span><br><span class="line">    mStartListenersCalled = <span class="keyword">false</span>;</span><br><span class="line">    mPlayingBackwards = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在doAnimationFrame中首先通过startAnimation将等待的动画启动，它其实将动画添加到活动的动画列表mAnimations并调用开始执行动画的回调。随后对于活动列表中的动画执行doAnimationFrame，它执行一帧动画。对于执行完成的动画调用endAnimation，它分别从活动列表，等待列表，延时列表中移除该动画实例。最后只要有活动的动画，就需要调用scheduleAnimation安排下一帧动画的执行。这样动画就能够连续执行了。</p><h3 id="propertyvaluesholder"><a class="markdownIt-Anchor" href="#propertyvaluesholder"></a> PropertyValuesHolder</h3><p>在ValueAnimation动画的执行过程中依赖于PropertyValuesHolder，只不过这时候的PropertyName为空，在整个流程中涉及到PropertyValuesHolder的有下面几个部分：</p><ol><li>在setValues中通过of方法实例化PropertyValuesHolder</li><li>在动画初始化initAnimation方法中调用其init方法</li><li>在animateValue中通过PropertyValuesHolder的calculateValue计算动画值</li></ol><p>下面就分别看看这些具体是如何实现的</p><h4 id="设置values"><a class="markdownIt-Anchor" href="#设置values"></a> 设置values</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPropertyValuesHolder</span> <span class="keyword">extends</span> <span class="title">PropertyValuesHolder</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(propertyName);</span><br><span class="line">        setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setIntValues(values);</span><br><span class="line">        mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PropertyValuesHolder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">    mKeyframeSet = KeyframeSet.ofInt(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KeyframeSet.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">    IntKeyframe keyframes[] = <span class="keyword">new</span> IntKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;</span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>);</span><br><span class="line">        keyframes[<span class="number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">1f</span>, values[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>, values[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;</span><br><span class="line">            keyframes[i] =</span><br><span class="line">                    (IntKeyframe) Keyframe.ofInt((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置的values最终是以KeyFrameSet的形式存在的，KeyframeSet实际上就是关键帧的值，包含了我们设置的值，以及<br>每个值对应的fraction。</p><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We already handle int and float automatically, but not their Object</span></span><br><span class="line">        <span class="comment">// equivalents</span></span><br><span class="line">        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :</span><br><span class="line">                (mValueType == Float.class) ? sFloatEvaluator :</span><br><span class="line">                <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// KeyframeSet knows how to evaluate the common types - only give it a custom</span></span><br><span class="line">        <span class="comment">// evaluator if one has been set on this class</span></span><br><span class="line">        mKeyframeSet.setEvaluator(mEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init实际上是为PropertyValuesHolder设置估值器，sIntEvaluator实际上就是整型的估值器，在计算动画值时使用，它的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startInt = startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算动画值"><a class="markdownIt-Anchor" href="#计算动画值"></a> 计算动画值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    mAnimatedValue = mKeyframeSet.getValue(fraction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123;<span class="comment">//关键帧数目为2的情况</span></span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;<span class="comment">//有插值器先计算插值</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(),</span><br><span class="line">                mLastKeyframe.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fraction &lt;= <span class="number">0f</span>) &#123;<span class="comment">//关键帧第一帧</span></span><br><span class="line">        <span class="keyword">final</span> Keyframe nextKeyframe = mKeyframes.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> prevFraction = mFirstKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) /</span><br><span class="line">            (nextKeyframe.getFraction() - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(),</span><br><span class="line">                nextKeyframe.getValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//关键帧最后一帧</span></span><br><span class="line">        <span class="keyword">final</span> Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = mLastKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) /</span><br><span class="line">            (mLastKeyframe.getFraction() - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),</span><br><span class="line">                mLastKeyframe.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他关键帧</span></span><br><span class="line">    Keyframe prevKeyframe = mFirstKeyframe;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;</span><br><span class="line">        Keyframe nextKeyframe = mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;</span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevFraction);</span><br><span class="line">            <span class="keyword">return</span> mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),</span><br><span class="line">                    nextKeyframe.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't reach here</span></span><br><span class="line">    <span class="keyword">return</span> mLastKeyframe.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画值最终是通过KeyFrameSet来计算的，我们通过of方法构造的KeyFrameSet,这里通过fraction来计算最终的动画值，fraction可能是经过插值器计算后的，对于关键帧数为2的最简单，直接通过估值器计算即可，startValue就是第一个关键帧的值，endValue就是最后一个关键帧。而当关键帧数目大于2的时候，需要这么计算，这里我举个例子比如ofInt(1,100,200),关键帧的数目为3，对应的KeyFrame分别为[0f,1],[0.5f,100],[1f,200]这里的0f,0.5f,1f分别是keyFrame对应的fraction。在getValue中根据fraction计算动画值时：</p><ol><li>如果此时fraction小于0.5，则根据估值器进行如下计算evaluate(intervalFraction，0,100);</li><li>如果fraction大于0.5则进行如下计算evaluate(intervalFraction，100,200)</li></ol><h3 id="objectanimation"><a class="markdownIt-Anchor" href="#objectanimation"></a> ObjectAnimation</h3><p>ObjectAnimator是ValueAnimation的子类，它实际上同ValueAnimation的区别在于，ObjectAnimation包含一个Target和PropertyName，可以在该Target上的Property上应用动画，这个Target不仅仅可以是View。只要Target在该PropertyName上具有setter和getter方法即可。在ObjectAnimation中重载了initAnimation和animateValue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="comment">// mValueType may change due to setter/getter setup; do this before calling super.init(),</span></span><br><span class="line">        <span class="comment">// which uses mValueType to set up the default type evaluator.</span></span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].setupSetterAndGetter(mTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.initAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectAnimation相比ValueAnimation会调用PropertyValuesHolder的setupSetterAndGetter方法，从名称上看应该是建立Target的对应属性的setter和getter方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupSetterAndGetter</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    Class targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (mSetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        setupSetter(targetClass);<span class="comment">//获取mSetter方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Keyframe kf : mKeyframeSet.mKeyframes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kf.hasValue()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                setupGetter(targetClass);</span><br><span class="line">                <span class="keyword">if</span> (mGetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Already logged the error - just return to avoid NPE</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                kf.setValue(mGetter.invoke(target));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取target对应属性的set方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupSetter</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, <span class="string">"set"</span>, mValueType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取target对应属性的get方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupGetter</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">    mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, <span class="string">"get"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PropertyValuesHolder.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">setupSetterOrGetter</span><span class="params">(Class targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">        HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        String prefix, Class valueType)</span> </span>&#123;</span><br><span class="line">    Method setterOrGetter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Have to lock property map prior to reading it, to guard against</span></span><br><span class="line">        <span class="comment">// another thread putting something in there after we've checked it</span></span><br><span class="line">        <span class="comment">// but before we've added an entry to it</span></span><br><span class="line">        mPropertyMapLock.writeLock().lock();</span><br><span class="line">        HashMap&lt;String, Method&gt; propertyMap = propertyMapMap.get(targetClass);</span><br><span class="line">        <span class="keyword">if</span> (propertyMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setterOrGetter = propertyMap.get(mPropertyName);<span class="comment">//从缓存中取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setterOrGetter == <span class="keyword">null</span>) &#123;<span class="comment">//没有的话，就从target中取</span></span><br><span class="line">            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);</span><br><span class="line">            <span class="keyword">if</span> (propertyMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                propertyMap = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();</span><br><span class="line">                propertyMapMap.put(targetClass, propertyMap);</span><br><span class="line">            &#125;</span><br><span class="line">            propertyMap.put(mPropertyName, setterOrGetter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mPropertyMapLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setterOrGetter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setupSetterOrGetter方法会通过getPropertyFunction获取属性对应的get或者set方法，获取到以后缓存到propertyMapMap中，propertyMapMap以target实例为key，以一个Map&lt;String,Method&gt;为value。这个Map是用于保存属性对应的Method，其中key就是属性的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectAnimator.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.animateValue(fraction);</span><br><span class="line">    <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        mValues[i].setAnimatedValue(mTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PropertyValuesHolder.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = getAnimatedValue();</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectAnimator的animateValue和ValueAnmiation的实现是不同的，ObjectAnimator会通过PropertyValuesHolder的setAnimatedValue方法为Target设置属性值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;属性动画是在Android3.0提供的一套全新的动画Api，它和传统的补间动画相比有更大的灵活性。比如我们要使用动画更新一个button的宽度，
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>android Tween动画原理</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-animation-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-animation-src/</id>
    <published>2018-03-12T13:41:50.000Z</published>
    <updated>2019-03-16T07:59:56.159Z</updated>
    
    <content type="html"><![CDATA[<p>Android提供了几种基本的动画：</p><ol><li>帧动画</li><li>补间动画</li><li>属性动画</li></ol><p>其中属性动画和补间动画比较常用，它们最大的区别在于补间动画并不会真正的改变View的属性，什么意思呢？比如通过补间动画将页面中的Button从左边移动到右边一段距离，如果此时点击Button，它不会对点击事件做出响应，这是因为button的作用区域(点击该区域依然可以触发click事件)依然在原来的位置，这是补间动画将其绘制在其原来的右边罢了。</p><p>本篇将首先从源码的角度对补间动画进行分析，属性动画会在下一篇中做介绍，至于补间动画的基本用法，这里就不多做介绍了。<br>在我们分析之前我们先提两个问题：</p><ol><li>动画是如何进行绘制的？</li><li>动画是怎么计算每一帧的画面的？即某一个时刻View的位置的？</li></ol><p>带着这两个问题，我们开始分析补间动画，这里首先从startAnimation开始分析，这是动画开始执行的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\core\java\android\view\View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">    setAnimation(animation);</span><br><span class="line">    invalidateParentCaches();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startAnimation中主要做了两件事，第一个就是通过setAnimation设置当前View的动画，然后通过invalidate重绘制View。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    mCurrentAnimation = animation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the screen is off assume the animation start time is now instead of</span></span><br><span class="line">        <span class="comment">// the next frame we draw. Keeping the START_ON_FIRST_FRAME start time</span></span><br><span class="line">        <span class="comment">// would cause the animation to start when the screen turns back on</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; !mAttachInfo.mScreenOn &amp;&amp;</span><br><span class="line">                animation.getStartTime() == Animation.START_ON_FIRST_FRAME) &#123;</span><br><span class="line">            animation.setStartTime(AnimationUtils.currentAnimationTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        animation.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setAnimation将animation保存在View的mCurrentAnimation以备使用。<br>接下来就是通过invalidate来重绘制View，这个我在专门的一篇中有所介绍，这里我简单说一下， invalidate实际上会从当前发起绘制的view开始向上寻找父View(ViewParent)，然后和其父View计算总的脏区域，父View再计算根据得到的脏区域计算和其父View的脏区域，这个操作一直到ViewRootImpl，即View层级树的顶部管理者，它会根据计算的脏区域触发Draw操作。也就是会走到performTraversals中，这个流程想必大家都清楚了。</p><p>View在绘制完自身的内容后，会通过dispatchDrawl来绘制其子View，动画也就是在此时进行绘制的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;<span class="comment">//子view的个数</span></span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;<span class="comment">//子view节点</span></span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);<span class="comment">//绘制子view</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[getChildDrawingOrder(count, i)];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchDraw中会通过遍历孩子节点并未其调用drawChild来绘制子View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    Transformation transformToApply = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Animation a = getAnimation();</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        more = drawAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">        concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">        <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        transformToApply = parent.getChildTransformation();</span><br><span class="line">    &#125; </span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (transformToApply != <span class="keyword">null</span> || alpha &lt; <span class="number">1</span> || !hasIdentityMatrix() ||</span><br><span class="line">        (mPrivateFlags3&amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transformToApply != <span class="keyword">null</span> || !childHasIdentityMatrix) &#123;</span><br><span class="line">            <span class="keyword">int</span> transX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> transY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">                transX = -sx;</span><br><span class="line">                transY = -sy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//动画的Transformation不为null</span></span><br><span class="line">            <span class="keyword">if</span> (transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useDisplayListProperties) &#123;</span><br><span class="line">                        displayList.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Undo the scroll translation, apply the</span></span><br><span class="line">                        <span class="comment">// transformation matrix,</span></span><br><span class="line">                        <span class="comment">// then redo the scroll translate to get the correct</span></span><br><span class="line">                        <span class="comment">// result.</span></span><br><span class="line">                        canvas.translate(-transX, -transY);</span><br><span class="line">                        canvas.concat(transformToApply.getMatrix());</span><br><span class="line">                        canvas.translate(transX, transY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取Transformation的alpha值</span></span><br><span class="line">                <span class="keyword">float</span> transformAlpha = transformToApply.getAlpha();</span><br><span class="line">                <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    alpha *= transformAlpha;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!childHasIdentityMatrix &amp;&amp; !useDisplayListProperties) &#123;</span><br><span class="line">                canvas.translate(-transX, -transY);</span><br><span class="line">                canvas.concat(getMatrix());</span><br><span class="line">                canvas.translate(transX, transY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View的这个draw方法同draw(Canvas)的那个方法不同，它只是被ViewGroupd的drawChild调用，在这个方法里，我们可以看到绘制动画的方法，首先通过getAnimation获取到我们在startAnimation中设置的动画，然后交给drawAnimation计算动画的Transformation，它被存放在transformToApply中，如果有动画执行那么transformToApply肯定不为null,这里concatMatrix未true表示动画会改变变换矩阵，比如ScaleAnimation会改变变换的Matrix，而AlpahAnimation不会改变，为true这种情况会对canvas做一些列变换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///frameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line">    Transformation invalidationTransform;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</span><br><span class="line">        a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>)</span><br><span class="line">            a.setListenerHandler(mAttachInfo.mHandler);</span><br><span class="line">        onAnimationStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line">    <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</span><br><span class="line">    <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">        &#125;</span><br><span class="line">        invalidationTransform = parent.mInvalidationTransformation;</span><br><span class="line">        a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        invalidationTransform = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE</span><br><span class="line">                    | ViewGroup.FLAG_ANIMATION_DONE)) == ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// The child need to draw an animation, potentially</span></span><br><span class="line">                <span class="comment">// offscreen, so</span></span><br><span class="line">                <span class="comment">// make sure we do not cancel invalidate requests</span></span><br><span class="line">                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                parent.invalidate(mLeft, mTop, mRight, mBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.mInvalidateRegion == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.mInvalidateRegion = <span class="keyword">new</span> RectF();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> RectF region = parent.mInvalidateRegion;</span><br><span class="line">            a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</span><br><span class="line">                    invalidationTransform);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The child need to draw an animation, potentially offscreen,</span></span><br><span class="line">            <span class="comment">// so</span></span><br><span class="line">            <span class="comment">// make sure we do not cancel invalidate requests</span></span><br><span class="line">            parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</span><br><span class="line">            parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</span><br><span class="line">                    top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是补间动画的核心处理方法，它首先对动画进行初始化initialize，接下来通过getTransformation计算动画的相关信息，并返回more,代表动画是否完成。如果是true表示还有动画需要执行，那么在最后会通过parent的invalidate重新发起绘制进行下一帧的绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">    mScaleFactor = scale;</span><br><span class="line">    <span class="keyword">return</span> getTransformation(currentTime, outTransformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartTime == -<span class="number">1</span>) &#123;</span><br><span class="line">        mStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startOffset = getStartOffset();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> duration = mDuration;</span><br><span class="line">    <span class="keyword">float</span> normalizedTime;</span><br><span class="line">    <span class="keyword">if</span> (duration != <span class="number">0</span>) &#123;</span><br><span class="line">        normalizedTime = ((<span class="keyword">float</span>) (currentTime - (mStartTime + startOffset))) /</span><br><span class="line">                (<span class="keyword">float</span>) duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// time is a step-change with a zero duration</span></span><br><span class="line">        normalizedTime = currentTime &lt; mStartTime ? <span class="number">0.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span>;</span><br><span class="line">    mMore = !expired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">            fireAnimationStart();</span><br><span class="line">            mStarted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (USE_CLOSEGUARD) &#123;</span><br><span class="line">                guard.open(<span class="string">"cancel or detach or getTransformation"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCycleFlip) &#123;</span><br><span class="line">            normalizedTime = <span class="number">1.0f</span> - normalizedTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">        applyTransformation(interpolatedTime, outTransformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRepeatCount == mRepeated) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mEnded) &#123;</span><br><span class="line">                mEnded = <span class="keyword">true</span>;</span><br><span class="line">                guard.close();</span><br><span class="line">                fireAnimationEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRepeatCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mRepeated++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                mCycleFlip = !mCycleFlip;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mStartTime = -<span class="number">1</span>;</span><br><span class="line">            mMore = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            fireAnimationRepeat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mMore &amp;&amp; mOneMoreTime) &#123;</span><br><span class="line">        mOneMoreTime = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mMore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getTransformation会根据当前时间和动画的持续时间执行时间流逝的进度，该进度随时间的流逝均匀的增加，如果该进度在0和1之间那么说明动画还在执行，如果动画此时还未开始会通过fireAnimationStart回调动画开始的回调，随后通过getInterpolation根据进度和插值器计算插值，插值和时间流逝的进度区别在于，插值可以根据数学模型生成任意的值，而时间流逝的进度值是客观不可变的。补间动画正是基于计算的插值来计算下一帧的动画的。计算完插值后通过applyTransformation来计算动画。我们可以看看TranslateAnimation是如何基于此计算动画的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = mFromXDelta;</span><br><span class="line">    <span class="keyword">float</span> dy = mFromYDelta;</span><br><span class="line">    <span class="keyword">if</span> (mFromXDelta != mToXDelta) &#123;</span><br><span class="line">        dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFromYDelta != mToYDelta) &#123;</span><br><span class="line">        dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    t.getMatrix().setTranslate(dx, dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TranslateAnimation都是基于interpolatedTime计算动画偏移。如水平方向的偏移<br>dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime) 这里的interpolatedTime可以看作是插值器计算的动画进度，它从0f-1.0f。</p><p>完成这一步，就可以通过view的父view发起绘制动画的请求，这是通过parent.invalidate方法来发起的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android提供了几种基本的动画：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帧动画&lt;/li&gt;
&lt;li&gt;补间动画&lt;/li&gt;
&lt;li&gt;属性动画&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中属性动画和补间动画比较常用，它们最大的区别在于补间动画并不会真正的改变View的属性，什么意思呢？比如通过补间动画
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>requestLayout源码分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-requestLayout-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-requestLayout-src/</id>
    <published>2018-02-18T02:26:32.000Z</published>
    <updated>2019-03-17T09:30:07.996Z</updated>
    
    <content type="html"><![CDATA[<p>invalidate是用来进行view的重绘的，它一般会导致onDraw的调用(对于ViewGroup容器来说它并不一定会调用onDraw)以使View改变自身内容，但是如果当view的大小尺寸发生了变化，此时就需要requestLayout对view进行布局请求。比如当view设置了布局参数后就需要进行布局请求。但需要注意的是requestLayout并不保证onDraw会调用，它只负责完成布局请求，调不调用onDraw取决于view的内容是否改变。所以一般情况下requestLayout和invalidate是结合着使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    mLayoutParams = params;</span><br><span class="line">    ……</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class="line">        <span class="comment">// not the views in its parent hierarchy</span></span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;<span class="comment">//如果正在layout 发送请求layout</span></span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置FLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED标记</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestLayout是从View开始，它首先判断的当前viewRoot是否正在进行layout，如果是，则发送请求给ViewRoot，告诉它当前view需要进行layout。否则为view打上PFLAG_FORCE_LAYOUT和PFLAG_INVALIDATED标记，然后调用parent的requestLayout，这里parent即它的父view，可以是ViewGroup也可以是ViewRoot,其中ViewGroup没有覆盖requestLayout，那么依然是调用View的requestLayout。这实际上是一个递归调用为父view打上请求布局的标记。直到ViewRootImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<span class="comment">//如果layout请求没有在执行 </span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;<span class="comment">//设置layout请求标记</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl的requestLayout中设置mLayoutRequested为true,然后开启请求布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; !mStopped;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获得view宽高的测量规格，lp.width和lp.height表示DecorView根布局宽和高</span></span><br><span class="line">            <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//开始执行测量操作</span></span><br><span class="line"></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; !mStopped;<span class="comment">//layoutRequested 为true并且actitivy并非暂停则需要执行layout</span></span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">            || attachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">     <span class="keyword">boolean</span> cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||</span><br><span class="line">                viewVisibility != View.VISIBLE;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<span class="comment">//既没有取消绘制，也没有创建新的平面</span></span><br><span class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;<span class="comment">//</span></span><br><span class="line">            ……</span><br><span class="line">            performDraw();<span class="comment">//开始执行绘制操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mLayoutRequested 在requestLayout中设置为true,mStopped表示当前view树所在的window状态不是停止的，一般为false，那么layoutRequested为true，didLayout为true。那么分别执行performMeasure和performLayout，下面我们分别分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl的performMeasure执行view的measure方法进行测量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;<span class="comment">//清除meaure set 标记 用来检测是否调用了setMeasuredDimension</span></span><br><span class="line"></span><br><span class="line">       ……</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">    mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">            (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于mPrivateFlags在requestLayout中设置了PFLAG_FORCE_LAYOUT，所有清除PFLAG_MEASURED_DIMENSION_SET的标记，这个标记用于检测是否调用setMeasuredDimension，同时打上PFLAG_LAYOUT_REQUIRED标记，表示请求布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;<span class="comment">//表示正在进行layout请求操作</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process fresh layout requests, then measure and layout</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line">                ……</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performLayout负责执行viewlayout过程，同时对请求布局的view也执行requstLayout。这里host就是view树的根节点，即DecorView，它是个FrameLayout。所以我们看看ViewGroup的layout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>viewGroup调用view的layout</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<span class="comment">//setFrame中可能会触发invalidate进行重绘置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<span class="comment">//如果布局发生了变化 则还需要对子视图进行重新布局</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在measure过程中设置了PFLAG_LAYOUT_REQUIRED标记，那么就会调用onLayout来进行view的布局过程，这个过程完成后，清理PFLAG_LAYOUT_REQUIRED和PFLAG_FORCE_LAYOUT标记表示布局过程完成了。这里需要注意的是view在测量后大小可能发生变化，这时候通过setFrame设置其边框时会调用invalidate的调用，因此可能会导致onDraw的调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;invalidate是用来进行view的重绘的，它一般会导致onDraw的调用(对于ViewGroup容器来说它并不一定会调用onDraw)以使View改变自身内容，但是如果当view的大小尺寸发生了变化，此时就需要requestLayout对view进行布局请求。比如当v
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View invalidate的源码分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-invalidate-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-invalidate-src/</id>
    <published>2018-02-10T02:26:32.000Z</published>
    <updated>2019-03-16T08:07:12.014Z</updated>
    
    <content type="html"><![CDATA[<p>我们在自定义View时，通常使用invalidate方法来刷新View，本篇将对invalidate的实现进行分析。invalidate有多个重载方法，<br>但其最终的实现都是类似的，这里我们从invalidate()开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/View.java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Invalidate the whole view. If the view is visible,</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; will be called at some point in</span></span><br><span class="line"><span class="comment">* the future. This must be called from a UI thread. To call from a non-UI thread,</span></span><br><span class="line"><span class="comment">* call &#123;<span class="doctag">@link</span> #postInvalidate()&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//使整个view无效，将会导致view的onDraw调用 即重绘view的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);<span class="comment">//true表示刷新缓存也应该失效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//true表示刷新缓存也应该失效，如果置位false表示view的内容或者大小没有发生变化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (skipInvalidate()) &#123;<span class="comment">//是否应该跳出本次过程，跳过绘制的条件需满足：view不可见 且没有当前动画在执行 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 可以进行刷新的条件：</span></span><br><span class="line"><span class="comment">        * 1: 需要绘制且已经设置过边界</span></span><br><span class="line"><span class="comment">        * 2：当前绘制缓存还是有效，但要使其失效</span></span><br><span class="line"><span class="comment">        * 3：view将处于invalided状态</span></span><br><span class="line"><span class="comment">        * 4: 透明度发生了变化</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) ||</span><br><span class="line">            (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) ||</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || isOpaque() != mLastIsOpaque) &#123;</span><br><span class="line">        mLastIsOpaque = isOpaque();</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DRAWN;<span class="comment">//重置绘制标记</span></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;<span class="comment">//标记PFLAG_DIRTY 表示view当前已经失效</span></span><br><span class="line">        <span class="keyword">if</span> (invalidateCache) &#123;<span class="comment">//需要失效缓存</span></span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;<span class="comment">//标记失效</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<span class="comment">//清除缓存有效的标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;<span class="comment">//取到view的attch信息</span></span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;<span class="comment">//父view</span></span><br><span class="line">        <span class="comment">//noinspection PointlessBooleanExpression,ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (!HardwareRenderer.RENDER_DIRTY_REGIONS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; ai.mHardwareAccelerated) &#123;<span class="comment">//开启了硬件加速</span></span><br><span class="line">                <span class="comment">// fast-track for GL-enabled applications; just invalidate the whole hierarchy</span></span><br><span class="line">                <span class="comment">// with a null dirty rect, which tells the ViewAncestor to redraw everything</span></span><br><span class="line">                p.invalidateChild(<span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//开启硬件加速了就将view所有的区域标记为脏区域以使viewRoot重绘所有的内容</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未开启硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect r = ai.mTmpInvalRect;</span><br><span class="line">            r.set(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);<span class="comment">//将Rect设置为view的大小</span></span><br><span class="line">            <span class="comment">// Don't call invalidate -- we don't want to internally scroll</span></span><br><span class="line">            <span class="comment">// our own bounds</span></span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, r);<span class="comment">//调用父view的invalidateChild方法 具体见ViewGroup</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invalidate的实现很简单，只需要满足一定的条件，就需要走绘制流程，这里需要注意两个标记一个是PFLAG_INVALIDATED，代表了View当前已经失效了，<br>另一个PFLAG_DRAWING_CACHE_VALID，表示View的绘制缓存有效。这里根据参数invalidateCache为true对其进行设置，对于硬件加速和非硬件加速的情况分别走<br>不同的流程，现在大多数其实是走硬件加速的流程，但这里我们还是看软件绘制的流程，关于硬件加速我们在别的篇章中介绍，在这里Mark~一下就好。</p><p>这里会设置一个Rect区域,这个区域实际上就是我们View的大小，也是待刷新的dirty区域，因为mRight-mLeft是View的宽度，mBottom-mTop就是View的高度，随后通过调用ViewParent的<br>invalidateChild方法，这里的ViewParent实际上就是当前view的父View或者view层级数的ViewRoot，所以invalidateChild是会走到ViewGroup或者ViewRootImpl<br>中去的。我们接着看哈~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION)</span><br><span class="line">                == PFLAG_DRAW_ANIMATION;<span class="comment">//child view是否在执行动画</span></span><br><span class="line">        Matrix childMatrix = child.getMatrix();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;</span><br><span class="line">                child.getAnimation() == <span class="keyword">null</span> &amp;&amp; childMatrix.isIdentity();<span class="comment">//发起请求的view是否是不透明的，执行动画的view则不认为它不透明</span></span><br><span class="line">        <span class="keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;<span class="comment">//child view 的 dirty标记</span></span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//存放dirty region的起点坐标    </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</span><br><span class="line">        location[CHILD_LEFT_INDEX] = child.mLeft;</span><br><span class="line">        location[CHILD_TOP_INDEX] = child.mTop;</span><br><span class="line">        ……</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawAnimation) &#123;</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewRootImpl) &#123;</span><br><span class="line">                    ((ViewRootImpl) parent).mIsAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span></span><br><span class="line">            <span class="comment">// flag coming from the child that initiated the invalidate</span></span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到的是父view的父view</span></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invalidateChild接收两个参数，发起invalidate的child view即dirty区域，dirty区域的起始坐标点就是child view<br>在父view中的左上角坐标，随后进行do…while循环，在循环中我们忽略执行动画的情况，然后为当前父view设置dirty标记。<br>这个dirty标记为父view记录下子view的视图情况，后续在draw时会用到该标记判断是否需要绘制通过onDraw绘制view<br>随后调用invalidateChildInParent方法并返回当前父View的父View,一直到ViewRootImpl。可见这个循环其实是一个在View<br>层级数中从发起View的父View不断上溯到ViewRoot执行invalidateChildInParent的过程，那么在这之间，invalidateChildInParent<br>到底会做些什么事情呢？这里我们传递给invalidateChildInParent的是dirty区域的在当前父view的左上角的坐标和dirty区域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class="line">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">            <span class="comment">//计算dirty区域在当前父view中的偏移位置</span></span><br><span class="line">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</span><br><span class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                    dirty.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<span class="comment">//同时置ViewParent的PFLAG_DRAWING_CACHE_VALID标记为0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新location</span></span><br><span class="line">            location[CHILD_LEFT_INDEX] = left;</span><br><span class="line">            location[CHILD_TOP_INDEX] = top;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">                mLocalDirtyRect.union(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWN &amp; ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            location[CHILD_LEFT_INDEX] = mLeft;</span><br><span class="line">            location[CHILD_TOP_INDEX] = mTop;</span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                dirty.set(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// in case the dirty rect extends outside the bounds of this container</span></span><br><span class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);<span class="comment">//和当前VeiwGroup所属区域做并集</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;<span class="comment">//ViewGroup的标记置失效</span></span><br><span class="line">                mLocalDirtyRect.union(dirty);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在invalidateChildInParent中，首先通过offset计算dirty区域在当前父view中偏移位置，起始的dirty区域就是发起invalidate的子view<br>它再父view中的左上角位置就是(mLeft,mTop),随后计算dirty区域，首先判断FLAG_CLIP_CHILDREN是否设置，即我们在布局文件中<br>设置的android:clipChildren，默认是设置为true的，这个属性是用来限制子view是否在父view的绘制区域内的。设置为false即FLAG_CLIP_CHILDREN未设置的情况下<br>表示可以超出父view的绘制区域。这种情况下的话就设置dirty区域为当前父view的区域。否则FLAG_CLIP_CHILDREN设置就根据当前dirty区域和父view的区域做交集运算后<br>得到的dirty区域。如果没交集则dirty置空。然后更新location为当前父view在其父view中的左上角位置，为下一次计算脏区域在其父view中的偏移做准备。这样经过一层层的<br>计算后最终回溯到ViewRootImpl中的invalidateChildInParent中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (dirty == <span class="keyword">null</span>) &#123;<span class="comment">//脏区域为null说明要重新绘制整个view树</span></span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;<span class="comment">//没有动画在执行且没有脏区域就不用绘制了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span> || mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTempRect.set(dirty);</span><br><span class="line">        dirty = mTempRect;</span><br><span class="line">        <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</span><br><span class="line">            dirty.offset(<span class="number">0</span>, -mCurScrollY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">            dirty.inset(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Rect localDirty = mDirty;</span><br><span class="line">    <span class="keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">        mAttachInfo.mSetIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new dirty rect to the current one</span></span><br><span class="line">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">    <span class="comment">// Intersect with the bounds of the window to skip</span></span><br><span class="line">    <span class="comment">// updates that lie outside of the visible region</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intersected = localDirty.intersect(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    <span class="keyword">if</span> (!intersected) &#123;</span><br><span class="line">        localDirty.setEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*ViewRootImpl同样是ViewParent，它和ViewGroup的invalideChildInParent的区别在于</span></span><br><span class="line"><span class="comment">    * ViewRootImpl在统计完dirty region后会进行schedualTraversals进行绘制流程*/</span></span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkThread会检查更新的线程是否是ui线程，如果dirty区域为null说明需要绘制整个view树，如果dirty区域为空或者未执行动画也不需要<br>再进行下去了。如果mCurScrollY不为空说明页面有滚动过，需要据此重新计算dirty区域。随后将dirty区域添加到localDrity中即当前view树<br>中的dirty区域中去。接着讲当前dirty区域和整个页面区域做交集计算，intersected一般为true也就是有交集，最后通过scheduleTraversals<br>进行重绘的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        draw(fullRedrawNeeded, updateTranformHint);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded, <span class="keyword">boolean</span> updateTranformHint)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;<span class="comment">//surface无效的话就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    <span class="comment">//如果是绘制整个页面 就设置dirty为整个屏幕的大小    </span></span><br><span class="line">    <span class="keyword">if</span> (fullRedrawNeeded) &#123;</span><br><span class="line">        attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        dirty.set(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//重绘区域不为空 或者正在执行动画</span></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating) &#123;</span><br><span class="line">        <span class="comment">//开启了硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (attachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//软件绘制 dirty描述绘制区域</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//根据重绘区域获取一个Canvas</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        mView.draw(canvas);<span class="comment">//view的绘制</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleTraversals通过performDraw来绘制view，这里实际上是调用draw(boolean fullRedrawNeeded, boolean updateTranformHint)方法，<br>对应非硬件加速的情况，这个方法内部调用drawSoftware来进行绘制，注意这里的dirty实际上就是当前view树计算后得到的脏区域。当然也包括了我们之前<br>调用view的invalidate后计算的脏区域。通过这个脏区域通过在mSurface中设置一个裁剪区域并返回一个Canvas，随后的绘制就在此Canvas的裁剪区域中进行绘制。</p><p>View的draw绘制过程主要包括以下方面：</p><ol><li>Draw the background</li><li>If necessary, save the canvas’ layers to prepare for fading</li><li>Draw view’s content</li><li>Draw children</li><li>If necessary, draw the fading edges and restore layers</li><li>Draw decorations (scrollbars for instance)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ……    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState); <span class="comment">//子view是否不透明且未执行动画</span></span><br><span class="line">    ……</span><br><span class="line">    background.draw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);<span class="comment">//子视图不透明 会覆盖掉当前视图 所以skip</span></span><br><span class="line"></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在draw流程中是否回调onDraw是由dirtyOpaque决定的，而dirtyOpaque是根据标记PFLAG_DIRTY_OPAQUE是否设置来决定的，<br>还记得在上面invalidateChild时会为父view设置这个标记？这个标记表明子view是不透明的且没有在执行动画，那么此时<br>就没必要对view进行绘制了，因为子view是在父view之上的，会覆盖掉当前view的视图，所有就没有必要绘制了。<br>需要注意的是，ViewGroup作为一个容器控件，默认情况下是没有任何东西可画的，它是一个透明控件。</p><p>draw过程中的dispatchDraw用来绘制子view，我们看下ViewGroup中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/ViewGroup.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;<span class="comment">//绘制子视图</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;<span class="comment">//子视图可见或者设置了动画</span></span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);<span class="comment">//绘制子视图</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[getChildDrawingOrder(count, i)];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawChild会调用view的另一个重载方法，它有三个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">    <span class="comment">/*quickReject判断当前View的区域是否落在Canvas的裁剪区域之外，如果是返回true，表示跳过当前view的绘制*/</span>    </span><br><span class="line">    <span class="keyword">if</span> (!concatMatrix &amp;&amp;</span><br><span class="line">            (flags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |</span><br><span class="line">                    ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp;</span><br><span class="line">            canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) &amp;&amp;</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 1. view没有关联的matrix矩阵</span></span><br><span class="line"><span class="comment">    * 2. view的绘制区域落在Canvas裁剪区域之外</span></span><br><span class="line"><span class="comment">    * 3. clipchild设置为true</span></span><br><span class="line"><span class="comment">    * 4. 没有执行动画</span></span><br><span class="line"><span class="comment">    * **/</span>     </span><br><span class="line">        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;</span><br><span class="line">        <span class="keyword">return</span> more;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (!layerRendered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasDisplayList) &#123;</span><br><span class="line">            <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                dispatchDraw(canvas);<span class="comment">//绘制子视图</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                draw(canvas);<span class="comment">//绘制本身及子视图</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            ((HardwareCanvas) canvas).drawDisplayList(displayList, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从draw方法中可以看出，子view的并不是每次进行绘制流程时候都需要绘制一遍，尤其是当view通过invalidate触发绘制时，<br>因此此时Canvas根据dirty区域设置了裁剪区域，而ViewGroup在绘制子view时会判断其区域是否落在这个裁剪区域内，如果<br>不在就没有必要进行绘制了，直接返回。这是通过canvas的quickReject进行判断的.随后就是字view的绘制，这里面会判断是否<br>设置了PFLAG_SKIP_DRAW，这个标记用来控制是否需要对View进行绘制，对ViewGroup来说默认是设置了的，所以它直接通过<br>dispatchDraw来绘制子view，并不会对自身进行绘制，onDraw也不会进行调用。如果想要使它绘制可以通过setWillNotDraw(false)<br>来清除PFLAG_SKIP_DRAW标记。这样会进入view(ViewGroup)的draw流程，但具体能不能调用onDraw还要做以下判断</p><blockquote><p>final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;<br>(mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); //子view是否不透明且未执行动画</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((changed &amp; DRAW_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_SKIP_DRAW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">        &#125;</span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate(<span class="keyword">true</span>);<span class="comment">//通过invalidate刷新</span></span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里invalidate的流程就分析完了，需要注意的是，invalidate会触发绘制流程，但是并不会触发onMeasure和onLayout。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在自定义View时，通常使用invalidate方法来刷新View，本篇将对invalidate的实现进行分析。invalidate有多个重载方法，&lt;br&gt;
但其最终的实现都是类似的，这里我们从invalidate()开始分析。&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Surface绘图缓冲区的创建流程</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-surface-buffer-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-surface-buffer-src/</id>
    <published>2018-01-24T01:37:17.000Z</published>
    <updated>2019-03-16T08:08:25.697Z</updated>
    
    <content type="html"><![CDATA[<p>Android View绘制是GUI系统的核心，而绘制view是需要缓冲区的，也就是我们说的画布，因此了解这个缓冲区的分配流程是有必要的，本篇将对该缓冲区的分配进行解释。</p><h3 id="activity结构剖析"><a class="markdownIt-Anchor" href="#activity结构剖析"></a> Activity结构剖析</h3><p>Acitivty实际上在WMS端只是个Window，是以WindowState进行描述的，在AMS端它是一个ActivityRecord，在Activity内部它持有一个mWindow，它实际上为一个PhoneWindow实例，在PhoneWindow中维护了一个DecorView，也就是view树，这个PhoneWindow实例由一个WindowManagerImpl进行管理，在WindowManagaerImpl内部持有一个WindowManagerGlobal单例，它内部持有WMS的本地代理IWindowManager和由其打开的一个IWindowSession负责和WMS进行会话，另一方面它负责整个应用的窗口视图的管理，也就是DecorView及ViewRootImpl的管理。每个新添加的window最终会在WMS端以WidowState的形式存在于WMS，WMS不关心window的View树的内容，它只关心Window的大小样式以及Z序等，而绘制的流程是由我们应用程序进行的，实际上就是由ViewRootImp进行绘制的。那么相应的ViewRootImpl在进行绘制前是需要一个画布进行view树的绘制的，这个画布就是Surface。接下来我们将围绕这个Surface进行话题的展开。</p><h3 id="画布的分配"><a class="markdownIt-Anchor" href="#画布的分配"></a> 画布的分配</h3><p>在ViewRootImpl创建时同时会new一个Surface对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure><p>接下来我们看下这个Surface的内部会做些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ^</span><br><span class="line">    <span class="keyword">int</span> mNativeObject; <span class="comment">// package scope only for SurfaceControl access</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLockedObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mGenerationId; <span class="comment">// incremented each time mNativeObject changes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Surface的构造方法只是个空实现，而貌似mCanvas可能会是真正的画布，我们继续看看Canvas的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">     <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mNativeCanvas;</span><br><span class="line">    <span class="comment">// may be null</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap mBitmap;</span><br><span class="line">    <span class="comment">// optional field set by the caller</span></span><br><span class="line">    <span class="keyword">private</span> DrawFilter mDrawFilter;</span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Canvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHardwareAccelerated()) &#123;</span><br><span class="line">            <span class="comment">// 0 means no native bitmap</span></span><br><span class="line">            mNativeCanvas = initRaster(<span class="number">0</span>);</span><br><span class="line">            mFinalizer = <span class="keyword">new</span> CanvasFinalizer(mNativeCanvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFinalizer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Canava的构造方法中也并没有相关缓冲区分配的动作，这么说new出来的Surface并非真的分派了缓冲区，而只是一个空壳。想想也就能理解，我们知道ViewRootImpl分派的时机是WindowManagerGlobal通过addView来添加view树的时候分配的时候，这时候WMS还不知道这个Window的存在的(最起码得知道分配多大吧)，那么给view树分配缓冲区的确为时过早。那么什么时候分配合适呢？当然是准备绘制view树的时候。view树的绘制是在performTraversal中进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;<span class="comment">//viewRoot管理的view树 decorView</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">boolean</span> windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">            &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())</span><br><span class="line">                || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                        frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)</span><br><span class="line">                || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                        frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">                viewVisibilityChanged || params != <span class="keyword">null</span> || mConfigurationChanged) &#123;</span><br><span class="line">         relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">         ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    performMeasure();</span><br><span class="line">    ……</span><br><span class="line">    performLayout();</span><br><span class="line">    ……</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals函数比较长，我这里只取跟本篇相关的内容，在performTraversals并非仅仅只有三大绘制流程performMeasure,performLayout和performDraw,实际上在这三个流程之前还是做了很多事情的，我简单的说下：</p><ol><li><p>计算期望的窗口大小，如果Window带状态栏，那么在其大小中应该除去状态栏的那部分宽高。否则大小应该为整个屏幕的大小</p></li><li><p>如果窗口大小发生了变化也需要记录下来</p></li><li><p>计算窗口的内容区域边衬是否变化</p></li><li><p>如果可见性发生了变化也需要记录，同时通知view树子视图可见性发生了变化</p></li><li><p>根据条件判断是否需要relayoutWindow，在relayoutWindow中会重新计算窗口大小。需要满足的条件至少为以下一种：</p><pre><code> &lt;1&gt;. Activity窗口是第一次执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true。  &lt;2&gt;. 前面得到的变量windowShouldResize的值等于true，即Activity窗口的大小的确是发生了变化。  &lt;3&gt;. 前面得到的变量insetsChanged的值等于true，即Activity窗口的内容区域边衬发生了变化。  &lt;4&gt;. Activity窗口的可见性发生了变化，即变量viewVisibilityChanged的值等于true。  &lt;5&gt;. Activity窗口的属性发生了变化，即变量params指向了一个WindowManager.LayoutParams对象</code></pre></li></ol><p>6.执行绘制流程，这个在另外的篇幅再做介绍</p><p>在relayoutWindow中会计算窗口的大小，同时这里会为窗口分配缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingConfiguration, mSurface);</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mWindowSession和WMS进行会话调用relayout计算窗口的大小并将mSurface传递给WMS。IWindowSession的服务端为Session，我们看看它的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outConfig, outSurface);<span class="comment">//调用WMS的relayoutWindow</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Session的relayout会通过WMS的relayoutWindow来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">    WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">    Rect outVisibleInsets, Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">                surfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建SurfaceControl 准备画布</span></span><br><span class="line">            SurfaceControl surfaceControl = winAnimator.createSurfaceLocked();</span><br><span class="line">            <span class="keyword">if</span> (surfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outSurface.copyFrom(surfaceControl);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// For some reason there isn't a surface.  Clear the</span></span><br><span class="line">                <span class="comment">// caller's object so they see the same state.</span></span><br><span class="line">                outSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>relayoutWindow的参树client为ViewRootImpl传递的W对象，是一个Binder对象，WMS通过client来通知应用窗口的变化。最后一个参数从命名上来看，它是一个出参，也就是通过这个方法可以拿到真正可用的Surface。可以看到outSurface是由copyFrom从SurfaceControl得来的。这个surfaceControl是通过winAnimator.createSurfaceLocked()来创建的。这个winAnimator是一个WindowStateAnimator，在我们为Window创建WindowState时创建的，它和WindowState是一一对应的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.java</span><br><span class="line"><span class="function">SurfaceControl <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">            mSession.mSurfaceSession,</span><br><span class="line">            attrs.getTitle().toString(),</span><br><span class="line">            w, h, format, flags);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mSurfaceControl在WindowStateAnimator中只会创建一次，这里的mSession实际上就是应用端和WMS进行会话的session，即IWindowSession，在创建时会指定缓冲区大小，格式以及标记。那么mSurfaceSession是什么呢，在哪里创建的呢？我们继续看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</span><br><span class="line"> <span class="comment">//为客户端创建一个Session会话，后面客户端使用这个Session同WMS进行会话    </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">    WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">    Rect outContentInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ……    </span><br><span class="line">    win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                    attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ……</span><br><span class="line">    win.attach()</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/wm/WindowState.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken</span><br><span class="line">        + <span class="string">", list="</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/wm/Session.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WMS为应用打开一个会话session后并没有立马去创建mSurfaceSession，而是在Window添加到WMS的时候创建完WindowState后通过attach方法创建的。它同样的对于一个Session只会创建一个，也就是说我们的应用程序只会有一个SurfaceSession，因为它是Session的成员嘛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceSession</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This field is accessed by native code.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNativeClient; <span class="comment">// SurfaceComposerClient*</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeCreate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">int</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeKill</span><span class="params">(<span class="keyword">int</span> ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a new connection with the surface flinger. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mNativeClient = nativeCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceSession的实现很简单，因为它的工作都放在native层完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_SurfaceSession.cpp</span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();<span class="comment">//SurfaceComposerClient是处于客户端的</span></span><br><span class="line">    client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jint&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上它是创建了一个SurfaceComposerClient对象并放在mNativeClient中。这个对象是用来和SurfaceFlinger打交道的，但它并不是SurfaceFlinger的本地代理。SurfaceFlinger负责界面图层的合成，这之间会涉及我们的缓冲区，所以分配缓冲区的工作需要经过SurfaceFlinger来进行。</p><p>弄清楚SurfaceSession是什么后，接下来我们看SurfaceControl的创建，它会用到SurfaceSession。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceControl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mNativeObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">            String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mNativeObject = nativeCreate(session, name, w, h, format, flags);<span class="comment">//通过native层创建SurfaceControl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，它的工作也是在native层进行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_SurfaceControl.cpp</span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">            String8(name.c_str()), w, h, format, flags);<span class="comment">//创建SurfaceHolder</span></span><br><span class="line">    <span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(surface.get());<span class="comment">//这里返回创建的SurfaceControl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_SurfaceSession.cpp</span><br><span class="line">sp&lt;SurfaceComposerClient&gt; android_view_SurfaceSession_getClient(</span><br><span class="line">        JNIEnv* env, jobject surfaceSessionObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;SurfaceComposerClient*&gt;(</span><br><span class="line">            env-&gt;GetIntField(surfaceSessionObj, gSurfaceSessionClassInfo.mNativeClient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nativeCreate中首先通过android_view_SurfaceSession_getClient从SurfaceSession中取到之前创建的SurfaceComoserClient对象，然后通过该对象调用的CreateSurface创建SurfaceControl。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();<span class="comment">//与surfaceflinger建立连接</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">            mClient = conn;<span class="comment">//mClient对应服务端Client</span></span><br><span class="line">            mStatus = NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();<span class="comment">//实例采用单例</span></span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">"ComposerService reconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ComposerService::connectLocked() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">"SurfaceFlinger"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;<span class="comment">//获取surfaceflinger服务</span></span><br><span class="line">        usleep(<span class="number">250000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w,</span><br><span class="line">        <span class="keyword">uint32_t</span> h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">        <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">                &amp;handle, &amp;gbp);<span class="comment">//在Client服务端创建相应的Layer</span></span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);<span class="comment">//同时创建一个SurfaceControl，这个gbp即是对应Layer的BufferQueue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient在创建完后，强引用的会首先会执行onFirstRef 在这个方法里会通过<br>ComposerService::getComposerService获取到SurfaceFlinger的Binder本地代理sm，这是在ComposerService::connectLocked中通过getService获取的，SurfaceFlinger是实名Binder，因此可以通过ServiceManager查询得到。获取到SurfaceFlinger的本地代理后，就可以通过createConnection创建ISurfaceComposerClient，它是一个匿名Binder,是SurfaceFlinger服务中Client 的本地代理。Client也是个Binder Server,SurfaceFlinger为每个于其建立连接的应用进程维护一个Client便于管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/Client.cpp</span><br><span class="line"><span class="comment">//应用程序创建Surface</span></span><br><span class="line"><span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="comment">//message最终通过这个handler进行处理</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);<span class="comment">//创建过程由sf的createLayer完成，客户端创建一个Surface，对应的在sf中创建一个Layer</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);<span class="comment">//通过消息队列的方式来处理请求，主要是因为sf是为多个应用服务的，用这样的方式便于处理多个请求。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Client中createSurfac会通过请求参数构造一个MessageBase然后post到SurfaceFlinger的MessageQueue，最终事件会通过MessageBase的handleMessage进行处理，在handleMessage中调用了虚方法handler进行消息的处理。也就是MessageCreateLayer的handler进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageBase::handleMessage(<span class="keyword">const</span> Message&amp;) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handler();<span class="comment">//调用handler方法</span></span><br><span class="line">    barrier.open();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在MessageCreateLayer的handler中又会通过SurfaceFlinger的createLayout为客户端创建一个Layer，这个Layer即图层，它对应于应用端的Window。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::createLayer(</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)<span class="comment">//为客户端创建Layer</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;<span class="comment">//支持两种类型的Layer Normal和Dim</span></span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == NO_ERROR) &#123;</span><br><span class="line">        addClientLayer(client, *handle, *gbp, layer);<span class="comment">//将创建的Layer添加到用户的队列中</span></span><br><span class="line">        setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger的createLayer中会根据flag来创建不同的layer，分别为Normal和Dim类型的，创建完layer后会将其添加到client中去。这里我们看下CreateNormalLayer的实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)<span class="comment">//创建Normal类型的Layer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// initialize the surfaces</span></span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">        <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">        <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">            format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> NO_RGBX_8888</span></span><br><span class="line">            format = PIXEL_FORMAT_RGB_565;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_RGBX_8888</span></span><br><span class="line">    <span class="keyword">if</span> (format == PIXEL_FORMAT_RGBX_8888)</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    *outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);<span class="comment">//创建Layouer 在第一次引用该Layer时会创建其BufferQueue和Consumer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);<span class="comment">//设置layer大小和格式</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp = (*outLayer)-&gt;getBufferQueue();<span class="comment">//获取Layer对应的BufferQueue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Layer的实例后就可以通过getBufferQueue获取到layer内部的BufferQueue，这个BufferQueue是个Binder Server,它是一个缓冲队列，用来维护layer的缓冲区。它是在Layer的onFirstRef中创建的，我们缓冲区的分配在SurfaceFligner端实际实际上就是通过它来分配的。同时，它既是缓冲区的消费者又是生产者，对于应用端来说，它扮演生产者的角色，因为应用端是填充数据的一方，而对于surfaceFligner来说它又扮演消费者的角色，因为SurfaceFlinger是合成layer层，取出缓冲区进行显示的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;<span class="comment">//在第一次引用时创建一个bufferqueue</span></span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    mBufferQueue = <span class="keyword">new</span> SurfaceTextureLayer(mFlinger);<span class="comment">//创建一个BufferQueue用于管理Layer的图形缓冲区</span></span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceTextureLayer</span> :</span> <span class="keyword">public</span> BufferQueue &#123;<span class="comment">//父类是BufferQueue</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SurfaceTextureLayer(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger);</span><br><span class="line">    <span class="keyword">virtual</span> ~SurfaceTextureLayer();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的SurfaceTextureLayer它实际上就是个BufferQueue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w,</span><br><span class="line">        uint32_t h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    if (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">        status_t err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">                &amp;handle, &amp;gbp);//在Client服务端创建相应的Layer</span><br><span class="line">        ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error %s&quot;, strerror(-err));</span><br><span class="line">        if (err == NO_ERROR) &#123;</span><br><span class="line">            sur = new SurfaceControl(this, handle, gbp);//同时创建一个SurfaceControl，这个gbp即是对应Layer的BufferQueue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建好layer后通过getBufferQueue后是以IGraphicBufferProducer的角色返回的，它代表了这个BufferQueue将作为一个生产者供应用端使用。紧接着在本地创建一个SurfaceControl<br>需要注意这个时候gbd是在我们的应用进程中了，它是BufferQueue的本地代理binder对象了。<br>我们通过这个代理对象来创建SurfaceControl。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl::SurfaceControl(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp)</span><br><span class="line">    : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建好本地的SurfaceControl，然后保存在java层的SurfaceControl的mNativeObject中。但是这个时候好像并没有真正去分配缓冲区，那么创建这个SurfaceControl给上层到底是干嘛用的？没错，就是用来分配缓冲区的，因为它内部这时候是有一个IGraphicBufferProducer的，它是layer中的BufferQueue代理binder。</p><p>在WMS的relayoutWindow中创建完SurfaceControl后，会通过Surface的copyFrom来初始化它，在这之前Surface还是个空壳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"other must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> surfaceControlPtr = other.mNativeObject;<span class="comment">//取到指向SurfaceControl的本地对象指针</span></span><br><span class="line">        <span class="keyword">if</span> (surfaceControlPtr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</span><br><span class="line">                    <span class="string">"SurfaceControl native object is null. Are you using a released SurfaceControl?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);<span class="comment">//通过SurfaceControl来创建新的Surface</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">                nativeRelease(mNativeObject);</span><br><span class="line">            &#125;</span><br><span class="line">            setNativeObjectLocked(newNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java层的Surface是通过nativeCreateFromSurfaceControl，并将native层的SurfaceControl对象指针传递给它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());<span class="comment">//返回surfacecontrol管理的surface</span></span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过native层的SurfaceControl指针，可以通过getSurface获取到一个Surface。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span><span class="comment">//获取内部持有的Surface</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;<span class="comment">//第一次为空时创建</span></span><br><span class="line">        <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">        <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">        mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);<span class="comment">//这个surface是sf中消费的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNativeObjectLocked</span><span class="params">(<span class="keyword">int</span> ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeObject != ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject == <span class="number">0</span> &amp;&amp; ptr != <span class="number">0</span>) &#123;</span><br><span class="line">            mCloseGuard.open(<span class="string">"release"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mNativeObject != <span class="number">0</span> &amp;&amp; ptr == <span class="number">0</span>) &#123;</span><br><span class="line">            mCloseGuard.close();</span><br><span class="line">        &#125;</span><br><span class="line">        mNativeObject = ptr;</span><br><span class="line">        mGenerationId += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceControl 并不直接去分配缓冲区，而是通过管理一个本地Surface对象来管理缓冲区，它通过mGraphicBufferProducer构造，这个就是之前我们取到的IGraphicBufferProducer binder代理对象，构造的本地Surface最终会通过setNativeObjectLocked<br>保存在java层Surface的mNativeObject中。到这里java层的Surface就算创建完了，最终返回给ViewRootImpl使用。</p><h3 id="surface的使用"><a class="markdownIt-Anchor" href="#surface的使用"></a> Surface的使用</h3><h4 id="从surface中取缓冲区"><a class="markdownIt-Anchor" href="#从surface中取缓冲区"></a> 从Surface中取缓冲区</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    Canvas canvas;</span><br><span class="line">    ……</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface首先通过lockCanvas获取到一个Canvas对象，这个Canvas实际上为就是通过Surface的缓冲区填充的画布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ……</span><br><span class="line">        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">        <span class="keyword">return</span> mCanvas;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jni层的surface lockCanvas调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>)</span>;<span class="comment">//这个surface由surfaceControl创建的</span></span><br><span class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect dirtyRect;</span><br><span class="line">    Rect* dirtyRectPtr = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;<span class="comment">//ANativeWindow_Buffer定义在native_window.h中</span></span><br><span class="line">    status_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> exception = (err == NO_MEMORY) ?</span><br><span class="line">                OutOfResourcesException :</span><br><span class="line">                <span class="string">"java/lang/IllegalArgumentException"</span>;</span><br><span class="line">        jniThrowException(env, exception, NULL);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate a SkCanvas object to this surface</span></span><br><span class="line">    env-&gt;SetIntField(canvasObj, gCanvasClassInfo.mSurfaceFormat, outBuffer.format);<span class="comment">//将skCanvas是关联到surface</span></span><br><span class="line">    SkBitmap bitmap;<span class="comment">//准备画布</span></span><br><span class="line">    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setConfig(convertPixelFormat(outBuffer.format), outBuffer.width, outBuffer.height, bpr);<span class="comment">//设置画布大小及格式</span></span><br><span class="line">    <span class="keyword">if</span> (outBuffer.format == PIXEL_FORMAT_RGBX_8888) &#123;</span><br><span class="line">        bitmap.setAlphaType(kOpaque_SkAlphaType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);<span class="comment">//给画布设置缓冲区</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.setPixels(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkCanvas* nativeCanvas = SkNEW_ARGS(SkCanvas, (bitmap));<span class="comment">//将画布作为native的Canvase返回给上层使用</span></span><br><span class="line">    swapCanvasPtr(env, canvasObj, nativeCanvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect( SkRect::Make(reinterpret_cast&lt;<span class="keyword">const</span> SkIRect&amp;&gt;(dirtyRect)) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</span><br><span class="line">    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface的localCanvas是通过nativeLockCanvas,首先通过mNativeObject取到本地的Surface对象，通过这个本地的Surface进行lock取到缓冲区outBuffer，它是一个ANativeWindow_Buffer，随后通过这个缓冲区初始化一个SkBitmap画布，并设置其格式大小等，通过SkBitmap创建一个SkCanvas返回给java层Surface的mCanvas，我们在Draw方法中使用的Canvas就是这个SkCanvas.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::lock(</span><br><span class="line">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    ANativeWindowBuffer* out;<span class="comment">// 定义在window.h</span></span><br><span class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);<span class="comment">//分配缓冲区</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">int</span> Surface::dequeueBuffer(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> reqW = mReqWidth ? mReqWidth : mUserWidth;</span><br><span class="line">    <span class="keyword">int</span> reqH = mReqHeight ? mReqHeight : mUserHeight;</span><br><span class="line">    ……</span><br><span class="line">    sp&lt;Fence&gt; fence;</span><br><span class="line">    <span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, mSwapIntervalZero,</span><br><span class="line">            reqW, reqH, mReqFormat, mReqUsage);</span><br><span class="line">    ……</span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;<span class="comment">//未分配 或者需要重新映射</span></span><br><span class="line">        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);<span class="comment">//Surface通过调用 requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">        <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d"</span>, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    *buffer = gbuf.get();<span class="comment">//获取缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过mGraphicBufferProducer通过dequeueBuffer分配缓冲区，实际是由BufferQueue完成的，它实际上是取到BufferQueue中BufferSlot槽的索引buf，有了这个索引，通过requestBuffer就真正的创建buffer并将该buffer映射到Surface所在进程。这样我们的应用程序就可以使用了。</p><h4 id="提交绘制好的缓冲区"><a class="markdownIt-Anchor" href="#提交绘制好的缓冲区"></a> 提交绘制好的缓冲区</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ……</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的应用层绘制完后，需要将该缓冲区unlock并且提交给BufferQueue。这个是通过nativeUnlockCanvasAndPost进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the canvas from the surface</span></span><br><span class="line">    SkCanvas* nativeCanvas = SkNEW(SkCanvas);</span><br><span class="line">    swapCanvasPtr(env, canvasObj, nativeCanvas);<span class="comment">//把canvas从surface分离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock surface</span></span><br><span class="line">    status_t err = surface-&gt;unlockAndPost();<span class="comment">//提交结果</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::unlockAndPost()<span class="comment">//提交Locked的Buffer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLockedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Surface::unlockAndPost failed, no locked buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlock();</span><br><span class="line">    err = queueBuffer(mLockedBuffer.get(), <span class="number">-1</span>);<span class="comment">//将该Buffer queue</span></span><br><span class="line">    mPostedBuffer = mLockedBuffer;<span class="comment">//locked的buffer变为posted</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surfae的unlockAndPost调用queueBuffer方法完成buffer的提交</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::queueBuffer(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd) &#123;<span class="comment">//buffer queue进行消费</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);<span class="comment">//通过调用GBP的</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mGraphicBufferProducer入队这个buffer，此时生产者的任务完毕，layer端的Consumer即SurfaceFlinger会监听到这个有效的缓冲区，然后准备合成显示layer，最终将绘制的东西显示在屏幕上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android View绘制是GUI系统的核心，而绘制view是需要缓冲区的，也就是我们说的画布，因此了解这个缓冲区的分配流程是有必要的，本篇将对该缓冲区的分配进行解释。&lt;/p&gt;
&lt;h3 id=&quot;activity结构剖析&quot;&gt;&lt;a class=&quot;markdownIt-Anch
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View绘制流程分析</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/aosp-performtraversal-src/"/>
    <id>http://esligh.github.io/[object Object]/aosp-performtraversal-src/</id>
    <published>2018-01-02T02:26:32.000Z</published>
    <updated>2019-03-17T09:30:15.273Z</updated>
    
    <content type="html"><![CDATA[<p>View的绘制流程是Android GUI系统中的关键部分，因为最终view中绘制的内容是要呈现给用户的。本篇基于Android4.4(KitKat)将对view绘制流程做一个全面的分析。</p><h3 id="绘制缓冲区"><a class="markdownIt-Anchor" href="#绘制缓冲区"></a> 绘制缓冲区</h3><p>在View绘制流程中首先是需要一块缓冲区提供给应用程序进行内容绘制的， 这个缓冲区在上层以Surface的形式提供给使用者，这个Surface就是view绘制流程的绘图表面。在&lt;Surface绘图缓冲区的创建流程&gt;<br>一篇中我们介绍了Surface绘图缓冲区的绘制。所以关于这部分的内容不再做介绍。</p><h3 id="绘制的时机"><a class="markdownIt-Anchor" href="#绘制的时机"></a> 绘制的时机</h3><p>在&lt;Activity启动分析(二)&gt;一篇中，我们知道在handleResumeActivity通过addView添加view，将window加入到WMS后，会通过updateViewLayout更新视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/WindowManagerGlobal.java</span><br><span class="line"> <span class="comment">//更新视图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);<span class="comment">//设置view布局参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);<span class="comment">//找到对应的viewroot</span></span><br><span class="line">        mParams.remove(index);<span class="comment">//移除之前的params</span></span><br><span class="line">        mParams.add(index, wparams);<span class="comment">//添加新的params</span></span><br><span class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);<span class="comment">//通过root设置参数 false代表view已经添加过 这里会对view树重新绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(WindowManager.LayoutParams attrs, <span class="keyword">boolean</span> newView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">        scheduleTraversals();<span class="comment">//设置完成后就准备绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在root.setLayoutParams中会通过scheduleTraversals()绘制view。view树的绘制流程是在ViewRootImpl中完成的。</p><h3 id="绘制流程"><a class="markdownIt-Anchor" href="#绘制流程"></a> 绘制流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//请求同步信号，信号到来时会调用mTraversalRunnable执行doTravels</span></span><br><span class="line">        scheduleConsumeBatchedInput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            performTraversals();<span class="comment">//真正的绘制流程是从这里开始的</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制流程需要配合Vsync信号来进行，这个是通过Choreographer来进行的，在scheduleTraversals中通过mChoreographer请求同步信号，<br>信号到来时会调用mTraversalRunnable的doTraversal。在doTraversal中调用performTraversals来开始真正的绘制流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">            <span class="comment">//获得view宽高的测量规格，lp.width和lp.height表示DecorView根布局宽和高</span></span><br><span class="line">            <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<span class="comment">//开始执行测量操作</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; !mStopped;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">            || attachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||</span><br><span class="line">                viewVisibility != View.VISIBLE;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<span class="comment">//既没有取消绘制，也没有创建新的平面</span></span><br><span class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            performDraw();<span class="comment">//开始执行绘制操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在performTraversals中会做很多事情，这里我们主要绘制的主要流程，即measure,layout和draw的过程，在&lt;Surface绘图缓冲区的创建流程&gt;一篇中我们知道了在绘制之前是需要准备画布的，这个画布就是ViewRootImpl的mSurface，它会通过relayoutWindow创建。</p><h3 id="measure过程"><a class="markdownIt-Anchor" href="#measure过程"></a> measure过程</h3><p>measure过程主要进行view树中所有的view的大小的测量，我们看到测量并不一定会在performTraversals中进行，而是需要满足一定的条件：</p><ol><li>Window的状态不能为stopped，即mStopped=false</li><li>窗口的触摸模式发生了变化，由此引发了Activity窗口当前获焦点的控件发生了变化，即变量focusChangedDueToTouchMode的值等于true。这个检查是通过调用ensureTouchModeLocally来实现的。</li><li>窗口前面测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight不等于WindowManagerService服务计算出来的宽度mWidth和高度mHeight。这里的host为DecorView</li><li>窗口的内容区域边衬大小和可见区域边衬大小发生了变化， 即contentInsetsChanged的值等于true</li></ol><p>只有满足上述条件，measure流程才会进行，在执行measure前，首先会根据DecorView的宽高获取测量规格MesaureSpec，它的前两位为mode，有三种，分别为：</p><ul><li>UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大</li><li>EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。</li><li>AT_MOST：子容器可以是声明大小内的任意大小</li></ul><p>这个测量规格会传递给子view,子view结合自身LayoutParams算出view的大小。子view测量完成后，通过setMeasureDimentions将测量结果保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在performMeasure之前会通过getRootMeasureSpec获取根view的MeasureSpec，它默认为屏幕的大小，<br>这里的mView是DecorView，它是一个FrameLayout，通过它我们来看看测量过程是如何进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                    mMeasureCache.indexOfKey(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">        <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">        <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">        setMeasuredDimension((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>measure方法是在view中定义的，这里需要注意measure是一个final方法，在内部它通过调用onMeasure来完成实际的测量工作。如果我们需要自定义view，就需要覆盖onMeasure在其中完成view大小的测量，我们看下默认的onMeasure实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        <span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">        <span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;<span class="comment">//标记已经调用了setMeasuredDimension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onMeasure默认通过setMeasuredDimension设置mMeasuredWidth和mMeasuredHeight的值。通过这个方法完成测量过程。默认值是通过getDefaultSize计算得到的,它的第一个参数是通过getSuggestedMinimumxx获取到的，用来获取建议的最小宽高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个建议的最小高度值由layout:minHeight 和 BackGround的最小高度决定，最小宽度值也是类似。getDefaultSize会通过父view传递给view的MeasureSpec来计算最终宽高。对于MeasureSpec.AT_MOST和MeasureSpec.EXACTLY两种最常见的模式，最终的大小是由specSize,也就是MeasureSpec决定的。而不是由建议值。</p><h3 id="layout过程"><a class="markdownIt-Anchor" href="#layout过程"></a> layout过程</h3><p>在测量完view大小后，通过layout来确定view的位置，layout流程需满足下面的条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; !mStopped;</span><br></pre></td></tr></table></figure><ol><li>通过requestLayout发起过layout请求</li><li>Window的状态不为stopped</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line">    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是从view根部开始，我们看看DecorView的layout实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/ViewGroup.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果LayoutTransitiond动画未执行，那么直接调用View的layout，否则设置mLayoutCalledWhileSuppressed = true，等待动画完成后再进行requestyLayout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<span class="comment">//如果布局     发生了变化 则还需要对子视图进行重新布局</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout的布局是通过onLayout来实现的，在View中onLayout的实现是空的实现,因为view是通过其父view即viewGroup进行layout的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup的onLayout,它是个抽象方法，所有ViewGroup的子类都需要实现此方法以完成其子view的布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>我们通过以LinearLayout为例说明ViewGroup是如何进行子view的布局的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的oriention来调用不同的布局方法，这里我们看看layoutVertical。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line">    <span class="keyword">int</span> childLeft;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Where right end of child should go</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</span><br><span class="line">    <span class="keyword">int</span> childRight = width - mPaddingRight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Space available for child</span></span><br><span class="line">    <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">        <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">            <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">            childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">        <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">            childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            childTop = mPaddingTop;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                gravity = minorGravity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                            + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                childTop += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            childTop += lp.topMargin;</span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                    childWidth, childHeight);</span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;        </span><br><span class="line">    child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="draw过程"><a class="markdownIt-Anchor" href="#draw过程"></a> draw过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">boolean</span> cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||</span><br><span class="line">                    viewVisibility != View.VISIBLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<span class="comment">//既没有取消绘制，也没有创建新的Surface</span></span><br><span class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            performDraw();<span class="comment">//开始执行绘制操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// Try again</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>draw流程需要满足：</p><ol><li>未取消绘制也没有创建新的Surface,dispatchOnPreDraw返回true或者View不可见则取消绘制</li><li>未跳过此次绘制，即skipDraw为false,或者mReportNextDraw为true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        draw(fullRedrawNeeded, updateTranformHint);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded, <span class="keyword">boolean</span> updateTranformHint)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//重绘区域不为空或者正在执行动画</span></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating) &#123;</span><br><span class="line">        <span class="comment">//开启了硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (attachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// Draw with hardware renderer.</span></span><br><span class="line">            mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">            mHardwareYOffset = yoff;</span><br><span class="line">            mResizeAlpha = resizeAlpha;</span><br><span class="line"></span><br><span class="line">            mCurrentDirty.set(dirty);</span><br><span class="line">            dirty.setEmpty();</span><br><span class="line">            <span class="comment">// 硬件加速绘制</span></span><br><span class="line">            attachInfo.mHardwareRenderer.draw(mView, attachInfo, <span class="keyword">this</span>,</span><br><span class="line">                    animating ? <span class="keyword">null</span> : mCurrentDirty);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="comment">//软件绘制</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">    mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">    surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performDraw中会调用draw方法来完成绘制，draw方法中会通过attachInfo.mHardwareRenderer来判断是否启用了硬件加速，关于硬件加速我们在后面的篇幅进行讨论，这里我们假设未开启硬件加速关注软件绘制，即drawSoftware这个方法，这个方法首先会通过mSurface来取得绘制得画布canvas，并以dirty作为裁剪区域进行view绘制，最后通过unlockCanvasAndPost提交绘制得结果。这里mView就是我们的DecorView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/View.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mClipBounds != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.clipRect(mClipBounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">        * in the appropriate order:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *      1. Draw the background</span></span><br><span class="line"><span class="comment">        *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">        *      3. Draw view's content</span></span><br><span class="line"><span class="comment">        *      4. Draw children</span></span><br><span class="line"><span class="comment">        *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">        *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">        <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">                background.draw(canvas);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.translate(scrollX, scrollY);</span><br><span class="line">                background.draw(canvas);</span><br><span class="line">                canvas.translate(-scrollX, -scrollY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2, save the canvas' layers</span></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制流程的代码有点长，我做了稍微精简了下,从注释中我们可以看到绘制的具体流程分为6步：</p><ol><li>绘制背景(Draw the background)</li><li>如果需要，为view的淡隐淡出效果保存layers(If necessary, save the canvas’ layers to prepare for fading)</li><li>绘制view的内容(Draw view’s content)</li><li>绘制子view(Draw children)</li><li>如果需要，绘制淡隐淡出效果并恢复保存的layers If necessary, draw the fading edges and restore layers</li><li>绘制装饰内容，比如滚动条等 Draw decorations (scrollbars for instance)</li></ol><p>draw的第一步是进行view背景的绘制，但并不是必须的，背景资源存放在mBackground中，scrollX和scrollY都为0说明该view不用滚动，可以直接绘制其背景，否则需要进行坐标转换。一般情况下view是不带fading效果的，这时候就不需要进行第2步和第5步，否则就需要进行2到6的所有步骤。绘制view的content是通过onDraw来实现的，即真正的内容是通过子类来进行绘制的。因为view的onDraw是个空实现。绘制好自身的内容后可能该view还有子view，这时候就需要通过dispatchDraw来通知子view进行绘制，记住我们绘制的流程是从decorView开始的，它是个ViewGroup，也是整个view树的根view。我们知道ViewGroup是所有父容器的父类，所以dispatchDraw放在其中实现最合适不过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要遍历父view的所有子view通过drawChild来进行绘制。在drawChild中又回到我们view的draw绘制流程，其中会通过onDraw来进行child view的内容的绘制。整个绘制流程就是这样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;View的绘制流程是Android GUI系统中的关键部分，因为最终view中绘制的内容是要呈现给用户的。本篇基于Android4.4(KitKat)将对view绘制流程做一个全面的分析。&lt;/p&gt;
&lt;h3 id=&quot;绘制缓冲区&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>插件化/热修复原理</title>
    <link href="http://esligh.github.io/%5Bobject%20Object%5D/android-plugin-res/"/>
    <id>http://esligh.github.io/[object Object]/android-plugin-res/</id>
    <published>2017-12-22T00:40:40.000Z</published>
    <updated>2019-03-16T13:59:11.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前述"><a class="markdownIt-Anchor" href="#前述"></a> 前述</h3><h3 id="加载插件资源"><a class="markdownIt-Anchor" href="#加载插件资源"></a> 加载插件资源</h3><h4 id="独立式"><a class="markdownIt-Anchor" href="#独立式"></a> 独立式</h4><ol><li>获取插件的Resources对象</li><li>通过插件资源ID</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取对应插件的Resource对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 宿主apk的上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pluginPath 插件apk的路径，带apk名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resources <span class="title">getPluginResources</span><span class="params">(Context context, String pluginPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">        <span class="comment">// 反射调用方法addAssetPath(String path)</span></span><br><span class="line">        Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">        <span class="comment">// 将插件Apk文件添加进AssetManager</span></span><br><span class="line">        addAssetPath.invoke(assetManager, pluginPath);</span><br><span class="line">        <span class="comment">// 获取宿主apk的Resources对象</span></span><br><span class="line">        Resources superRes = context.getResources();</span><br><span class="line">        <span class="comment">// 获取插件apk的Resources对象</span></span><br><span class="line">        Resources mResources = <span class="keyword">new</span> Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加载apk获得内部资源id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context 宿主上下文</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pluginPath apk路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getResId</span><span class="params">(Context context, String pluginPath, String apkPackageName, String resName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在应用安装目录下创建一个名为app_dex文件夹目录,如果已经存在则不创建</span></span><br><span class="line">        File optimizedDirectoryFile = context.getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE);</span><br><span class="line">        <span class="comment">// 构建插件的DexClassLoader类加载器，参数：</span></span><br><span class="line">        <span class="comment">// 1、包含dex的apk文件或jar文件的路径，</span></span><br><span class="line">        <span class="comment">// 2、apk、jar解压缩生成dex存储的目录，</span></span><br><span class="line">        <span class="comment">// 3、本地library库目录，一般为null，</span></span><br><span class="line">        <span class="comment">// 4、父ClassLoader</span></span><br><span class="line">        DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(pluginPath, optimizedDirectoryFile.getPath(), <span class="keyword">null</span>, ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//通过使用apk自己的类加载器，反射出R类中相应的内部类进而获取我们需要的资源id</span></span><br><span class="line">        Class&lt;?&gt; clazz = dexClassLoader.loadClass(apkPackageName + <span class="string">".R$drawable"</span>);</span><br><span class="line">        Field field = clazz.getDeclaredField(resName);<span class="comment">//得到名为resName的这张图片字段</span></span><br><span class="line">        <span class="keyword">return</span> field.getInt(R.id.class);<span class="comment">//得到图片id</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> resId = getResId(MainActivity.<span class="keyword">this</span>.getApplication(), PATH, PLUGIN_PACKAGE_NAME, <span class="string">"ic_launcher"</span>);</span><br><span class="line">    Resources resources = getPluginResources(MainActivity.<span class="keyword">this</span>.getApplication(), PATH);</span><br><span class="line">    Drawable drawable = resources.getDrawable(resId);</span><br><span class="line">    mIvTest.setImageDrawable(drawable);</span><br></pre></td></tr></table></figure><h4 id="共享式"><a class="markdownIt-Anchor" href="#共享式"></a> 共享式</h4><ol><li>创建一个新的 AssetManager 对象，并将宿主和插件的资源都能过addAssetPath方法塞入</li><li>通过新的AssetManager对象来创建出一个新的Resources对象</li><li>将新的Resources对象替换ContextImpl中的mResources变量、LoadedApk变量里的mResources变量 以及 至空mThem变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergePluginResources</span><span class="params">(Application application, String apkName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的 AssetManager 对象</span></span><br><span class="line">    AssetManager newAssetManagerObj = AssetManager.class.newInstance();</span><br><span class="line">    Method addAssetPath = AssetManager.class.getMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">    <span class="comment">// 塞入原来宿主的资源</span></span><br><span class="line">    addAssetPath.invoke(newAssetManagerObj, application.getBaseContext().getPackageResourcePath());</span><br><span class="line">    <span class="comment">// 塞入插件的资源</span></span><br><span class="line">    File optDexFile = application.getBaseContext().getFileStreamPath(apkName);</span><br><span class="line">    addAssetPath.invoke(newAssetManagerObj, optDexFile.getAbsolutePath());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ----------------------------------------------</span></span><br><span class="line">    <span class="comment">// 创建一个新的 Resources 对象</span></span><br><span class="line">    Resources newResourcesObj = <span class="keyword">new</span> Resources(newAssetManagerObj,</span><br><span class="line">            application.getBaseContext().getResources().getDisplayMetrics(),</span><br><span class="line">            application.getBaseContext().getResources().getConfiguration());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ----------------------------------------------</span></span><br><span class="line">    <span class="comment">// 获取 ContextImpl 中的 Resources 类型的 mResources 变量，并替换它的值为新的 Resources 对象</span></span><br><span class="line">    Field resourcesField = application.getBaseContext().getClass().getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">    resourcesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    resourcesField.set(application.getBaseContext(), newResourcesObj);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ----------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 ContextImpl 中的 LoadedApk 类型的 mPackageInfo 变量</span></span><br><span class="line">    Field packageInfoField = application.getBaseContext().getClass().getDeclaredField(<span class="string">"mPackageInfo"</span>);</span><br><span class="line">    packageInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object packageInfoObj = packageInfoField.get(application.getBaseContext());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 mPackageInfo 变量对象中类的 Resources 类型的 mResources 变量，，并替换它的值为新的 Resources 对象</span></span><br><span class="line">    <span class="comment">// 注意：这是最主要的需要替换的，如果不需要支持插件运行时更新，只留这一个就可以了</span></span><br><span class="line">    Field resourcesField2 = packageInfoObj.getClass().getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">    resourcesField2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    resourcesField2.set(packageInfoObj, newResourcesObj);</span><br><span class="line">    <span class="comment">// ----------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 ContextImpl 中的 Resources.Theme 类型的 mTheme 变量，并至空它</span></span><br><span class="line">    <span class="comment">// 注意：清理mTheme对象，否则通过inflate方式加载资源会报错, 如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null</span></span><br><span class="line">    Field themeField = application.getBaseContext().getClass().getDeclaredField(<span class="string">"mTheme"</span>);</span><br><span class="line">    themeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    themeField.set(application.getBaseContext(), <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享式的插件资源会有ID冲突的问题，针对资源冲突的目前有两个方案：</p><ol><li>合并资源后重新生成resources.arsc，主要是针对resouces.arsc进行修改</li><li>修改aapt命令，对appt进行扩展。</li></ol><p>每个资源ID都是一个十六进制数，它由三部分构成</p><ol><li>PackageId 是apk包的id，默认是0x7f，默认不可变</li><li>TypeId 资源类型Id，比如像layout、string、drawable、id等等，它们对应的是：0x7f04?0x7f06?0x7f02?0x7f0b 等等，它们是按顺序从1开始递增的</li><li>ItemValue 类型Id下的资源值，从0开始递增</li></ol><p>通过修改aapt命令从而修改插件apk的PackageId解决资源ID的冲突问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前述&quot;&gt;&lt;/a&gt; 前述&lt;/h3&gt;
&lt;h3 id=&quot;加载插件资源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#加载插件资源&quot;&gt;&lt;/a&gt; 加载插件资源&lt;/h3
      
    
    </summary>
    
      <category term="AOSP" scheme="http://esligh.github.io/categories/AOSP/"/>
    
    
      <category term="Android" scheme="http://esligh.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
